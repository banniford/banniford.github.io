<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>最近踩坑合集</title>
      <link href="/2021/04/28/%E6%9C%80%E8%BF%91%E8%B8%A9%E5%9D%91%E5%90%88%E9%9B%86/"/>
      <url>/2021/04/28/%E6%9C%80%E8%BF%91%E8%B8%A9%E5%9D%91%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="最近踩坑合集"><a href="#最近踩坑合集" class="headerlink" title="最近踩坑合集"></a>最近踩坑合集</h1><p>&emsp;&emsp;上班恰好有1个月了，每天都在写 <code>markdown</code>，却没有写自己的 <code>markdown</code> 总结，以后尝试每周总结一下。</p><p>&emsp;&emsp;最近在做的是数据可视化，主要涉及的技术栈是 <code>numpy</code> ，<code>matplotlib</code>, <code>pandas</code> 内容上还是比较简单的，主要是对数据进行整理和绘图展示，在实践中还是踩了不少坑，这里整理一下。</p><h2 id="问题一：matplotlib绘制逆变波形图"><a href="#问题一：matplotlib绘制逆变波形图" class="headerlink" title="问题一：matplotlib绘制逆变波形图"></a>问题一：matplotlib绘制逆变波形图</h2><center><img src="/2021/04/28/最近踩坑合集/1.png" width="500"></center><center>(方波转正弦交流电示意图)</center><p>&emsp;&emsp;</p><a id="more"></a><p>&emsp;&emsp;这个看起来难度不大，但是我在搜资料的时候，一堆人使用 傅里叶变换进行拟合，这可难倒没学离散的我了，所以采用了土方法，利用 <strong>分割</strong> + <strong>间距</strong> 的方法。</p><p>&emsp;&emsp;思路就是自己定义个数据集，控制间距，分割以后对一些位置进行改变，最后得到所需要的图形。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#新建一个代码块</span></span><br><span class="line">m=[<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>,<span class="number">48</span>,<span class="number">64</span>]</span><br><span class="line"></span><br><span class="line">j = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(m)<span class="number">-1</span>):</span><br><span class="line">    m.insert(i+j,<span class="number">15</span>)</span><br><span class="line">    j+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"m="</span>,m)</span><br></pre></td></tr></table></figure><blockquote><p>m= [8, 15, 16, 15, 32, 15, 48, 15, 64]</p></blockquote><p>&emsp;&emsp;我们先定义一个 <code>m</code> 列表，来设置我们把 <code>1/4</code> 个周期分割的份数，那么中间肯定有间隔时间，我们加上时间间隔。</p><p>&emsp;&emsp;我们把 <code>1/4</code> 个周期的数据数量已经分好了，那我们我们需要把它们加起来算出一个整数，这个整数就是我们 <code>1/4</code> 个周期所需要的数据数量。</p><p>&emsp;&emsp;新建一个代码块，计算该整数并存储到变量 <code>M</code> 中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#新建一个代码块</span></span><br><span class="line">M=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> m:</span><br><span class="line">    M+=i</span><br><span class="line">print(<span class="string">"M="</span>,M)</span><br></pre></td></tr></table></figure><blockquote><p>M= 228</p></blockquote><p>&emsp;&emsp;现在我们得到了 <code>1/4</code> 个周期的数据数量，再乘以 <code>4</code> 就是我们一个周期的数据总数量了。</p><p>&emsp;&emsp;新建一个代码块,执行代码块查看效果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#新建一个代码块</span></span><br><span class="line">X= <span class="number">0</span></span><br><span class="line">my_X=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>*M + <span class="number">1</span>):</span><br><span class="line">    my_X.append(X)</span><br><span class="line">    <span class="comment"># 每份数据量为 pi/2 除以 M 份</span></span><br><span class="line">    X+=np.pi/(<span class="number">2</span>*M)</span><br><span class="line"></span><br><span class="line">create_figure()</span><br><span class="line">plt.plot(my_X,np.sin(my_X))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><center><img src="/2021/04/28/最近踩坑合集/2-15.png" width="500"></center><center>(构造正弦波)</center><p>&emsp;&emsp;</p><p>&emsp;&emsp;因为我们所划分的是 <code>1/4</code> 个周期，所以 每一份的数据量大小为 <code>pi/4</code> 除以 <code>M</code> 份，然后通过 <code>list.append</code> 函数添加到列表中去，我们就获得我们所需要的数据了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成矩形电波</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">period_new1</span><span class="params">(x)</span>:</span> </span><br><span class="line">    x1=np.sin(x)</span><br><span class="line">    <span class="comment">#根据条件筛选出大于0的数据并修改</span></span><br><span class="line">    y=np.where(x1&gt;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#将第一位和最后一位置为 0</span></span><br><span class="line">    y[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">    y[<span class="number">-1</span>]=<span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将矩形电波其中部分置为 0 模拟 PWM 波形</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">period_new2</span><span class="params">(y)</span>:</span> </span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> m:</span><br><span class="line">            idx+= i</span><br><span class="line">            <span class="keyword">if</span> i!= <span class="number">64</span> <span class="keyword">and</span> i!= <span class="number">15</span>:</span><br><span class="line">                y[idx:idx+<span class="number">15</span>] = <span class="number">0</span></span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(m):</span><br><span class="line">            idx+= i</span><br><span class="line">            <span class="keyword">if</span> i!= <span class="number">8</span> <span class="keyword">and</span> i!= <span class="number">15</span>:</span><br><span class="line">                y[idx:idx+<span class="number">15</span>] = <span class="number">0</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">create_figure()</span><br><span class="line">my_y1= period_new1(my_X)</span><br><span class="line">my_y2= period_new2(my_y1.copy())</span><br><span class="line"></span><br><span class="line">plt.plot()</span><br><span class="line">plt.plot(my_X,np.sin(my_X),<span class="string">'b-'</span>)  </span><br><span class="line">plt.plot(my_X,my_y1, color=<span class="string">'r'</span>, linestyle=<span class="string">'-'</span>);  </span><br><span class="line">plt.plot(my_X,my_y2,color=<span class="string">'#2ea338'</span>, linestyle=<span class="string">'-'</span>) </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><center><img src="/2021/04/28/最近踩坑合集/2.png" width="500"></center><center>(方波与正弦波)</center><p>&emsp;&emsp;</p><h2 id="问题二：-解决jpyter-node-中使用-matplotlib-画图中文字体的问题"><a href="#问题二：-解决jpyter-node-中使用-matplotlib-画图中文字体的问题" class="headerlink" title="问题二： 解决jpyter node 中使用 matplotlib 画图中文字体的问题"></a>问题二： 解决jpyter node 中使用 matplotlib 画图中文字体的问题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建代码块</span></span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> mpl</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="comment"># 更换当前字体库为 SimHei -&gt;黑体</span></span><br><span class="line">matplotlib.rc(<span class="string">"font"</span>,family=<span class="string">'SimHei'</span>)</span><br><span class="line"><span class="comment"># 解决保存图像是负号'-'显示为方块的问题</span></span><br><span class="line">plt.rcParams[<span class="string">"figure.dpi"</span>] =mpl.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;因为每个电脑的字体库可能有所不同，所以如果出现缺少 <code>SimHei</code> 的话会出现 <code>error</code> 错误，并且无法渲染中文字体，那么可以新建代码块运行以下代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建代码块</span></span><br><span class="line"><span class="comment"># 查询当前系统所有字体</span></span><br><span class="line"><span class="keyword">from</span> matplotlib.font_manager <span class="keyword">import</span> FontManager</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">mpl_fonts = set(f.name <span class="keyword">for</span> f <span class="keyword">in</span> FontManager().ttflist)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'all font list get from matplotlib.font_manager:'</span>)</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> sorted(mpl_fonts):</span><br><span class="line">    print(<span class="string">'\t'</span> + f)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以尝试将 <code>matplotlib.rc(&quot;font&quot;,family=&#39;SimHei&#39;)</code> 中的 <code>SimHei</code> 更换为 <strong>其他</strong> 字体尝试，一般中文字体库会以 <strong>拼音</strong> 的形式存在。</p><p>&emsp;&emsp;当然还有很多一劳永逸的方式，直接更改文件就好了，但是这种方法对于在云平台使用起来的话更加的灵活。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>json格式在python中的类型转换</title>
      <link href="/2021/04/14/json%E6%A0%BC%E5%BC%8F%E5%9C%A8python%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>/2021/04/14/json%E6%A0%BC%E5%BC%8F%E5%9C%A8python%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;最近在进行数据分析时，处理 <code>json</code>格式的数据遇到了坑，主要对 <code>json</code> 本身不了解，导致解析过后<code>python</code>不识别，我还纳闷，同样的东西，为啥格式不对，原来 <code>None</code> 和 <code>null</code> 也是有区别的。不过使用 <code>eval()</code> 还真挺好使，就是需要考虑一些安全性问题。</p><p>&emsp;&emsp;<code>JSON: JavaScript Object Notation</code> ( <code>JavaScript</code> 对象表示法)， <code>JSON</code> 是存储和交换文本信息的语法，类似 <code>XML</code>，<code>JSON</code> 比 <code>XML</code> 更小、更快，更易解析。</p><p>&emsp;&emsp;<code>JSON</code> 语法是 <code>JavaScript</code> 语法的子集：</p><ul><li><p>数据在名称/值对中</p></li><li><p>数据由逗号分隔</p></li><li><p>大括号 { } 保存对象</p></li><li><p>中括号 [ ] 保存数组，数组可以包含多个对象</p></li></ul><a id="more"></a><p>&emsp;&emsp;<strong>JSON 数据的书写格式是：</strong></p><blockquote><p>key : value</p></blockquote><p>&emsp;&emsp;<code>JSON</code> 的 <code>value</code> 值可以是：<strong>数字（整数或浮点数）</strong>、<strong>字符串（在双引号中）</strong>、<strong>逻辑值（true 或 false）</strong>、<strong>数组（在中括号中）</strong>、<strong>对象（在大括号中）</strong>、<strong>null</strong> ，需要注意的是，<code>key</code> 值必须加 <strong>双引号</strong> ，<code>value</code> 中，字符串必须加 <strong>双引号</strong> ，其他类型不要加 <strong>双引号</strong> ，以上写法必须严格遵循，否则将不会被判定为 <code>JSON</code> 格式。</p><p>实例演示：</p><p>使用 <code>eval()</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_fea_text</span><span class="params">(data_str)</span>:</span></span><br><span class="line">    data_str=eval(data_str)</span><br><span class="line">    <span class="keyword">if</span> len(data) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> data_str[<span class="number">0</span>][<span class="string">'text'</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>使用 <code>json</code> 库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_fea_text</span><span class="params">(data_str)</span>:</span></span><br><span class="line">    <span class="comment"># 将文字中的"前加 \ 进行转义</span></span><br><span class="line">    data = data.replace(<span class="string">'"'</span>,<span class="string">'\\"'</span>)</span><br><span class="line">    <span class="comment"># 将单引号' 转为 双引号 "</span></span><br><span class="line">    data = data.replace(<span class="string">'\''</span>,<span class="string">'\"'</span>)</span><br><span class="line">    <span class="comment"># 将 None 转为 null</span></span><br><span class="line">    data = data.replace(<span class="string">'None'</span>,<span class="string">'null'</span>)</span><br><span class="line">    <span class="comment"># 将字符串转换为 json 对象</span></span><br><span class="line">    data=json.loads(data)</span><br><span class="line">    <span class="keyword">if</span> len(data) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> data[<span class="number">0</span>][<span class="string">'text'</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> 因为 <code>json</code> 解析的缘故，在解析过程中，会将 <code>null</code> 转化为 <code>None</code> ， <code>Python</code> 解释器虽然可以对单双引号没有特定的区分，但是在 <code>json</code> 语句中必须使用 <strong>双引号 “”</strong> ，也要注意在字符串中如果本身含有 <strong>双引号</strong>，要加 <strong>反斜杠</strong> <code>\</code> 进行字符的转义，否则也会转换过程也会出错。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python内存管理机制</title>
      <link href="/2021/03/10/python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"/>
      <url>/2021/03/10/python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="python内存管理机制"><a href="#python内存管理机制" class="headerlink" title="python内存管理机制"></a>python内存管理机制</h1><p>引用计数器为主 标记清除和分代回收为辅+缓存机制</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python函数装饰器</title>
      <link href="/2021/03/06/python%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
      <url>/2021/03/06/python%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Python-函数装饰器"><a href="#Python-函数装饰器" class="headerlink" title="Python 函数装饰器"></a>Python 函数装饰器</h1><p>装饰器(Decorators)是 Python 的一个重要部分。简单地说：他们是修改其他函数的功能的函数。他们有助于让我们的代码更简短，也更Pythonic（Python范儿）。 </p><h3 id="一切皆为对象"><a href="#一切皆为对象" class="headerlink" title="一切皆为对象"></a>一切皆为对象</h3><p>对于python中的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hi</span><span class="params">(name=<span class="string">"you"</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hi "</span> + name</span><br><span class="line"> </span><br><span class="line">print(hi())</span><br><span class="line"><span class="comment"># output: 'hi you'</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 我们甚至可以将一个函数赋值给一个变量，比如</span></span><br><span class="line">greet = hi</span><br><span class="line"><span class="comment"># 我们这里没有在使用小括号，因为我们并不是在调用hi函数</span></span><br><span class="line"><span class="comment"># 而是在将它放在greet变量里头。我们尝试运行下这个</span></span><br><span class="line"> </span><br><span class="line">print(greet())</span><br><span class="line"><span class="comment"># output: 'hi you'</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 如果我们删掉旧的hi函数，看看会发生什么！</span></span><br><span class="line"><span class="keyword">del</span> hi</span><br><span class="line">print(hi())</span><br><span class="line"><span class="comment">#outputs: NameError</span></span><br><span class="line"> </span><br><span class="line">print(greet())</span><br><span class="line"><span class="comment">#outputs: 'hi you'</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="在函数中定义函数"><a href="#在函数中定义函数" class="headerlink" title="在函数中定义函数"></a>在函数中定义函数</h3><p>函数中的函数属于私有函数，外部无法直接调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hi</span><span class="params">(name=<span class="string">"yasoob"</span>)</span>:</span></span><br><span class="line">    print(<span class="string">"now you are inside the hi() function"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"now you are in the greet() function"</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">welcome</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"now you are in the welcome() function"</span></span><br><span class="line"> </span><br><span class="line">    print(greet())</span><br><span class="line">    print(welcome())</span><br><span class="line">    print(<span class="string">"now you are back in the hi() function"</span>)</span><br><span class="line"> </span><br><span class="line">hi()</span><br><span class="line"><span class="comment">#output:now you are inside the hi() function</span></span><br><span class="line"><span class="comment">#       now you are in the greet() function</span></span><br><span class="line"><span class="comment">#       now you are in the welcome() function</span></span><br><span class="line"><span class="comment">#       now you are back in the hi() function</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 上面展示了无论何时你调用hi(), greet()和welcome()将会同时被调用。</span></span><br><span class="line"><span class="comment"># 然后greet()和welcome()函数在hi()函数之外是不能访问的，比如：</span></span><br><span class="line"> </span><br><span class="line">greet()</span><br><span class="line"><span class="comment">#outputs: NameError: name 'greet' is not defined</span></span><br></pre></td></tr></table></figure><h3 id="从函数中返回函数"><a href="#从函数中返回函数" class="headerlink" title="从函数中返回函数"></a>从函数中返回函数</h3><p>当将函数名本身作为返回值时 <code>a=f</code>，则是将<strong>函数地址返回</strong>，并不是调用函数，而如果将函数赋值给变量<code>a=f()</code>，则是将<code>f()</code>的返回值<strong>赋值给a</strong>的过程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hi</span><span class="params">(name=<span class="string">"yasoob"</span>)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"now you are in the greet() function"</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">welcome</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"now you are in the welcome() function"</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">"yasoob"</span>:</span><br><span class="line">        <span class="keyword">return</span> greet</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> welcome</span><br><span class="line"> </span><br><span class="line">a = hi()</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment">#outputs: &lt;function greet at 0x7f2143c01500&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#上面清晰地展示了`a`现在指向到hi()函数中的greet()函数</span></span><br><span class="line"><span class="comment">#现在试试这个</span></span><br><span class="line"> </span><br><span class="line">print(a())</span><br><span class="line"><span class="comment">#outputs: now you are in the greet() function</span></span><br><span class="line">b=hi()()</span><br><span class="line">print(b)</span><br><span class="line"><span class="comment">#outputs: now you are in the greet() function</span></span><br></pre></td></tr></table></figure><p>在上述代码中，使用 判断语句返回了 <code>greet</code> 和 <code>welcome</code> ，而不是<code>greet()</code> 和 <code>welcome()</code> ,那么上面的<code>a()</code>和<code>b</code>的结果就是一样的。</p><h3 id="将函数作为参数传给另一个函数"><a href="#将函数作为参数传给另一个函数" class="headerlink" title="将函数作为参数传给另一个函数"></a>将函数作为参数传给另一个函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hi</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hi yasoob!"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doSomethingBeforeHi</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">"I am doing some boring work before executing hi()"</span>)</span><br><span class="line">    print(func())</span><br><span class="line"> </span><br><span class="line">doSomethingBeforeHi(hi)</span><br><span class="line"><span class="comment">#outputs:I am doing some boring work before executing hi()</span></span><br><span class="line"><span class="comment">#        hi yasoob!</span></span><br></pre></td></tr></table></figure><p>当函数为变量名时，指向地址 可将函数本身作为参数传向函数调用。</p><p>那么装饰器的用法就出现了，可以将函数本身插入某段代码之中。<strong>（类似jvav中spring框架的依赖注解）</strong></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_new_decorator</span><span class="params">(a_func)</span>:</span><span class="comment">#定义装饰器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapTheFunction</span><span class="params">()</span>:</span><span class="comment"># 定义一个包装函数</span></span><br><span class="line">        print(<span class="string">"add something before"</span>)</span><br><span class="line">        </span><br><span class="line">        a_func()</span><br><span class="line">        </span><br><span class="line">        print(<span class="string">"add somthing after"</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> wrapTheFunction <span class="comment">#返回包装函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"我是执行函数"</span>)</span><br><span class="line">    </span><br><span class="line">a=a_new_decorator(func) <span class="comment">#将返回的函数赋值给a</span></span><br><span class="line">a()<span class="comment">#调用函数</span></span><br><span class="line"><span class="comment">#outputs: add something before</span></span><br><span class="line"><span class="comment">#         我是执行函数</span></span><br><span class="line"><span class="comment">#         add somthing after</span></span><br></pre></td></tr></table></figure><p>我们用装饰器封装了一个函数，那么我们可以用<code>@</code>来进行注解注入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@a_new_decorator </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"我是执行函数1"</span>)</span><br><span class="line"></span><br><span class="line">func1()</span><br><span class="line"><span class="comment">#outputs: add something before</span></span><br><span class="line"><span class="comment">#         我是执行函数1</span></span><br><span class="line"><span class="comment">#         add somthing after</span></span><br></pre></td></tr></table></figure><p><code>@a_new_decorator</code>相当于<code>a=a_new_decorator(func1)</code>那么注解@就相当于将当前函数注入装饰器中，那么调用当前这个函数，就是将当前函数装饰后返回结果。</p><p>但是此时要注意</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(func1.__name__)</span><br><span class="line"><span class="comment"># Output: wrapTheFunction</span></span><br></pre></td></tr></table></figure><p>对于正常函数来说，应该返回函数本身的名称即<code>func1</code></p><p> 这里的函数被warpTheFunction替代了。它重写了我们函数的名字和注释文档(docstring)。幸运的是Python提供给我们一个简单的函数来解决这个问题，那就是functools.wraps。我们修改上一个例子来使用functools.wraps： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_new_decorator</span><span class="params">(a_func)</span>:</span><span class="comment">#定义装饰器</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @wraps(a_func)#解决函数名装饰时被修改的问题</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapTheFunction</span><span class="params">()</span>:</span><span class="comment"># 定义一个包装函数</span></span><br><span class="line">        print(<span class="string">"add something before"</span>)</span><br><span class="line">        </span><br><span class="line">        a_func()</span><br><span class="line">        </span><br><span class="line">        print(<span class="string">"add somthing after"</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> wrapTheFunction <span class="comment">#返回包装函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@a_new_decorator #a=a_new_decorator(func) 那么注解@就相当于将当前函数注入装饰器中，那么调用这个函数，就是带装饰器打包</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"我是执行函数1"</span>)</span><br><span class="line"></span><br><span class="line">func1()</span><br><span class="line">print(func1.__name__)</span><br><span class="line"><span class="comment"># Output: func1</span></span><br></pre></td></tr></table></figure><p>蓝本规范：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_name</span><span class="params">(f)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(f)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorated</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> can_run:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Function will not run"</span></span><br><span class="line">        <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> decorated</span><br><span class="line"> </span><br><span class="line"><span class="meta">@decorator_name</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span>(<span class="string">"Function is running"</span>)</span><br><span class="line"> </span><br><span class="line">can_run = <span class="literal">True</span></span><br><span class="line">print(func())</span><br><span class="line"><span class="comment"># Output: Function is running</span></span><br><span class="line"> </span><br><span class="line">can_run = <span class="literal">False</span></span><br><span class="line">print(func())</span><br><span class="line"><span class="comment"># Output: Function will not run</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong><code>@wraps</code>接受一个函数来进行装饰，并加入了复制函数名称、注释文档、参数列表等等的功能。这可以让我们在装饰器里面访问在装饰之前的函数的属性。</p><h4 id="关于args，-kwargs的小知识"><a href="#关于args，-kwargs的小知识" class="headerlink" title="关于args，*kwargs的小知识"></a>关于<em>args，*</em>kwargs的小知识</h4><p>答：可变参数 </p><ul><li>如果我们不确定要往函数中传入多少个参数，或者我们想往函数中以列表和元组的形式传参数时，那就使要用<code>*args</code>， <strong>输出结果以元组的形式展示</strong> ；</li><li>如果我们不知道要往函数中传入多少个关键词参数，或者想传入字典的值作为关键词参数时，那就要使用<code>**kwargs</code>，它将打包关键字参数成dict给函数体调用， <strong>输出结果以列表形式展示</strong>  。 </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">L=(<span class="number">1</span>,<span class="number">2</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(*args)</span>:</span></span><br><span class="line">    print(type(args),args)</span><br><span class="line">test(L)</span><br><span class="line">test(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">test(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#outputs:</span></span><br><span class="line"><span class="comment">#      &lt;class 'tuple'&gt; ((1, 2, [1, 2, 3]),)</span></span><br><span class="line"><span class="comment">#      &lt;class 'tuple'&gt; (1, 2)</span></span><br><span class="line"><span class="comment">#      &lt;class 'tuple'&gt; (1,)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    print(type(kwargs),kwargs)</span><br><span class="line">    </span><br><span class="line">info=&#123;<span class="string">'id'</span>:<span class="number">1</span>,<span class="string">'age'</span>:<span class="number">15</span>,<span class="string">'name'</span>:<span class="string">"老王"</span>&#125;</span><br><span class="line"></span><br><span class="line">test1()</span><br><span class="line">test1(id=<span class="number">1</span>,age=<span class="number">15</span>,name=<span class="string">"老王"</span>)</span><br><span class="line">test1(id=info[<span class="string">'id'</span>],name=info[<span class="string">'name'</span>],age=info[<span class="string">'age'</span>])</span><br><span class="line"><span class="comment">#outputs:</span></span><br><span class="line"><span class="comment">#        &lt;class 'dict'&gt; &#123;&#125;</span></span><br><span class="line"><span class="comment">#        &lt;class 'dict'&gt; &#123;'id': 1, 'age': 15, 'name': '老王'&#125;</span></span><br><span class="line"><span class="comment">#         &lt;class 'dict'&gt; &#123;'id': 1, 'name': '老王', 'age': 15&#125;</span></span><br></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="授权-Authorization"><a href="#授权-Authorization" class="headerlink" title="授权(Authorization)"></a>授权(Authorization)</h4><p> 装饰器能有助于检查某个人是否被授权去使用一个web应用的端点(endpoint)。它们被大量使用于Flask和Django web框架中。这里是一个例子来使用基于装饰器的授权： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">requires_auth</span><span class="params">(f)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(f)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorated</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        auth = request.authorization</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> auth <span class="keyword">or</span> <span class="keyword">not</span> check_auth(auth.username, auth.password):</span><br><span class="line">            authenticate()</span><br><span class="line">        <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> decorated</span><br></pre></td></tr></table></figure><h4 id="日志-Logging"><a href="#日志-Logging" class="headerlink" title="日志(Logging)"></a>日志(Logging)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logit</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">with_logging</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(func.__name__ + <span class="string">" was called"</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)<span class="comment">#返回被装饰函数的返回值 即x+x</span></span><br><span class="line">    <span class="keyword">return</span> with_logging</span><br><span class="line"> </span><br><span class="line"><span class="meta">@logit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addition_func</span><span class="params">(x)</span>:</span></span><br><span class="line">   <span class="string">"""Do some math."""</span></span><br><span class="line">   <span class="keyword">return</span> x + x</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">result = addition_func(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># Output: addition_func was called</span></span><br><span class="line">result</span><br><span class="line"><span class="comment"># Output: 8</span></span><br></pre></td></tr></table></figure><hr><h3 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h3><h4 id="在函数中嵌入装饰器"><a href="#在函数中嵌入装饰器" class="headerlink" title="在函数中嵌入装饰器"></a>在函数中嵌入装饰器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logit</span><span class="params">(logfile=<span class="string">'out.log'</span>)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">logging_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">        @wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapped_function</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            log_string = func.__name__ + <span class="string">" was called"</span></span><br><span class="line">            print(log_string)</span><br><span class="line">            <span class="comment"># 打开logfile，并写入内容</span></span><br><span class="line">            <span class="keyword">with</span> open(logfile, <span class="string">'a'</span>) <span class="keyword">as</span> opened_file:</span><br><span class="line">                <span class="comment"># 现在将日志打到指定的logfile</span></span><br><span class="line">                opened_file.write(log_string + <span class="string">'\n'</span>)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapped_function</span><br><span class="line">    <span class="keyword">return</span> logging_decorator</span><br><span class="line"> </span><br><span class="line"><span class="meta">@logit()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line">myfunc1()</span><br><span class="line"><span class="comment"># Output: myfunc1 was called</span></span><br><span class="line"><span class="comment"># 现在一个叫做 out.log 的文件出现了，里面的内容就是上面的字符串</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@logit(logfile='func2.log')#通过外包装函数可以</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line">myfunc2()</span><br><span class="line"><span class="comment"># Output: myfunc2 was called</span></span><br><span class="line"><span class="comment"># 现在一个叫做 func2.log 的文件出现了，里面的内容就是上面的字符串</span></span><br></pre></td></tr></table></figure><h4 id="装饰器类"><a href="#装饰器类" class="headerlink" title="装饰器类"></a>装饰器类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">logit</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, logfile=<span class="string">'out.log'</span>)</span>:</span></span><br><span class="line">        self.logfile = logfile</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, func)</span>:</span></span><br><span class="line"><span class="meta">        @wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapped_function</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            log_string = func.__name__ + <span class="string">" was called"</span></span><br><span class="line">            print(log_string)</span><br><span class="line">            <span class="comment"># 打开logfile并写入</span></span><br><span class="line">            <span class="keyword">with</span> open(self.logfile, <span class="string">'a'</span>) <span class="keyword">as</span> opened_file:</span><br><span class="line">                <span class="comment"># 现在将日志打到指定的文件</span></span><br><span class="line">                opened_file.write(log_string + <span class="string">'\n'</span>)</span><br><span class="line">            <span class="comment"># 现在，发送一个通知</span></span><br><span class="line">            self.notify()</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapped_function</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">notify</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># logit只打日志，不做别的</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="meta">@logit()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">email_logit</span><span class="params">(logit)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    一个logit的实现版本，可以在函数调用时发送email给管理员</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, email=<span class="string">'admin@myproject.com'</span>, *args, **kwargs)</span>:</span></span><br><span class="line">        self.email = email</span><br><span class="line">        super(email_logit, self).__init__(*args, **kwargs)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">notify</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 发送一封email到self.email</span></span><br><span class="line">        <span class="comment"># 这里就不做实现了</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p> 从现在起，@email_logit 将会和 @logit 产生同样的效果，但是在打日志的基础上，还会多发送一封邮件给管理员。 </p><p>被面试官问到的悲惨经历，就突然想不起来了~~</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据分析工具</title>
      <link href="/2021/03/02/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
      <url>/2021/03/02/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h1><p>简介：开源的Python科学计算库，方便使用数组、矩阵运算，包含线性代数、傅里叶变换、随机数生成等大量函数。</p><h3 id="为什么使用-Numpy？"><a href="#为什么使用-Numpy？" class="headerlink" title="为什么使用 Numpy？"></a>为什么使用 Numpy？</h3><p>对于同样的数值计算任务，使用Numpy比直接编写Python代码实现，优点：</p><ul><li>代码更简洁：Numpy 直接以数组、矩阵为<strong>粒度</strong>计算并且支持大量的数学函数，而Python需要多层<strong>for循环</strong>从底层实现；</li><li>性能更加高效：Numpy的数组存储效率和输入输出计算性能，比Python使用List好很多；<ul><li>注：Numpy的<strong>数据存储</strong>和Python原生的<strong>List</strong>是不一样的</li><li>注：Numpy 的大部分都是<strong>C语言</strong>实现的，这是Numpy比纯Python代码高效的原因；</li></ul></li></ul><p>Numpy 是 Python各种数据科学类库的基础库：</p><ul><li>比如SciPy、Scikit-Learn、Tensorflow、PaddlePaddle等</li></ul><a id="more"></a><h3 id="NdarrayObject"><a href="#NdarrayObject" class="headerlink" title="NdarrayObject"></a>NdarrayObject</h3><p>1、ndarray用于存储同类型元素的多维数组</p><p>2、ndarray中的每个元素在内存中都有相同的存储大小区域</p><p>3、 ndarray 内部由以下内容组成： </p><ul><li>一个指向数据（内存或内存映射文件中的一块数据）的指针。 </li><li>数据类型或 dtype，描述在数组中的固定大小值的格子。 </li><li>一个表示数组形状（shape）的元组，表示各维度大小的元组。 </li><li>一个跨度元组（stride），其中的整数指的是为了前进到当前维度下一个元素需要”跨过”的字节数。 </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">numpy.array(object, dtype = <span class="literal">None</span>, copy = <span class="literal">True</span>, order = <span class="literal">None</span>, subok = <span class="literal">False</span>, ndmin = <span class="number">0</span>)</span><br><span class="line">np.arange(start,stop,step,dtype)</span><br><span class="line">np.ones(shape,dtype=<span class="literal">None</span>,order=<span class="string">'C'</span>)<span class="comment">#创建全是1的数组</span></span><br><span class="line">np.ones_like(x)<span class="comment">#根据现有的矩阵创建一个与其形状相同的矩阵</span></span><br><span class="line">np.zeros<span class="comment">#类似</span></span><br><span class="line">np.empty<span class="comment">#未初始化的数组</span></span><br><span class="line">np.full(shape,fill_value,dtype=<span class="literal">None</span>,order=<span class="string">'C'</span>)<span class="comment">#使用full创建指定值填充满的数组</span></span><br><span class="line">np.random.randn()<span class="comment">#不传返回一个数，多个返回列表或数组</span></span><br></pre></td></tr></table></figure><p><strong>创建array的方法</strong></p><ul><li>从Python的列表List和嵌套列表array</li><li>使用预定函数arange、ones/ones_like、zeros/zeros_like、emtpy/empty_like、full/full_like、eye等函数创建</li><li>生成随机数的np.random模块构建</li></ul><p><strong>array本身支持的大量操作和函数</strong></p><ul><li>直接逐元素的加减乘除等算数操作</li><li>更好的面向多维的数组索引</li><li>求sum/mean等聚合函数</li><li>线性代数函数，比如求解逆矩阵、求解方程组</li></ul><h3 id="Numpy对数组按索引查询"><a href="#Numpy对数组按索引查询" class="headerlink" title="Numpy对数组按索引查询"></a>Numpy对数组按索引查询</h3><p>基础索引、神奇索引、布尔索引</p><h4 id="基础索引"><a href="#基础索引" class="headerlink" title="基础索引"></a>基础索引</h4><p>一维数组与List操作相似</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#二维数组 分别用行坐标和列坐标实现行列筛选</span></span><br><span class="line">X[<span class="number">0</span>,<span class="number">0</span>]<span class="comment">#坐标</span></span><br><span class="line">X[<span class="number">-1</span>,<span class="number">2</span>]</span><br><span class="line">X[<span class="number">-1</span>]<span class="comment">#倒数第一行</span></span><br><span class="line">X[:,<span class="number">2</span>]=<span class="number">111</span><span class="comment">#第三列</span></span><br></pre></td></tr></table></figure><p>注意：Numpy切片修改会修改原数组</p><h4 id="神奇索引"><a href="#神奇索引" class="headerlink" title="神奇索引"></a>神奇索引</h4><p>用整数数组进行索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#通过构建列表索引可以筛选数据</span></span><br><span class="line">indexs=np.array([[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>]])</span><br><span class="line">X[indexs]<span class="comment">#可将对应的行索引数据筛选出来 二维数组</span></span><br><span class="line">X[[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>]] <span class="comment">#对应坐标！！！！！！！！</span></span><br><span class="line"></span><br><span class="line">实例：获取数组中最大的前N个数字</span><br><span class="line"><span class="comment"># 随机生成1-100之间的10个数字 不包括1，100</span></span><br><span class="line">arr = np.random.randint(<span class="number">1</span>,<span class="number">100</span>,<span class="number">10</span>)</span><br><span class="line"><span class="comment">#arr.argsort()会返回排序后的索引index</span></span><br><span class="line"><span class="comment">#取最大值对应得3个 下标</span></span><br><span class="line">arr.argsort()[<span class="number">-3</span>:]</span><br><span class="line">arr[arr.argsort()[<span class="number">-3</span>:]]<span class="comment">#获取数组中最大的前3个数字</span></span><br></pre></td></tr></table></figure><h4 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h4><p>通过条件可以降维或者查找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">X&gt;<span class="number">5</span><span class="comment">#返回true flase 相当于降维</span></span><br><span class="line">X[X&gt;<span class="number">5</span>] <span class="comment">#返回 满足条件的数字列表一维</span></span><br><span class="line">X[X&gt;<span class="number">5</span>]=<span class="number">0</span></span><br><span class="line">X[X&lt;=<span class="number">5</span>]=<span class="number">1</span></span><br><span class="line">X[X[:,<span class="number">3</span>]&gt;<span class="number">5</span>] <span class="comment">#返回第三个值（列）大于5的所有行 可以更改值=111</span></span><br><span class="line">condition=(x%<span class="number">2</span>==<span class="number">0</span>) | (x&gt;<span class="number">7</span>)</span><br><span class="line">X[condition]<span class="comment">#筛选偶数或大于7 的数</span></span><br></pre></td></tr></table></figure><p>random随机函数</p><p><img src="/2021/03/02/数据分析工具/1.jpg" alt></p><p>Numpy常用的数字统计函数</p><p><img src="/2021/03/02/数据分析工具/2.jpg" alt></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>Numpy怎样给数组增加一个维度</p><p>需要：</p><p>在不改变数据的情况下，添加数组维度；（注意观察这个例子，维度变了，但数据不变）原始数组：一维数组arr=[1,2,3,4],其中shape是（4，），取值分别为arr[0],arr[1],arr[2],arr[3]变形数组：二维数组arr[[1，2，3，4]] 其shape是(1,4)，取值分别为a[0,0]a[0,1]a[0,2]a[0,3]</p><p>实操：</p><p>经常需要在纸上手绘数组的形状，来查看不同数组是否形状匹配，是否需要升维和降维</p><p>3种方法：</p><ul><li>np.newaxis: 关键字，使用索引和语法给数组添加维度</li><li>np.expand_dims(arr,axis): 方法，和np.newaxis实现一样的功能，给arr在axis位置添加维度</li><li>np.reshape(a,newshape):方法，给一个维度设置为1完成升维</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">arr = np.arange(<span class="number">5</span>)</span><br><span class="line">arr.shape<span class="comment">#(5,)</span></span><br></pre></td></tr></table></figure><p>方法一：</p><p>注意：np.newaxis其实就是None的别名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.newaxis <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">np.newaxis == <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>所以下方演示中 np.newaxis 可以用 None 替代</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加一个行维度</span></span><br><span class="line">arr[np.newaxis,:]</span><br><span class="line">arr[np.newaxis,:].shape<span class="comment">#(5,1)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加一个列维度</span></span><br><span class="line">arr[:,np.newaxis]</span><br><span class="line">arr[:,np.newaxis].shape<span class="comment">#(1,5)</span></span><br></pre></td></tr></table></figure><p>方法二：</p><p>np.expand_dims 方法实现的效果，和np.newaxis 关键字是一模一样的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加一个行维度</span></span><br><span class="line"><span class="comment">#相当于arr[np.newaxis,:]</span></span><br><span class="line">np.expand_dims(arr,axis=<span class="number">0</span>)</span><br><span class="line">np.expand_dims(arr,axis=<span class="number">0</span>).shape</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加一个列维度</span></span><br><span class="line">np.expand_dims(arr,axis=<span class="number">1</span>)</span><br><span class="line">np.expand_dims(arr,axis=<span class="number">1</span>).shape</span><br></pre></td></tr></table></figure><p>方法三：</p><p>np.reshape 方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加一个行维度</span></span><br><span class="line">np.reshape(arr,(<span class="number">1</span>,<span class="number">5</span>))</span><br><span class="line">np.reshape(arr,(<span class="number">1</span>,<span class="number">-1</span>))<span class="comment">#-1自动计算</span></span><br><span class="line">np.reshape(arr,(<span class="number">1</span>,<span class="number">-1</span>)).shape</span><br><span class="line"><span class="comment">#添加一个列维度</span></span><br><span class="line">np.reshape(arr,(<span class="number">-1</span>,<span class="number">1</span>))</span><br><span class="line">np.reshape(arr,(<span class="number">-1</span>,<span class="number">1</span>)).shape</span><br></pre></td></tr></table></figure><h1 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h1><p> pandas 是基于NumPy的一种工具， 使数据预处理、清洗、分析工作变得更快更简单。pandas是专门为处理表格和混杂数据设计的，而NumPy更适合处理统一的数值数组数据。 </p><p> <strong>pandas有两个主要数据结构：Series和DataFrame</strong></p><h3 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h3><p>Series是一种类似于一维数组的对象，它由<strong>一组数据</strong>（各种NumPy数据类型）以及一组与之相关的<strong>数据标签（即索引）</strong>组成，即index和values两部分，可以通过索引的方式选取Series中的单个或一组值。</p><p><strong>pd.Series(list,index=[])</strong>, 第二个参数是Series中数据的索引，可以省略。</p><ul><li>第一个参数可以是列表 ndarray</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np,pandas <span class="keyword">as</span> pd</span><br><span class="line">arr1=np.arange(<span class="number">10</span>)</span><br><span class="line">s1=pd.Series(arr1)</span><br><span class="line">print(s1) <span class="comment"># 由于我们没有为数据指定索引，于是会自动创建一个0到N-1(N为数据的长度)的整数型索引</span></span><br></pre></td></tr></table></figure><ul><li>第一个参数可以是字典，字典的键将作为Series的索引 </li><li>第一个参数可以是DataFrame中的某一行或某一列 </li></ul><h3 id="Series类型的操作"><a href="#Series类型的操作" class="headerlink" title="Series类型的操作"></a>Series类型的操作</h3><p>Series类型索引、切片、运算的操作类似于ndarray，同样的类似Python字典类型的操作，包括保留字in操作、使用.get()方法。<br> Series和ndarray之间的主要区别在于Series之间的操作会根据索引自动对齐数据。</p><h3 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h3><p>DataFrame是一个表格型的数据类型，每列值类型可以不同，是最常用的pandas对象。DataFrame既有行索引也有列索引，它可以被看做由Series组成的字典（共用同一个索引）。DataFrame中的数据是以一个或多个二维块存放的（而不是列表、字典或别的一维数据结构）。</p><h3 id="DataFrame的创建"><a href="#DataFrame的创建" class="headerlink" title="DataFrame的创建"></a>DataFrame的创建</h3><p> <strong>pd.DataFrame(data,columns = [ ],index = [ ])</strong>：columns和index为指定的列、行索引，并按照顺序排列。 </p><ul><li>创建DataFrame最常用的是直接传入一个由等长列表或NumPy数组组成的<strong>字典</strong>，会自动加上行索引，字典的<strong>键</strong>会被当做<strong>列索引</strong>： </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = &#123;<span class="string">'state'</span>: [<span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Nevada'</span>, <span class="string">'Nevada'</span>, <span class="string">'Nevada'</span>],</span><br><span class="line">        <span class="string">'year'</span>: [<span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2003</span>],</span><br><span class="line">        <span class="string">'pop'</span>: [<span class="number">1.5</span>, <span class="number">1.7</span>, <span class="number">3.6</span>, <span class="number">2.4</span>, <span class="number">2.9</span>, <span class="number">3.2</span>]&#125;</span><br><span class="line">df= pd.DataFrame(data)</span><br><span class="line">In [<span class="number">45</span>]: df</span><br><span class="line">Out[<span class="number">45</span>]: </span><br><span class="line">   pop   state  year</span><br><span class="line"><span class="number">0</span>  <span class="number">1.5</span>    Ohio  <span class="number">2000</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.7</span>    Ohio  <span class="number">2001</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3.6</span>    Ohio  <span class="number">2002</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2.4</span>  Nevada  <span class="number">2001</span></span><br><span class="line"><span class="number">4</span>  <span class="number">2.9</span>  Nevada  <span class="number">2002</span></span><br><span class="line"><span class="number">5</span>  <span class="number">3.2</span>  Nevada  <span class="number">2003</span></span><br></pre></td></tr></table></figure><p> 如果创建时指定了columns和index索引，则按照索引顺序排列，并且如果传入的列在数据中找不到，就会在结果中产生缺失值： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">48</span>]: df2 = pd.DataFrame(data, columns=[<span class="string">'year'</span>, <span class="string">'state'</span>, <span class="string">'pop'</span>, <span class="string">'debt'</span>],</span><br><span class="line">   ....:                       index=[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>, <span class="string">'five'</span>, <span class="string">'six'</span>])</span><br><span class="line">In [<span class="number">49</span>]: df2</span><br><span class="line">Out[<span class="number">49</span>]: </span><br><span class="line">       year   state  pop debt</span><br><span class="line">one    <span class="number">2000</span>    Ohio  <span class="number">1.5</span>  NaN</span><br><span class="line">two    <span class="number">2001</span>    Ohio  <span class="number">1.7</span>  NaN</span><br><span class="line">three  <span class="number">2002</span>    Ohio  <span class="number">3.6</span>  NaN</span><br><span class="line">four   <span class="number">2001</span>  Nevada  <span class="number">2.4</span>  NaN</span><br><span class="line">five   <span class="number">2002</span>  Nevada  <span class="number">2.9</span>  NaN</span><br><span class="line">six    <span class="number">2003</span>  Nevada  <span class="number">3.2</span>  NaN</span><br></pre></td></tr></table></figure><ul><li>另一种常见的创建DataFrame方式是使用嵌套字典，如果嵌套字典传给DataFrame，pandas就会被解释为外层字典的键作为列，内层字典键则作为行索引： </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">65</span>]: pop = &#123;<span class="string">'Nevada'</span>: &#123;<span class="number">2001</span>: <span class="number">2.4</span>, <span class="number">2002</span>: <span class="number">2.9</span>&#125;,</span><br><span class="line">....:        <span class="string">'Ohio'</span>: &#123;<span class="number">2000</span>: <span class="number">1.5</span>, <span class="number">2001</span>: <span class="number">1.7</span>, <span class="number">2002</span>: <span class="number">3.6</span>&#125;&#125;</span><br><span class="line">In [<span class="number">66</span>]: df3 = pd.DataFrame(pop)</span><br><span class="line">In [<span class="number">67</span>]: df3</span><br><span class="line">Out[<span class="number">67</span>]: </span><br><span class="line">      Nevada  Ohio</span><br><span class="line"><span class="number">2000</span>     NaN   <span class="number">1.5</span></span><br><span class="line"><span class="number">2001</span>     <span class="number">2.4</span>   <span class="number">1.7</span></span><br><span class="line"><span class="number">2002</span>     <span class="number">2.9</span>   <span class="number">3.6</span></span><br></pre></td></tr></table></figure><p><img src="/2021/03/02/数据分析工具/3.png" alt></p><h3 id="DataFrame对象操作"><a href="#DataFrame对象操作" class="headerlink" title="DataFrame对象操作"></a>DataFrame对象操作</h3><ul><li><strong>df.values</strong>：将DataFrame转换为ndarray二维数组，注意后面不加()。 </li><li>通过类似字典标记的方式或属性的方式，可以将DataFrame的列获取为一个Series。 </li><li>列可以通过赋值的方式进行修改。例如，我们可以给那个空的”debt”列赋上一个标量值或一组值。 </li><li>将列表或数组赋值给某个列时，其长度必须跟DataFrame的长度相匹配。如果赋值的是一个Series，就会精确匹配DataFrame的索引，所有的空位都将被填上缺失值。 </li><li>为不存在的列赋值会创建出一个新列。关键字del用于删除列。 </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = &#123;<span class="string">'state'</span>: [<span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Nevada'</span>, <span class="string">'Nevada'</span>, <span class="string">'Nevada'</span>],</span><br><span class="line">        <span class="string">'year'</span>: [<span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2003</span>],</span><br><span class="line">        <span class="string">'pop'</span>: [<span class="number">1.5</span>, <span class="number">1.7</span>, <span class="number">3.6</span>, <span class="number">2.4</span>, <span class="number">2.9</span>, <span class="number">3.2</span>]&#125;</span><br><span class="line">In [<span class="number">48</span>]: df2 = pd.DataFrame(data, columns=[<span class="string">'year'</span>, <span class="string">'state'</span>, <span class="string">'pop'</span>, <span class="string">'debt'</span>],</span><br><span class="line">   ....:                       index=[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>, <span class="string">'five'</span>, <span class="string">'six'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">50</span>]: df2.columns</span><br><span class="line">Out[<span class="number">50</span>]: Index([<span class="string">'year'</span>, <span class="string">'state'</span>, <span class="string">'pop'</span>, <span class="string">'debt'</span>], dtype=<span class="string">'object'</span>)</span><br><span class="line"><span class="comment">#通过类似字典标记的方式或属性的方式，可以将DataFrame的列获取为一个Series。</span></span><br><span class="line">In [<span class="number">51</span>]: df2[<span class="string">'state'</span>]  <span class="comment">#或者df2.state</span></span><br><span class="line">Out[<span class="number">51</span>]: </span><br><span class="line">one        Ohio</span><br><span class="line">two        Ohio</span><br><span class="line">three      Ohio</span><br><span class="line">four     Nevada</span><br><span class="line">five     Nevada</span><br><span class="line">six      Nevada</span><br><span class="line">Name: state, dtype: object</span><br><span class="line"><span class="comment">#列可以通过赋值的方式进行修改。例如，我们可以给那个空的"debt"列赋上一个标量值或一组值</span></span><br><span class="line">In [<span class="number">54</span>]: frame2[<span class="string">'debt'</span>] = <span class="number">16.5</span></span><br><span class="line">In [<span class="number">55</span>]: frame2</span><br><span class="line">Out[<span class="number">55</span>]: </span><br><span class="line">       year   state  pop  debt</span><br><span class="line">one    <span class="number">2000</span>    Ohio  <span class="number">1.5</span>  <span class="number">16.5</span></span><br><span class="line">two    <span class="number">2001</span>    Ohio  <span class="number">1.7</span>  <span class="number">16.5</span></span><br><span class="line">three  <span class="number">2002</span>    Ohio  <span class="number">3.6</span>  <span class="number">16.5</span></span><br><span class="line">four   <span class="number">2001</span>  Nevada  <span class="number">2.4</span>  <span class="number">16.5</span></span><br><span class="line">five   <span class="number">2002</span>  Nevada  <span class="number">2.9</span>  <span class="number">16.5</span></span><br><span class="line">six    <span class="number">2003</span>  Nevada  <span class="number">3.2</span>  <span class="number">16.5</span></span><br><span class="line"><span class="comment">#将列表或数组赋值给某个列时，其长度必须跟DataFrame的长度相匹配。如果赋值的是一个Series，就会精确匹配DataFrame的索引，所有的空位都将被填上缺失值</span></span><br><span class="line">In [<span class="number">58</span>]: val = pd.Series([<span class="number">-1.2</span>, <span class="number">-1.5</span>, <span class="number">-1.7</span>], index=[<span class="string">'two'</span>, <span class="string">'four'</span>, <span class="string">'five'</span>])</span><br><span class="line">In [<span class="number">59</span>]: df2[<span class="string">'debt'</span>] = val</span><br><span class="line">In [<span class="number">60</span>]: df2</span><br><span class="line">Out[<span class="number">60</span>]: </span><br><span class="line">       year   state  pop  debt</span><br><span class="line">one    <span class="number">2000</span>    Ohio  <span class="number">1.5</span>   <span class="number">16.5</span></span><br><span class="line">two    <span class="number">2001</span>    Ohio  <span class="number">1.7</span>  <span class="number">-1.2</span></span><br><span class="line">three  <span class="number">2002</span>    Ohio  <span class="number">3.6</span>   <span class="number">16.5</span></span><br><span class="line">four   <span class="number">2001</span>  Nevada  <span class="number">2.4</span>  <span class="number">-1.5</span></span><br><span class="line">five   <span class="number">2002</span>  Nevada  <span class="number">2.9</span>  <span class="number">-1.7</span></span><br><span class="line">six    <span class="number">2003</span>  Nevada  <span class="number">3.2</span>   <span class="number">16.5</span></span><br><span class="line"><span class="comment">#为不存在的列赋值，会创建出一个新列</span></span><br><span class="line">In [<span class="number">61</span>]: df2[<span class="string">'eastern'</span>] = df2.state == <span class="string">'Ohio'</span></span><br><span class="line">In [<span class="number">62</span>]: df2</span><br><span class="line">Out[<span class="number">62</span>]: </span><br><span class="line">       year   state  pop  debt  eastern</span><br><span class="line">one    <span class="number">2000</span>    Ohio  <span class="number">1.5</span>   NaN     <span class="literal">True</span></span><br><span class="line">two    <span class="number">2001</span>    Ohio  <span class="number">1.7</span>  <span class="number">-1.2</span>     <span class="literal">True</span></span><br><span class="line">three  <span class="number">2002</span>    Ohio  <span class="number">3.6</span>   NaN     <span class="literal">True</span></span><br><span class="line">four   <span class="number">2001</span>  Nevada  <span class="number">2.4</span>  <span class="number">-1.5</span>    <span class="literal">False</span></span><br><span class="line">five   <span class="number">2002</span>  Nevada  <span class="number">2.9</span>  <span class="number">-1.7</span>    <span class="literal">False</span></span><br><span class="line">six    <span class="number">2003</span>  Nevada  <span class="number">3.2</span>   NaN    <span class="literal">False</span></span><br><span class="line"><span class="comment">#关键字del用于删除列</span></span><br><span class="line">In [<span class="number">63</span>]: <span class="keyword">del</span> df2[<span class="string">'eastern'</span>]</span><br><span class="line">In [<span class="number">64</span>]: df2.columns</span><br><span class="line">Out[<span class="number">64</span>]: Index([<span class="string">'year'</span>, <span class="string">'state'</span>, <span class="string">'pop'</span>, <span class="string">'debt'</span>], dtype=<span class="string">'object'</span>)</span><br></pre></td></tr></table></figure><h3 id="pandas的基本功能"><a href="#pandas的基本功能" class="headerlink" title="pandas的基本功能"></a>pandas的基本功能</h3><p><strong>数据索引</strong>：Series和DataFrame的索引是Index类型，Index对象是不可修改，可通过索引值或索引标签获取目标数据，也可通过索引使序列或数据框的计算、操作实现自动化对齐。索引类型index的常用方法：</p><ul><li>.append(idx)：连接另一个Index对象，产生新的Index对象 </li><li>.diff(idx)：计算差集，产生新的Index对象 </li><li>.intersection(idx)：计算交集 </li><li>.union(idx)：计算并集 </li><li>.delete(loc)：删除loc位置处的元素 </li><li>.insert(loc,e)：在loc位置增加一个元素 </li></ul><p><img src="/2021/03/02/数据分析工具/3.jpg" alt></p><p><strong>重新索引</strong>：能够改变、重排Series和DataFrame索引，会创建一个新对象，如果某个索引值当前不存在，就引入缺失值。<br> <strong>df.reindex(index, columns ,fill_value, method, limit, copy )</strong>：index/columns为新的行列自定义索引；fill_value为用于填充缺失位置的值；method为填充方法，ffill当前值向前填充，bfill向后填充；limit为最大填充量；copy 默认True，生成新的对象，False时，新旧相等不复制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">98</span>]: frame = pd.DataFrame(np.arange(<span class="number">9</span>).reshape((<span class="number">3</span>, <span class="number">3</span>)),</span><br><span class="line">   ....:                      index=[<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>],columns=[<span class="string">'Ohio'</span>, <span class="string">'Texas'</span>, <span class="string">'California'</span>])</span><br><span class="line">In [<span class="number">99</span>]: frame</span><br><span class="line">Out[<span class="number">99</span>]: </span><br><span class="line">   Ohio  Texas  California</span><br><span class="line">a     <span class="number">0</span>      <span class="number">1</span>           <span class="number">2</span></span><br><span class="line">c     <span class="number">3</span>      <span class="number">4</span>           <span class="number">5</span></span><br><span class="line">d     <span class="number">6</span>      <span class="number">7</span>           <span class="number">8</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">100</span>]: frame2 = frame.reindex([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])</span><br><span class="line">In [<span class="number">101</span>]: frame2</span><br><span class="line">Out[<span class="number">101</span>]: </span><br><span class="line">   Ohio  Texas  California</span><br><span class="line">a   <span class="number">0.0</span>    <span class="number">1.0</span>         <span class="number">2.0</span></span><br><span class="line">b   NaN    NaN         NaN</span><br><span class="line">c   <span class="number">3.0</span>    <span class="number">4.0</span>         <span class="number">5.0</span></span><br><span class="line">d   <span class="number">6.0</span>    <span class="number">7.0</span>         <span class="number">8.0</span></span><br></pre></td></tr></table></figure><p><strong>删除指定索引</strong>：默认返回的是一个新对象。<br> <strong>.drop()</strong>：能够删除Series和DataFrame指定行或列索引。<br> 删除一行或者一列时，用单引号指定索引，删除多行时用列表指定索引。<br> 如果删除的是列索引，需要增加axis=1或axis=’columns’作为参数。<br> 增加inplace=True作为参数，可以就地修改对象，不会返回新的对象。</p><p><img src="/2021/03/02/数据分析工具/4.PNG" alt></p><p><strong>索引、选取和过滤</strong><br> <strong>df.loc[行标签，列标签]</strong>：通过标签查询指定的数据，第一个值为行标签，第二值为列标签。当第二个参数为空时，查询的是单个或多个行的所有列。如果查询多个行、列的话，则两个参数用列表表示。<br> <strong>df.iloc[行位置，列位置]</strong>：通过默认生成的数字索引查询指定的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">128</span>]: data = pd.DataFrame(np.arange(<span class="number">16</span>).reshape((<span class="number">4</span>, <span class="number">4</span>)),</span><br><span class="line">   .....:                     index=[<span class="string">'Ohio'</span>, <span class="string">'Colorado'</span>, <span class="string">'Utah'</span>, <span class="string">'New York'</span>],</span><br><span class="line">   .....:                     columns=[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>])</span><br><span class="line">​</span><br><span class="line">In [<span class="number">129</span>]: data</span><br><span class="line">Out[<span class="number">129</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">Colorado    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br><span class="line"><span class="comment">#df.loc选取第二行、第二三列</span></span><br><span class="line">In [<span class="number">137</span>]: data.loc[<span class="string">'Colorado'</span>, [<span class="string">'two'</span>, <span class="string">'three'</span>]]   </span><br><span class="line">Out[<span class="number">137</span>]: </span><br><span class="line">two      <span class="number">5</span></span><br><span class="line">three    <span class="number">6</span></span><br><span class="line">Name: Colorado, dtype: int64</span><br><span class="line"><span class="comment">#df.iloc选取第二行、第二三列</span></span><br><span class="line">In [<span class="number">138</span>]: data.iloc[<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line">Out[<span class="number">138</span>]: </span><br><span class="line">two      <span class="number">5</span></span><br><span class="line">three    <span class="number">6</span></span><br><span class="line">Name: Colorado, dtype: int64</span><br></pre></td></tr></table></figure><p> 在pandas中，有多个方法可以选取和重新组合数据。对于DataFrame，表5-4进行了总结 </p><p><img src="/2021/03/02/数据分析工具/5.png" alt></p><p><strong>算术运算</strong>：算术运算根据行列索引，对齐后运算，运算默认产生浮点数，对齐时缺项填充NaN (空值)。除了用+-*/外，还可以用Series和DataFrame的算术方法，这些方法传入fill_value参数时，可以填充缺省值。比如df1.add(df2, fill_value = 1)：</p><p><img src="/2021/03/02/数据分析工具/6.png" alt></p><p>比较运算只能比较相同索引的元素，不进行补齐。采用&gt;&lt; &gt;= &lt;= == !=等符号进行的比较运算，产生布尔值。<br> <strong>排序</strong> ：在排序时，任何缺失值默认都会被放到末尾<br> <strong>.sort_index(axis=0, ascending=True)</strong>：根据指定轴索引的值进行排序。默认轴axis=0, ascending=True，即默认根据0轴的索引值做升序排序。轴axis=1为根据1轴的索引值排序， ascending=False为降序。<br> 在指定轴上根据数值进行排序，默认升序。<br> <strong>Series.sort_values(axis=0, ascending=True)</strong>：只能根据0轴的值排序。<br> <strong>DataFrame.sort_values(by, axis=0, ascending=True)</strong>，参数by为axis轴上的某个索引或索引列表。</p><h3 id="pandas数据分析"><a href="#pandas数据分析" class="headerlink" title="pandas数据分析"></a>pandas数据分析</h3><h4 id="统计分析、相关分析"><a href="#统计分析、相关分析" class="headerlink" title="统计分析、相关分析"></a>统计分析、相关分析</h4><p><strong>适用于Series和DataFrame的基本统计分析函数</strong>：传入axis=’columns’或axis=1将会按行进行运算。<br> <strong>.describe()</strong>：针对各列的多个统计汇总，用统计学指标快速描述数据的概要。<br> <strong>.sum()</strong>：计算各列数据的和<br> <strong>.count()</strong>：非NaN值的数量<br> <strong>.mean( )/.median()</strong>：计算数据的算术平均值、算术中位数<br> <strong>.var()/.std()</strong>：计算数据的方差、标准差<br> <strong>.corr()/.cov()</strong>：计算相关系数矩阵、协方差矩阵，是通过参数对计算出来的。Series的corr方法用于计算两个Series中重叠的、非NA的、按索引对齐的值的相关系数。DataFrame的corr和cov方法将以DataFrame的形式分别返回完整的相关系数或协方差矩阵。<br> <strong>.corrwith()</strong>：利用DataFrame的corrwith方法，可以计算其列或行跟另一个Series或DataFrame之间的相关系数。传入一个Series将会返回一个相关系数值Series（针对各列进行计算），传入一个DataFrame则会计算按列名配对的相关系数。<br> <strong>.min()/.max()</strong>：计算数据的最小值、最大值<br> <strong>.diff()</strong>：计算一阶差分，对时间序列很有效<br> <strong>.mode()</strong>：计算众数，返回频数最高的那（几）个<br> <strong>.mean()</strong>：计算均值<br> <strong>.quantile()</strong>：计算分位数（0到1）<br> <strong>.isin()</strong>：用于判断矢量化集合的成员资格，可用于过滤Series中或DataFrame列中数据的子集<br> <strong>适用于Series的基本统计分析函数，DataFrame[列名]返回的是一个Series类型。</strong><br> <strong>.unique()</strong>：返回一个Series中的唯一值组成的数组。<br> <strong>.value_counts()</strong>：计算一个Series中各值出现的频率。<br> <strong>.argmin()/.argmax()</strong>：计算数据最大值、最小值所在位置的索引位置（自动索引）<br> <strong>.idxmin()/.idxmax()</strong>：计算数据最大值、最小值所在位置的索引（自定义索引）</p><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><ul><li><p><strong>DataFrame.groupby()</strong>：分组函数，使用方法参考<a href="https://blog.csdn.net/cymy001/article/details/78300900" target="_blank" rel="noopener">https://blog.csdn.net/cymy001/article/details/78300900</a> </p></li><li><p><strong>pandas.cut()</strong>：根据数据分析对象的特征，按照一定的数值指标，把数据分析对象划分为不同的区间部分来进行研究，以揭示其内在的联系和规律性。类似给成绩设定优良中差，比如：0-59分为差，60-70分为中，71-80分为优秀等等。使用方法参考<br> <a href="https://blog.csdn.net/weixin_39541558/article/details/80578529" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39541558/article/details/80578529</a><br> <a href="https://blog.csdn.net/missyougoon/article/details/83986511" target="_blank" rel="noopener">https://blog.csdn.net/missyougoon/article/details/83986511</a></p></li></ul><h4 id="pandas读写文本格式的数据"><a href="#pandas读写文本格式的数据" class="headerlink" title="pandas读写文本格式的数据"></a>pandas读写文本格式的数据</h4><p> pandas提供了一些用于将表格型数据读取为DataFrame对象的函数。下表对它们进行了总结，其中read_csv()、read_table()、to_csv()是用得最多的。 </p><p><img src="/2021/03/02/数据分析工具/7.png" alt></p><p>工作中实际碰到的数据可能十分混乱，一些数据加载函数（尤其是read_csv）的参数非常多（read_csv有超过50个参数）。具体使用参考<a href="https://seancheney.gitbook.io/python-for-data-analysis-2nd/di-06-zhang-shu-ju-jia-zai-cun-chu-yu-wen-jian-ge-shi" target="_blank" rel="noopener">https://seancheney.gitbook.io/python-for-data-analysis-2nd/di-06-zhang-shu-ju-jia-zai-cun-chu-yu-wen-jian-ge-shi</a></p><h4 id="处理缺失数据"><a href="#处理缺失数据" class="headerlink" title="处理缺失数据"></a>处理缺失数据</h4><p> 在许多数据分析工作中，缺失数据是经常发生的。对于数值数据，pandas使用浮点值NaN（np.nan）表示缺失数据，也可将缺失值表示为NA（Python内置的None值）。 </p><ul><li><strong>.info()</strong>：查看数据的信息，包括每个字段的名称、非空数量、字段的数据类型。 </li><li><strong>.isnull()</strong>：返回一个同样长度的值为布尔型的对象（Series DataFrame），表示哪些值是缺失的，<strong>.notnull()</strong>为其否定形式。 </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">In [<span class="number">10</span>]: string_data = pd.Series([<span class="string">'aardvark'</span>, <span class="string">'artichoke'</span>, np.nan, <span class="literal">None</span>])</span><br><span class="line">In [<span class="number">11</span>]: string_data</span><br><span class="line">Out[<span class="number">11</span>]:</span><br><span class="line"><span class="number">0</span>     aardvark</span><br><span class="line"><span class="number">1</span>    artichoke</span><br><span class="line"><span class="number">2</span>          NaN</span><br><span class="line"><span class="number">3</span>         <span class="literal">None</span></span><br><span class="line">dtype: object</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: string_data.isnull()</span><br><span class="line">Out[<span class="number">14</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">1</span>    <span class="literal">False</span></span><br><span class="line"><span class="number">2</span>     <span class="literal">True</span></span><br><span class="line"><span class="number">3</span>     <span class="literal">True</span></span><br><span class="line">dtype: bool</span><br></pre></td></tr></table></figure><ul><li><strong>.dropna()</strong>：删除缺失数据。对于Series对象，dropna返回一个仅含非空数据和索引值的Series。对于DataFrame对象，dropna默认删除<strong>含有</strong>缺失值的行；如果想删除<strong>含有</strong>缺失值的列，需传入axis = 1作为参数；如果想删除<strong>全部</strong>为缺失值的行或者列，需传入how=’all’作为参数；如果想留下一部分缺失数据，需传入thresh = n作为参数，表示每行至少n个非NA值。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">In [<span class="number">19</span>]: data = pd.DataFrame([[<span class="number">1.</span>, <span class="number">6.5</span>, <span class="number">3.</span>], [<span class="number">1.</span>, NA, NA], [NA, NA, NA], [NA, <span class="number">6.5</span>, <span class="number">3.</span>]])</span><br><span class="line">In [<span class="number">20</span>]: data.dropna()</span><br><span class="line">Out[<span class="number">22</span>]: </span><br><span class="line">     <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  <span class="number">6.5</span>  <span class="number">3.0</span></span><br><span class="line"><span class="comment">#传入how='all'将只丢弃全为NA的那些行：</span></span><br><span class="line">In [<span class="number">23</span>]: data.dropna(how=<span class="string">'all'</span>)</span><br><span class="line">Out[<span class="number">23</span>]: </span><br><span class="line">     <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  <span class="number">6.5</span>  <span class="number">3.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.0</span>  NaN  NaN</span><br><span class="line"><span class="number">3</span>  NaN  <span class="number">6.5</span>  <span class="number">3.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: data[<span class="number">4</span>] = NA</span><br><span class="line">In [<span class="number">25</span>]: data</span><br><span class="line">Out[<span class="number">25</span>]: </span><br><span class="line">     <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span>   <span class="number">4</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  <span class="number">6.5</span>  <span class="number">3.0</span> NaN</span><br><span class="line"><span class="number">1</span>  <span class="number">1.0</span>  NaN  NaN NaN</span><br><span class="line"><span class="number">2</span>  NaN  NaN  NaN NaN</span><br><span class="line"><span class="number">3</span>  NaN  <span class="number">6.5</span>  <span class="number">3.0</span> NaN</span><br><span class="line"><span class="comment">#用这种方式丢弃列，只需传入axis=1即可：</span></span><br><span class="line">In [<span class="number">26</span>]: data.dropna(axis=<span class="number">1</span>, how=<span class="string">'all'</span>)</span><br><span class="line">Out[<span class="number">26</span>]: </span><br><span class="line">     <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  <span class="number">6.5</span>  <span class="number">3.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.0</span>  NaN  NaN</span><br><span class="line"><span class="number">2</span>  NaN  NaN  NaN</span><br><span class="line"><span class="number">3</span>  NaN  <span class="number">6.5</span>  <span class="number">3.0</span></span><br><span class="line"><span class="comment">#假设你只想留下一部分观测数据，可以用thresh参数实现此目的：</span></span><br><span class="line">In [<span class="number">27</span>]: df = pd.DataFrame(np.random.randn(<span class="number">7</span>, <span class="number">3</span>))</span><br><span class="line">In [<span class="number">28</span>]: df.iloc[:<span class="number">4</span>, <span class="number">1</span>] = NA</span><br><span class="line">In [<span class="number">29</span>]: df.iloc[:<span class="number">2</span>, <span class="number">2</span>] = NA</span><br><span class="line">In [<span class="number">30</span>]: df</span><br><span class="line">Out[<span class="number">30</span>]: </span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line"><span class="number">0</span> <span class="number">-0.204708</span>       NaN       NaN</span><br><span class="line"><span class="number">1</span> <span class="number">-0.555730</span>       NaN       NaN</span><br><span class="line"><span class="number">2</span>  <span class="number">0.092908</span>       NaN  <span class="number">0.769023</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1.246435</span>       NaN <span class="number">-1.296221</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0.274992</span>  <span class="number">0.228913</span>  <span class="number">1.352917</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.886429</span> <span class="number">-2.001637</span> <span class="number">-0.371843</span></span><br><span class="line"><span class="number">6</span>  <span class="number">1.669025</span> <span class="number">-0.438570</span> <span class="number">-0.539741</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: df.dropna(thresh=<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">32</span>]: </span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.092908</span>       NaN  <span class="number">0.769023</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1.246435</span>       NaN <span class="number">-1.296221</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0.274992</span>  <span class="number">0.228913</span>  <span class="number">1.352917</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.886429</span> <span class="number">-2.001637</span> <span class="number">-0.371843</span></span><br><span class="line"><span class="number">6</span>  <span class="number">1.669025</span> <span class="number">-0.438570</span> <span class="number">-0.539741</span></span><br></pre></td></tr></table></figure><ul><li><strong>.fillna(value,method,limit,inplace)</strong>：填充缺失值。value为用于填充的值（比如0、’a’等）或者是字典（比如{‘列’:1,’列’:8,……}为指定列的缺失数据填充值）；method默认值为ffill，向前填充，bfill为向后填充；limit为向前或者向后填充的最大填充量。inplace默认会返回新对象，修改为inplace=True可以对现有对象进行就地修改。</li></ul><h4 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h4><p><strong>替换值</strong><br> <strong>.replace(old, new)</strong>：用新的数据替换老的数据，如果希望一次性替换多个值，old和new可以是列表。默认会返回一个新的对象，传入inplace=True可以对现有对象进行就地修改。</p><p><strong>删除重复数据</strong></p><ul><li><strong>.duplicated()</strong>：判断各行是否是重复行（前面出现过的行），返回一个布尔型Series。 </li><li><strong>.drop_duplicates()</strong>：删除重复行，返回删除后的DataFrame对象。默认保留的是第一个出现的行，传入keep=’last’作为参数后，则保留最后一个出现的行。 </li><li><p>两者都默认会对全部列做判断，在传入列索引组成的列表[ ‘列1’ , ‘列2’ , ……]作为参数后，可以只对这些列进行重复项判断。 </p><p><strong>利用函数或字典进行数据转换</strong> </p></li><li><p>Series.map()：接受一个函数或字典作为参数。使用map方法是一种实现元素级转换以及其他数据清理工作的便捷方式。 </p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">In [<span class="number">52</span>]: data = pd.DataFrame(&#123;<span class="string">'food'</span>: [<span class="string">'bacon'</span>, <span class="string">'pulled pork'</span>, <span class="string">'bacon'</span>,<span class="string">'pastrami'</span>, <span class="string">'corned beef'</span>, <span class="string">'bacon'</span>,<span class="string">'pastrami'</span>, <span class="string">'honey ham'</span>, <span class="string">'nova lox'</span>],</span><br><span class="line">   ....                       <span class="string">'ounces'</span>: [<span class="number">4</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">7.5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>]&#125;)</span><br><span class="line">meat_to_animal = &#123;</span><br><span class="line">  <span class="string">'bacon'</span>: <span class="string">'pig'</span>,  <span class="string">'pulled pork'</span>: <span class="string">'pig'</span>,  <span class="string">'pastrami'</span>: <span class="string">'cow'</span>,  <span class="string">'corned beef'</span>: <span class="string">'cow'</span>,</span><br><span class="line">  <span class="string">'honey ham'</span>: <span class="string">'pig'</span>,  <span class="string">'nova lox'</span>: <span class="string">'salmon'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#增加一列animal</span></span><br><span class="line">In [<span class="number">57</span>]: data[<span class="string">'animal'</span>] = data[<span class="string">'food'</span>].map(meat_to_animal)</span><br><span class="line">In [<span class="number">58</span>]: data</span><br><span class="line">Out[<span class="number">58</span>]: </span><br><span class="line">          food  ounces  animal</span><br><span class="line"><span class="number">0</span>        bacon     <span class="number">4.0</span>     pig</span><br><span class="line"><span class="number">1</span>  pulled pork     <span class="number">3.0</span>     pig</span><br><span class="line"><span class="number">2</span>        bacon    <span class="number">12.0</span>     pig</span><br><span class="line"><span class="number">3</span>     Pastrami     <span class="number">6.0</span>     cow</span><br><span class="line"><span class="number">4</span>  corned beef     <span class="number">7.5</span>     cow</span><br><span class="line"><span class="number">5</span>        Bacon     <span class="number">8.0</span>     pig</span><br><span class="line"><span class="number">6</span>     pastrami     <span class="number">3.0</span>     cow</span><br><span class="line"><span class="number">7</span>    honey ham     <span class="number">5.0</span>     pig</span><br><span class="line"><span class="number">8</span>     nova lox     <span class="number">6.0</span>  salmon</span><br></pre></td></tr></table></figure><h3 id="DataFrame常见函数"><a href="#DataFrame常见函数" class="headerlink" title="DataFrame常见函数"></a>DataFrame常见函数</h3><p>df.head()：查询数据的前五行<br>df.tail()：查询数据的末尾5行<br>pandas.cut()<br>pandas.qcut() 基于分位数的离散化函数。基于秩或基于样本分位数将变量离散化为等大小桶。<br>pandas.date_range() 返回一个时间索引<br>df.apply() 沿相应轴应用函数<br>Series.value_counts() 返回不同数据的计数值<br>df.aggregate()<br>df.reset_index() 重新设置index，参数drop = True时会丢弃原来的索引，设置新的从0开始的索引。常与groupby()一起用<br>numpy.zeros()</p>]]></content>
      
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法设计与分析</title>
      <link href="/2020/10/13/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"/>
      <url>/2020/10/13/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="算法设计与分析"><a href="#算法设计与分析" class="headerlink" title="算法设计与分析"></a>算法设计与分析</h1><h2 id="1-递归与分治"><a href="#1-递归与分治" class="headerlink" title="1.递归与分治"></a>1.递归与分治</h2><ul><li><p>分治法</p><p>1) 分治法产生的子问题是原问题的较小规模；</p><p>2) 反复应用分治手段，可以使子问题规模不断缩小；</p><p>3) 最终使子问题缩小到很容易直接求出其解；</p><p>4) 将规模较小的问题的答案逐级向上合并，可得大问题答案。</p></li><li><p>分治法解决问题通常使用递归算法；</p></li><li><p>直接或间接调用自身的算法称为递归算法。</p></li></ul><p>算法中要对边界条件处理，而对非边界条件的处理要分为3步：</p><ul><li>分：问题划分的子问题；</li><li>治：对各个子问题递归调用去解决；</li><li>合：合并子问题的解为问题的解。</li></ul><p><strong>边界条件与递归方程</strong>是递归函数的两个要素，递归函数只有具备了这两个要素，才能在有限次的计算后得到结果。</p><a id="more"></a><h3 id="N的阶乘"><a href="#N的阶乘" class="headerlink" title="N的阶乘"></a>N的阶乘</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fac</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n*fac(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n<span class="number">-1</span>)+fibonacci(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><p><img src="/2020/10/13/算法设计与分析/QQ截图20201020105312.jpg" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Type int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(Type &amp;a,Type &amp;b)</span></span>&#123;</span><br><span class="line"> Type temp=a;</span><br><span class="line"> a=b;</span><br><span class="line"> b=temp;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Perm</span><span class="params">(Type <span class="built_in">list</span>[],<span class="keyword">int</span> k,<span class="keyword">int</span> m)</span></span>&#123;<span class="comment">//产生list[k:m]元素的全排列 k,m 为数组下标</span></span><br><span class="line"> <span class="keyword">if</span>(k==m)&#123;<span class="comment">//只剩下一个元素</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%d "</span>,<span class="built_in">list</span>[i]);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span>&#123;<span class="comment">//还有多个元素待排列，递归产生排列</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;=m;i++)&#123;</span><br><span class="line"> Swap(<span class="built_in">list</span>[k],<span class="built_in">list</span>[i]);</span><br><span class="line"> Perm(<span class="built_in">list</span>,k+<span class="number">1</span>,m);</span><br><span class="line"> Swap(<span class="built_in">list</span>[k],<span class="built_in">list</span>[i]);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> Type <span class="built_in">list</span>[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"> Perm(<span class="built_in">list</span>,<span class="number">0</span>,<span class="number">2</span>);<span class="comment">//Perm(list,0,n-1)则产生list[0:n-1]的全排列</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="hanoi-塔"><a href="#hanoi-塔" class="headerlink" title="hanoi 塔"></a>hanoi 塔</h3><p><img src="/2020/10/13/算法设计与分析/QQ截图20201020105606.jpg" alt></p><p><img src="/2020/10/13/算法设计与分析/QQ截图20201020105701.jpg" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">hanoi(n<span class="number">-1</span>,a,c,b);<span class="comment">//借助b柱将a移动到c</span></span><br><span class="line">move(a,b);</span><br><span class="line">hanoi(n<span class="number">-1</span>,c,b,a);<span class="comment">//借助a柱将c到b</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分搜索术"><a href="#二分搜索术" class="headerlink" title="二分搜索术"></a>二分搜索术</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(ElementType A[],ElementType K,<span class="keyword">int</span> N)</span></span>&#123;<span class="comment">//折半查找 </span></span><br><span class="line"><span class="keyword">int</span> left,right,mid,Nofound=<span class="number">-1</span>;</span><br><span class="line">left=<span class="number">0</span>;</span><br><span class="line">right=N<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">mid=(left+right)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(K&lt;A[mid])right=mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (K&gt;A[mid])left=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Nofound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="棋盘覆盖"><a href="#棋盘覆盖" class="headerlink" title="棋盘覆盖"></a>棋盘覆盖</h3><ul><li>易知，在任何一个$2^k<em>2^k$的棋盘覆盖中，用到的 <em>*L</em></em> 型骨牌个数恰为$(4^k-1)/3$</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//坐标：左上行号，左上列号，特殊方格所在行号，特殊方格所在列号，棋盘大小</span></span><br><span class="line"><span class="keyword">int</span> tile=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Board[size][size]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChessBoard</span><span class="params">(<span class="keyword">int</span> tr,<span class="keyword">int</span> tc,<span class="keyword">int</span> dr,<span class="keyword">int</span> dc,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> t=tile++;<span class="comment">//L型骨牌号</span></span><br><span class="line">    <span class="keyword">int</span> s=size/<span class="number">2</span>;<span class="comment">//分割棋盘</span></span><br><span class="line">    <span class="comment">//覆盖左上角子棋盘</span></span><br><span class="line">    <span class="keyword">if</span>(dr &lt; tr+s &amp;&amp; dc &lt; tc+s) </span><br><span class="line">        ChessBoard(tr,tc,dr,dc,s);<span class="comment">//特殊方格在此棋盘中</span></span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//此棋盘中无特殊方格</span></span><br><span class="line">        Board[tr+s<span class="number">-1</span>][tc+s<span class="number">-1</span>]= t ;<span class="comment">//用 t 号 L 型骨牌覆盖右下角</span></span><br><span class="line">        ChessBoard(tr,tc,tr+s<span class="number">-1</span>,tc+s<span class="number">-1</span>,s);<span class="comment">//覆盖其余方格</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//覆盖右上角子棋盘</span></span><br><span class="line">    <span class="keyword">if</span>(dr&lt;tr+s &amp;&amp; dc &gt;= tc+s)<span class="comment">//特殊方格在此棋盘中</span></span><br><span class="line">        ChessBoard(tr,tc+s,dr,dc,s);</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//此棋盘无特殊方格</span></span><br><span class="line">        Board[tr+s<span class="number">-1</span>][tc+s] = t;<span class="comment">//用t号L型骨牌覆盖左下角</span></span><br><span class="line">        ChessBoard(tr,tc+s,tr+s<span class="number">-1</span>,tc+s,s);<span class="comment">//覆盖其余方格</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//覆盖左下角子棋盘</span></span><br><span class="line">    <span class="keyword">if</span>(dr &gt;= tr+s &amp;&amp; dc &lt; tc+s)<span class="comment">//特殊方格在此棋盘中</span></span><br><span class="line">        ChessBoard(tr+s,tc,dr,dc,s);</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//此棋盘中无特殊方格</span></span><br><span class="line">        Board[tr+s][tr+s<span class="number">-1</span>] = t;<span class="comment">//用 t 号 L 型骨牌覆盖右上角</span></span><br><span class="line">        ChessBoard(tr+s,tc,tr+s,tr+s<span class="number">-1</span>,s);<span class="comment">//覆盖其余方格</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//覆盖右下角子棋盘</span></span><br><span class="line">    <span class="keyword">if</span>(dr &gt;= tr+s &amp;&amp; dc &gt;= tc+s)<span class="comment">//特殊方格在此棋盘中</span></span><br><span class="line">        ChessBoard(tr+s,tc+s,dr,dc,s);</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//此棋盘中无特殊方格</span></span><br><span class="line">        Board[tr+s][tc+s] = t;<span class="comment">//用t号L型骨牌覆盖左上角</span></span><br><span class="line">        ChessBoard(tr+s,tc+s,tr+s,tc+s,s);<span class="comment">//覆盖其余方格</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并递归算法 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(ElementType A[],ElementType TmpA[],<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> RightEnd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leftEnd=R<span class="number">-1</span>;<span class="comment">//左边终点位置，假设左右两列挨着 在一个数组里面</span></span><br><span class="line">    <span class="keyword">int</span> Tmp=L;<span class="comment">//存放结果得数组得初始位置，从第二个数组得哪个地方开始</span></span><br><span class="line">    <span class="keyword">int</span> NumElements = RightEnd - L + <span class="number">1</span>;<span class="comment">//归并结束后总元素数</span></span><br><span class="line">    <span class="keyword">while</span>(L&lt;=leftEnd &amp;&amp; R&lt;=RightEnd)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[L]&lt;=A[R])TmpA[Tmp++]=A[L++];</span><br><span class="line">        <span class="keyword">else</span> TmpA[Tmp++]=A[R++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(L&lt;=leftEnd)</span><br><span class="line">        TmpA[Tmp++]=A[L++];<span class="comment">//直接复制左边剩下的</span></span><br><span class="line">    <span class="keyword">while</span>(R&lt;=RightEnd)</span><br><span class="line">        TmpA[Tmp++]=A[R++];<span class="comment">//直接复制右边剩下得</span></span><br><span class="line">    <span class="comment">//两个只会执行一个</span></span><br><span class="line">    <span class="comment">//最后将TmpA数组倒回A数组，RightEnd 始终没变(传进来后，传进来前始终在变)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;NumElements;i++,RightEnd--)</span><br><span class="line">        A[RightEnd]=TmpA[RightEnd];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分而治之 时间复杂度T(N)=T(N/2)+T(N/2)+O(N)=&gt;T(N)=O(NlogN) 稳定</span></span><br><span class="line"><span class="comment">//RightEnd 始终在变 递归调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MSort</span><span class="params">(ElementType A[],ElementType TmpA[],<span class="keyword">int</span> L,<span class="keyword">int</span> RightEnd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Center;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;RightEnd)&#123;</span><br><span class="line">        Center = (L+RightEnd)/<span class="number">2</span>;</span><br><span class="line">        MSort(A,TmpA,L,Center);</span><br><span class="line">        MSort(A,TmpA,Center+<span class="number">1</span>,RightEnd);</span><br><span class="line">        Merge(A,TmpA,L,Center+<span class="number">1</span>,RightEnd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统一接口 重要！！！！</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_sort</span><span class="params">(ElementType A[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    ElementType *TmpA;</span><br><span class="line">    TmpA=(ElementType*)<span class="built_in">malloc</span>(N * <span class="keyword">sizeof</span>(ElementType));</span><br><span class="line">    <span class="keyword">if</span> (TmpA!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        MSort(A,TmpA,<span class="number">0</span>,N<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">free</span>(TmpA);<span class="comment">//释放临时数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"错误"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//考试</span></span><br><span class="line"><span class="comment">//void MergeSort(Type a[],int left,int right)&#123;</span></span><br><span class="line"><span class="comment">//    if(left&lt;right)&#123;//至少有2个元素</span></span><br><span class="line"><span class="comment">//        int i=(left+right)/2;//取中点</span></span><br><span class="line"><span class="comment">//        MergeSort(a,left,i);</span></span><br><span class="line"><span class="comment">//        MergeSort(a,i+1,right);</span></span><br><span class="line"><span class="comment">//        Merge(a,b,left,i,right);//合并到数组b</span></span><br><span class="line"><span class="comment">//        Copy(a,b,left,right);//复制回数组a</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(Type a[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//Type *b=(Type*)malloc(n*sizeof(Type));</span></span><br><span class="line">    Type *b = <span class="keyword">new</span> Type [n];</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(s&lt;n)&#123;</span><br><span class="line">        MergePass(a,b,s,n);<span class="comment">//合并到数组b</span></span><br><span class="line">        s +=s;</span><br><span class="line">        MergePass(b,a,s,n);<span class="comment">//合并到数组a</span></span><br><span class="line">        s+=s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergepass</span><span class="params">(Type x[],Type y[],<span class="keyword">int</span> s,<span class="keyword">int</span> n)</span></span>&#123;<span class="comment">//合并大小为s的相邻子数组</span></span><br><span class="line">    <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=n<span class="number">-2</span>*s)&#123;</span><br><span class="line">        Merge(x,y,i,i+s<span class="number">-1</span>,i+<span class="number">2</span>*s<span class="number">-1</span>);<span class="comment">//合并大小为s的相邻2段子数组</span></span><br><span class="line">        i=i+<span class="number">2</span>*s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i+s&lt;n)<span class="comment">//剩下的元素个数少于2*s</span></span><br><span class="line">        Merge(x,y,i,i+s<span class="number">-1</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n<span class="number">-1</span>;j++);</span><br><span class="line">    y[j]=x[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(Type c[],Type d[],<span class="keyword">int</span> l,<span class="keyword">int</span> m,<span class="keyword">int</span> r)</span></span>&#123;<span class="comment">//合并c[l:m]和c[m+1:r]到d[l:r]</span></span><br><span class="line">    <span class="keyword">int</span> i=l,j=m+<span class="number">1</span>,k=l;</span><br><span class="line">    <span class="keyword">while</span>((i&lt;=m) &amp;&amp; (j&lt;=r))&#123;</span><br><span class="line">        <span class="keyword">if</span>(c[i]&lt;=c[j])</span><br><span class="line">            d[k++]=c[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            d[k++]=c[j++];</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;m)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> q=j;q&lt;=r;q++)</span><br><span class="line">                d[k++]=c[q];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> q=i;q&lt;=m;q++)</span><br><span class="line">                d[k++]=c[q];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//归并非递归算法 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge1</span><span class="params">(ElementType A[],ElementType TmpA[],<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> RightEnd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leftEnd=R<span class="number">-1</span>;<span class="comment">//左边终点位置，假设左右两列挨着 在一个数组里面</span></span><br><span class="line">    <span class="keyword">int</span> Tmp=L;<span class="comment">//存放结果得数组得初始位置，从第二个数组得哪个地方开始</span></span><br><span class="line">    <span class="keyword">int</span> NumElements = RightEnd - L + <span class="number">1</span>;<span class="comment">//归并结束后总元素数</span></span><br><span class="line">    <span class="keyword">while</span>(L&lt;=leftEnd &amp;&amp; R&lt;=RightEnd)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[L]&lt;=A[R])TmpA[Tmp++]=A[L++];</span><br><span class="line">        <span class="keyword">else</span> TmpA[Tmp++]=A[R++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(L&lt;=leftEnd)</span><br><span class="line">        TmpA[Tmp++]=A[L++];<span class="comment">//直接复制左边剩下的</span></span><br><span class="line">    <span class="keyword">while</span>(R&lt;=RightEnd)</span><br><span class="line">        TmpA[Tmp++]=A[R++];<span class="comment">//直接复制右边剩下得</span></span><br><span class="line">    <span class="comment">//两个只会执行一个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_pass</span><span class="params">(ElementType A[],ElementType TmpA[],<span class="keyword">int</span> N,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> length)</span></span>&#123;<span class="comment">//length = 当前有序子序列长度</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=N<span class="number">-2</span>*length;i+=<span class="number">2</span>*length)</span><br><span class="line">        Merge1(A,TmpA,i,i+length,i+<span class="number">2</span>*length<span class="number">-1</span>);<span class="comment">//将A中元素归并到TmpA而不直接倒回来</span></span><br><span class="line">    <span class="comment">//处理最后两个</span></span><br><span class="line">    <span class="keyword">if</span>(i+length&lt;N)<span class="comment">//归并最后两个子列</span></span><br><span class="line">        Merge1(A,TmpA,i,i+length,N<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//最后剩一个,直接倒进去就可以了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;N;j++)TmpA[j]=A[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统一接口 重要！！！！</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_sort1</span><span class="params">(ElementType A[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    ElementType *TmpA;</span><br><span class="line">    <span class="keyword">int</span> length=<span class="number">1</span>;</span><br><span class="line">    TmpA=(ElementType*)<span class="built_in">malloc</span>(N * <span class="keyword">sizeof</span>(ElementType));</span><br><span class="line">    <span class="keyword">if</span> (TmpA!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(length&lt;N)&#123;</span><br><span class="line">            Merge_pass(A,TmpA,N,length);</span><br><span class="line">        length *=<span class="number">2</span>;</span><br><span class="line">            Merge_pass(TmpA,A,N,length);</span><br><span class="line">            length *=<span class="number">2</span>;<span class="comment">//两边确保最后一次将TmpA中得序列倒回 A中         </span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">free</span>(TmpA);<span class="comment">//释放临时数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"错误"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(ElementType *x,ElementType *y)</span></span>&#123;</span><br><span class="line">    ElementType temp;</span><br><span class="line">    temp = *x;</span><br><span class="line">    *x=*y;</span><br><span class="line">    *y=temp;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap1</span><span class="params">(ElementType &amp;x,ElementType &amp;y)</span></span>&#123;</span><br><span class="line">    ElementType temp;</span><br><span class="line">    temp = x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=temp;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序     最好：O(n log2 n) 最坏：O(n^2) 平均：O(n log2 n)</span></span><br><span class="line"><span class="function">ElementType <span class="title">Median3</span><span class="params">(ElementType A[],<span class="keyword">int</span> Left,<span class="keyword">int</span> Right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Center=(Left+Right)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(A[Left]&gt;A[Center])</span><br><span class="line">        <span class="comment">//Swap(&amp;A[Left],&amp;A[Center]);</span></span><br><span class="line">    Swap1(A[Center],A[Right]);</span><br><span class="line">    <span class="keyword">if</span>(A[Left]&gt;A[Right])</span><br><span class="line">        <span class="comment">//Swap(&amp;A[Left],&amp;A[Right]);</span></span><br><span class="line">    Swap1(A[Center],A[Right]);</span><br><span class="line">    <span class="keyword">if</span>(A[Center]&gt;A[Right])</span><br><span class="line">        <span class="comment">//Swap(&amp;A[Center],&amp;A[Right]);</span></span><br><span class="line">    Swap1(A[Center],A[Right]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//A[Left]&lt;=A[Center]&lt;=A[Right]</span></span><br><span class="line">    Swap(&amp;A[Center],&amp;A[Right<span class="number">-1</span>]);<span class="comment">//将pivot藏到右边倒数第二个，</span></span><br><span class="line">    <span class="comment">//只需考虑A[Left+1],A[Right-2]，因为第一个和最后一个已经比它小和大</span></span><br><span class="line">    <span class="keyword">return</span> A[Right<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quicksort</span><span class="params">(ElementType A[],<span class="keyword">int</span> Left,<span class="keyword">int</span> Right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Right<span class="number">-1</span>&gt;<span class="number">0</span> &amp;&amp; Left+<span class="number">1</span>&lt;Right)&#123;</span><br><span class="line"><span class="keyword">int</span> Pivot=Median3(A,Left,Right);</span><br><span class="line">    <span class="keyword">int</span> i=Left;</span><br><span class="line">    <span class="keyword">int</span> j=Right<span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>( ; ; )&#123;</span><br><span class="line">        <span class="comment">//A[Left+1],A[Right-2]</span></span><br><span class="line">        <span class="keyword">while</span>(A[++i]&lt;Pivot)&#123;&#125;</span><br><span class="line">        <span class="keyword">while</span>(A[--j]&gt;Pivot)&#123;&#125;</span><br><span class="line">        <span class="comment">//两边都出现问题</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">            <span class="comment">//说明都出现问题 可以调换</span></span><br><span class="line">            Swap(&amp;A[i],&amp;A[j]);</span><br><span class="line">        <span class="comment">//Swap1(A[i],A[j]);</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;<span class="comment">//i&gt;j 调换</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Swap(&amp;A[i],&amp;A[Right<span class="number">-1</span>]);<span class="comment">//将Center这个数放到自己得位置上</span></span><br><span class="line">    Quicksort(A,Left,i<span class="number">-1</span>);<span class="comment">//递归将两边集合继续划分子集排序</span></span><br><span class="line">    Quicksort(A,i+<span class="number">1</span>,Right);</span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quick_Sort</span><span class="params">(ElementType A[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    Quicksort(A,<span class="number">0</span>,N<span class="number">-1</span>);<span class="comment">//数组下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//考试快排</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(Type &amp;x,Type &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(Type a[], <span class="keyword">int</span> p,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p &lt; r)&#123;</span><br><span class="line">        <span class="keyword">int</span> q=Partition(a,p,r);</span><br><span class="line">        QuickSort(a,p,q<span class="number">-1</span>); <span class="comment">//对左半段排序</span></span><br><span class="line">        QuickSort(a,q+<span class="number">1</span>,r);<span class="comment">//对右半段排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(Type a[],<span class="keyword">int</span> p,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = p,j=r+<span class="number">1</span>;</span><br><span class="line">    Type x=a[p];</span><br><span class="line">    <span class="comment">//将小于x的元素交换到左边区域，将大于x的元素交换到右边区域</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(a[++i]&lt;x &amp;&amp; i&lt;r);</span><br><span class="line">        <span class="keyword">while</span>(a[--j]&gt;x);</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=j)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        Swap(a[i],a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    a[p]=a[j];</span><br><span class="line">    a[j]=x;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RandomizedPartition</span><span class="params">(Type a[],<span class="keyword">int</span> p,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=Random(p,r);</span><br><span class="line">    Swap(a[i],a[p]);</span><br><span class="line">    <span class="keyword">return</span> Partition(a,p,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RandomizedQuickSort</span><span class="params">(Type a[],<span class="keyword">int</span> p,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p &lt; r)&#123;</span><br><span class="line">        <span class="keyword">int</span> q= RandomizedPartition(a,p,r);</span><br><span class="line">        RandomizedQuickSort(a,p,q<span class="number">-1</span>);<span class="comment">//对左半段排序</span></span><br><span class="line">        RandomizedQuickSort(a,q+<span class="number">1</span>,r);<span class="comment">//对右半段排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线性时间选择"><a href="#线性时间选择" class="headerlink" title="线性时间选择"></a>线性时间选择</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//采用随机快排 平均时间复杂度0(n)</span></span><br><span class="line"><span class="function">Type <span class="title">RandomizedSelect</span><span class="params">(Type a[],<span class="keyword">int</span> p,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;<span class="comment">//p起点坐标 r为第n-1个位置坐标，</span></span><br><span class="line"><span class="keyword">if</span>(p==r)</span><br><span class="line">    <span class="keyword">return</span> a[p];<span class="comment">//找到第k小元素</span></span><br><span class="line"><span class="keyword">int</span> i=RandomizedPartition(a,p,r);</span><br><span class="line">    <span class="keyword">int</span> j=i-p+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=j)</span><br><span class="line"><span class="keyword">return</span> RandomizedQuickSort(a,p,i,k);<span class="comment">//对左半段排序</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> RandomizedQuickSort(a,i+<span class="number">1</span>,r,k-j);<span class="comment">//对右半段排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-贪心算法"><a href="#2-贪心算法" class="headerlink" title="2.贪心算法"></a>2.贪心算法</h2><h3 id="活动安排"><a href="#活动安排" class="headerlink" title="活动安排"></a>活动安排</h3><p>用数组<code>f[]</code>表示最大结束时间，并从小到大排序 <code>s[]</code>为其对应的开始时间,<code>A[]</code>辅助表示是否满足条件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">GreedySelector</span>(<span class="title">int</span> <span class="title">n</span>,<span class="title">Type</span> <span class="title">s</span>[],<span class="title">Type</span> <span class="title">f</span>[],<span class="title">bool</span> <span class="title">A</span>[])&#123;</span></span><br><span class="line">    sort(f,s,n);<span class="comment">//以f[]为基准从小到大排序</span></span><br><span class="line">    A[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]&gt;=f[j])&#123;<span class="comment">//开始时间大于结束时间</span></span><br><span class="line">            A[i]=<span class="literal">true</span>;</span><br><span class="line">            j=i;         </span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            A[i]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(Type &amp;x,Type &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(ElementType A[],ElementType B[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> p=N<span class="number">-1</span>;p&gt;=<span class="number">0</span>;p--)&#123;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;<span class="comment">//判断是否在一趟排序过程中有序，没有触发Swap</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;p;i++)&#123;<span class="comment">//一趟</span></span><br><span class="line">    <span class="keyword">if</span>(A[i]&gt;A[i+<span class="number">1</span>])&#123;</span><br><span class="line">        Swap(A[i],A[i+<span class="number">1</span>]);</span><br><span class="line">        Swap(B[i],B[i+<span class="number">1</span>]);</span><br><span class="line">        flag=<span class="number">1</span>;<span class="comment">//发生了交换</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//适合单向链表，同一顺序，稳定</span></span><br></pre></td></tr></table></figure><h3 id="最优装载"><a href="#最优装载" class="headerlink" title="最优装载"></a>最优装载</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Loading</span>(<span class="title">int</span> <span class="title">x</span>[],<span class="title">Type</span> <span class="title">w</span>[],<span class="title">Type</span> <span class="title">c</span>,<span class="title">int</span> <span class="title">n</span>)&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *t=<span class="keyword">new</span> <span class="keyword">int</span> [n+<span class="number">1</span>];<span class="comment">//储存w下标</span></span><br><span class="line">    Sort(w,t,n);<span class="comment">//以w为基准从小到大排序，合并排序 稳定</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        x[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n &amp;&amp; w[t[i]]&lt;=c;i++)&#123;</span><br><span class="line">        x[t[i]]=<span class="number">1</span>;</span><br><span class="line">        c-=w[t[i]]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Huffman</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> BinaryTree&lt;<span class="keyword">int</span>&gt; HuffmanTree(Type [],<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">Type</span> <span class="params">()</span><span class="keyword">const</span></span>&#123; <span class="keyword">return</span> weight;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    BinaryTree&lt;<span class="keyword">int</span>&gt; tree;</span><br><span class="line">    Type weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">BinaryTree</span>&lt;int&gt; <span class="title">HuffmanTree</span>(<span class="title">Type</span> <span class="title">f</span>[],<span class="title">int</span> <span class="title">n</span>)&#123;</span></span><br><span class="line">    Huffman&lt;Type&gt; *w=<span class="keyword">new</span> Huffman&lt;Type&gt; [n+<span class="number">1</span>];</span><br><span class="line">    BinaryTree&lt;<span class="keyword">int</span>&gt; a,zero;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        z.MakeTree(i,zero,zero);</span><br><span class="line">        w[i].weight = f[i];</span><br><span class="line">        w[i].tree = z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//建优先队列</span></span><br><span class="line">    MinHeap&lt;Huffman&lt;Type&gt;&gt;Q(<span class="number">1</span>);</span><br><span class="line">    Q.Initialize(w,n,n);</span><br><span class="line">    <span class="comment">//反复合并最小频率树</span></span><br><span class="line">    Huffman&lt;Type&gt; x,y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        Q.DeleteMin(x);</span><br><span class="line">        Q.DeleteMin(y);</span><br><span class="line">        z.MakeTree(<span class="number">0</span>,x.tree,y.tree);</span><br><span class="line">        w.weight+=y.weight;</span><br><span class="line">        x.tree=z;</span><br><span class="line">        Q.Insert(x);</span><br><span class="line">    &#125;</span><br><span class="line">    Q.DeleteMin(x);</span><br><span class="line">    Q.Deactivate();</span><br><span class="line">    <span class="keyword">delete</span> []w;</span><br><span class="line">    <span class="keyword">return</span> x.tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h3><p>针对带权有向图，设置顶点集合S,并不断地做贪心选择来扩充这个集合。</p><p>算法描述：输入一个带权有向图G=(V,E),E={1,2···,n},顶点v是源 起点。c是一个二维数组，<code>c[i][j]</code>表示边( i , j ) 的权。当(i,j)不属于E时，<code>c[i][j]</code>=∞。dist[i] 表示当前从源到顶点 i 的最短路径长度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Dijkstra</span>(<span class="title">int</span> <span class="title">n</span>,<span class="title">int</span> <span class="title">v</span>,<span class="title">Type</span> <span class="title">dist</span>[],<span class="title">int</span> <span class="title">prev</span>[],<span class="title">Type</span> **<span class="title">c</span>)&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> s[maxint];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dist[i]=c[v][i];</span><br><span class="line">        s[i]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(dist[i]==maxint)</span><br><span class="line">            prev[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            prev[i]=v;<span class="comment">//当前i顶点对应的前一个顶点下标</span></span><br><span class="line">    &#125;</span><br><span class="line">    dist[v]=<span class="number">0</span>;s[v]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=maxint;</span><br><span class="line">        <span class="keyword">int</span> u=v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((!s[j])&amp;&amp;(dist[j]&lt;temp))&#123;</span><br><span class="line">                u=j;</span><br><span class="line">                temp = dist[j];</span><br><span class="line">            &#125;</span><br><span class="line">            s[u]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((!s[j])&amp;&amp;(c[u][j]&lt;maxint))&#123;</span><br><span class="line">                    Type newdist =dist[u]+c[u][j];</span><br><span class="line">                    <span class="keyword">if</span>(newdist&lt;dist[j])&#123;</span><br><span class="line">                        dist[j]=newdist;</span><br><span class="line">                        prev[j]= u;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Prim</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Void</span> <span class="title">Prim</span>(<span class="title">int</span> <span class="title">n</span>,<span class="title">Type</span> **<span class="title">c</span>)&#123;</span></span><br><span class="line">    Type lowcost[maxint];</span><br><span class="line">    <span class="keyword">int</span> closest[maxint];</span><br><span class="line">    <span class="keyword">bool</span> s[maxint];</span><br><span class="line">    s[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        lowcost[i]=c[<span class="number">1</span>][i];</span><br><span class="line">        closest[i]=<span class="number">1</span>;</span><br><span class="line">        s[i]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        Type min=inf;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//找中使用权值最小的顶点j</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>;k&lt;=n;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((lowcost[k]&lt;min)&amp;&amp; (!s[k]))&#123;</span><br><span class="line">                min=lowcost[k];</span><br><span class="line">                j=k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到符合贪心选择方式的边，将顶点j加入到集合S</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;j&lt;&lt;<span class="string">' '</span>&lt;&lt;closest[j]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        s[j]=<span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//找到一条边后，更新数组closest和lowcost</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((c[j][k]&lt;lowcost[k]) &amp;&amp; (!s[k]))&#123;</span><br><span class="line">            lowcost[k]=c[j][k];</span><br><span class="line">                closest[k]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Kruskal</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">EdgeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp;, EdgeNode&lt;Type&gt;);</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span> ,EdgeNode&lt;Type&gt;*,EdgeNode&lt;Type&gt;*)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">Type</span> <span class="params">()</span><span class="keyword">const</span></span>&#123;<span class="keyword">return</span> weight;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type weight;</span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">Kruskal</span>(<span class="title">int</span> <span class="title">n</span>,<span class="title">int</span> <span class="title">e</span>,<span class="title">EdgeNode</span>&lt;Type&gt; <span class="title">E</span>[],<span class="title">EdgeNode</span>&lt;Type&gt; <span class="title">t</span>[])&#123;</span></span><br><span class="line">MinHeap&lt;EdgeNode&lt;Type&gt;&gt;H(<span class="number">1</span>);</span><br><span class="line">    H.Initialize(E,e,e);</span><br><span class="line">    <span class="function">UnionFind <span class="title">U</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (e &amp;&amp; k&lt; n<span class="number">-1</span>)&#123;</span><br><span class="line">        EdgeNode&lt;<span class="keyword">int</span>&gt; x;</span><br><span class="line">        H.DeletMin(x);</span><br><span class="line">        e--;</span><br><span class="line">        <span class="keyword">int</span> a=U.Find(s.u);</span><br><span class="line">        <span class="keyword">int</span> b=U.Find(x.v);</span><br><span class="line">        <span class="keyword">if</span>(a!=b)&#123;</span><br><span class="line">            t[k++]=x;</span><br><span class="line">            U.Union(a,b);</span><br><span class="line">        &#125;</span><br><span class="line">        H.Deactivate();</span><br><span class="line">        <span class="keyword">return</span>(k==n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-动态规划"><a href="#3-动态规划" class="headerlink" title="3.动态规划"></a>3.动态规划</h2><h3 id="矩阵连乘"><a href="#矩阵连乘" class="headerlink" title="矩阵连乘"></a>矩阵连乘</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算矩阵乘积</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">matrixMultiply</span><span class="params">(<span class="keyword">int</span> **a,<span class="keyword">int</span> **b,<span class="keyword">int</span> **c,<span class="keyword">int</span> ra,<span class="keyword">int</span> ca,<span class="keyword">int</span> rb,<span class="keyword">int</span> cb)</span></span>&#123;</span><br><span class="line">    <span class="comment">//ra,ca和rb,cb 分别表示矩阵A和B的行数和列数</span></span><br><span class="line">    <span class="keyword">if</span>(ca!=rb)</span><br><span class="line">        error(<span class="string">"矩阵不可乘"</span>)；</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ra;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cb;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum=a[i][<span class="number">0</span>]*b[<span class="number">0</span>][j];<span class="comment">//第一个元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;ca;k++)</span><br><span class="line">                sum+=a[i][k]*b[k][j];</span><br><span class="line">            c[i][j]=sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划寻找最优值，输入参数存储与p中，输出最优值数组m，记录最优值断开位置数组s</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MatrixChain</span><span class="params">(<span class="keyword">int</span> *p,<span class="keyword">int</span> n,<span class="keyword">int</span> **m,<span class="keyword">int</span> **s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        m[i][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">2</span>;r&lt;=n;r++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-r+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j=i+r<span class="number">-1</span>;</span><br><span class="line">            m[i][j]=m[i+<span class="number">1</span>][j]+p[i<span class="number">-1</span>]*p[k]*p[j];</span><br><span class="line">            s[i][j]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;j;k++)&#123;</span><br><span class="line">                <span class="keyword">int</span> t=m[i][k]+m[k][j]+p[i<span class="number">-1</span>]*p[k]*p[j];</span><br><span class="line">                <span class="keyword">if</span>(t&lt;m[i][j])&#123;</span><br><span class="line">                    m[i][j]=t;</span><br><span class="line">                    s[i][j]=k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traceback</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> **s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==j)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Traceback(i,s[i][j],s);</span><br><span class="line">    Traceback(s[i][j]+<span class="number">1</span>,j,s);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Multiply A"</span>&lt;&lt;i&lt;&lt;<span class="string">","</span>&lt;&lt;s[i][j];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"and A"</span>&lt;&lt; (s[i][j]+<span class="number">1</span>)&lt;&lt;<span class="string">","</span>&lt;&lt;j&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LCSlength</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n,<span class="keyword">char</span> *x,<span class="keyword">char</span> *y,<span class="keyword">int</span> **c,<span class="keyword">int</span> **b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        c[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        c[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x[i]==y[j])&#123;<span class="comment">//左上角</span></span><br><span class="line">                c[i][j]=c[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                b[i][j]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c[i<span class="number">-1</span>][j] &gt;= c[i][j<span class="number">-1</span>])&#123;<span class="comment">//上一行</span></span><br><span class="line">                c[i][j]=c[i<span class="number">-1</span>][j];</span><br><span class="line">                b[i][j]=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//前一列</span></span><br><span class="line">                c[i][j]=c[i][j<span class="number">-1</span>];</span><br><span class="line">                b[i][j]=<span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="凸多边形最优三角剖分"><a href="#凸多边形最优三角剖分" class="headerlink" title="凸多边形最优三角剖分"></a>凸多边形最优三角剖分</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">MinWeightTriangulation</span>(<span class="title">int</span> <span class="title">n</span>,<span class="title">Type</span> **<span class="title">t</span>,<span class="title">int</span> **<span class="title">s</span>)&#123;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        t[i][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">2</span>;r&lt;=n;r++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-r+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j=i+r<span class="number">-1</span>;</span><br><span class="line">            t[i][j]=t[i+<span class="number">1</span>][j]+w(i<span class="number">-1</span>,i,j);</span><br><span class="line">            s[i][j]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;i+r<span class="number">-1</span>;k++)&#123;</span><br><span class="line">                <span class="keyword">int</span> u=t[i][k]+t[k+<span class="number">1</span>][j]+w(i<span class="number">-1</span>,k,j);</span><br><span class="line">                <span class="keyword">if</span>(u&lt;t[i][j])&#123;</span><br><span class="line">                    t[i][j]=u;</span><br><span class="line">                    s[i][j]=k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最优二叉搜索树"><a href="#最优二叉搜索树" class="headerlink" title="最优二叉搜索树"></a>最优二叉搜索树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OBST</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> n,<span class="keyword">int</span> **m,<span class="keyword">int</span> **s,<span class="keyword">int</span> **w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        w[i+<span class="number">1</span>][i]=a[i];</span><br><span class="line">        m[i+<span class="number">1</span>][i]=<span class="number">0</span>;</span><br><span class="line">        s[i+<span class="number">1</span>][i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;n;r++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-r;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j=i+r,i1=s[i][j<span class="number">-1</span>]&gt;i ? s[i][j<span class="number">-1</span>]:i,j1=s[i+<span class="number">1</span>][j]&gt;i ? s[i+<span class="number">1</span>][j]:j</span><br><span class="line">        w[i][j]=w[i][j<span class="number">-1</span>]+a[j]+b[j];</span><br><span class="line">            m[i][j]=m[i][i1<span class="number">-1</span>]+m[i1+<span class="number">1</span>][j];</span><br><span class="line">            s[i][j]=i1;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i1+<span class="number">1</span>;k&lt;=j1;k++)&#123;</span><br><span class="line">                <span class="keyword">int</span> t = m[i][k<span class="number">-1</span>] + m[k+<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(t&lt;=m[i][j])&#123;</span><br><span class="line">                    m[i][j]=t;</span><br><span class="line">                    s[i][j]=k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line"> m[i][j] +=w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2020/08/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2020/08/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构复习"><a href="#数据结构复习" class="headerlink" title="数据结构复习"></a>数据结构复习</h1><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><p><img src="/2020/08/24/数据结构/1.jpg" alt></p><p><img src="/2020/08/24/数据结构/2.jpg" alt></p><a id="more"></a><ul><li>若两端算法分别由复杂度$T_1(n)=O(f_1(n))$和$T_2(n)=O(f_2(n))$则<ul><li>$T_1(n)+T_2(n)=max(O(f_1(n)),O(f_2(n))$</li><li>$T_1(n)<em>T_2(n)=O(f_1(n)</em>f_2(n))$</li></ul></li><li>若$T(n)$是关于 n 的 k 阶多项式，那么$T(n)=O(n^k)$</li><li>一个<strong>for</strong>循环的时间复杂度等于循环次数乘以循环体代码的复杂度</li></ul><p>例题1 给定N个整数序列{A1，A2，……，An}；求函数$f(i,j)=max(\sum_{i=0}^jA_k)$的最大值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1 时间复杂度O(n^2)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSubseqSum1</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ThisSum,MaxSum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;N;k++)&#123;</span><br><span class="line">            ThisSum+=A[j];</span><br><span class="line">            <span class="keyword">if</span>(ThisSum&gt;MaxSum)</span><br><span class="line">                MaxSum=ThisSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MaxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法2 分而治之(递归) 时间复杂度O(nlogn) 见归并排序</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法3 在线处理（动态规划） 时间复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSubseqSum1</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ThisSum=<span class="number">0</span>,MaxSum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        ThisSum+=A[i];<span class="comment">//向右累加</span></span><br><span class="line">        <span class="keyword">if</span>(ThisSum&gt;MaxSum)</span><br><span class="line">            MaxSum=ThisSum;<span class="comment">//发现更大和则更新当前结果</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ThisSum&lt;<span class="number">0</span>)<span class="comment">//如果发现当前子列和为负数</span></span><br><span class="line">            ThisSum=<span class="number">0</span>;<span class="comment">//则不可能使后面的部分和增大，抛弃之</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MaxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="考-线性表（查找，增加，删除）"><a href="#考-线性表（查找，增加，删除）" class="headerlink" title="(考)线性表（查找，增加，删除）"></a>(考)线性表（查找，增加，删除）</h3><p>定义：（对象集）一个线性表是<code>n</code>个数据元素的有限序列。由同类型元素构成有序序列的线性结构。</p><ul><li>线性表<strong>顺序存储,</strong>抽象表示（考）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElementType Data[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> Last;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> <span class="title">L</span>;</span></span><br><span class="line">List Ptrl;</span><br><span class="line"><span class="comment">//访问下标i的元素：L.Data[i]或Ptrl-&gt;Data[i]</span></span><br><span class="line"><span class="comment">//线性表的长度：L.Last+1或Ptrl-&gt;last+1</span></span><br><span class="line"><span class="comment">//初始化（建立空表）</span></span><br><span class="line"><span class="function">List <span class="title">MakeEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List PtrL;</span><br><span class="line">    ptrL=(List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">    PtrL-&gt;Last=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> PtrL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(ElementType X,List Ptrl)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=PtrL-&gt;Last &amp;&amp; PtrL-&gt;Data[i]!=X) i++;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;PtrL-&gt;Last)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> i;</span><br><span class="line">&#125;<span class="comment">//时间复杂度 O(n)</span></span><br><span class="line"><span class="comment">//插入从后往前先挪数，再插入到i-1下标，第i个元素下标0开始</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(ElementType X,<span class="keyword">int</span> i,List PtrL)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">if</span>(Ptrl-&gt;Last==MAXSIZE<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"表满了，插不进去"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;PtrL-&gt;Last+<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"位置不合法"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j=PtrL-&gt;Last;j&gt;=i<span class="number">-1</span>;j--)</span><br><span class="line">        Ptrl-&gt;Data[j+<span class="number">1</span>]=PtrL-&gt;Data[j];</span><br><span class="line">    PtrL-&gt;Data[i<span class="number">-1</span>]=X;</span><br><span class="line">    PtrL-&gt;Last++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="comment">//O(n)</span></span><br><span class="line"><span class="comment">//删除,从i开始向前挪，覆盖前一个</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> i,List PtrL)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">   <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;PtrL-&gt;Last+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"位置不合法"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j=i;j&lt;=PtrL-&gt;Last;j++)</span><br><span class="line">         Ptrl-&gt;Data[j<span class="number">-1</span>]=PtrL-&gt;Data[j];</span><br><span class="line">    PtrL-&gt;Last--;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="comment">//O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//手写代码</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> ElementType int</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> LIST_INIT_SIZE 10 <span class="comment">//初始分配长度</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> LISTINCREMENT  5  <span class="comment">//存储空间的分配增量 </span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//动态分配 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">ElementType *data;</span><br><span class="line"><span class="keyword">int</span> length;<span class="comment">//当前长度 </span></span><br><span class="line"><span class="keyword">int</span> listsize;<span class="comment">//当前分配的储存容量(以sizeof(ELementType)为单位) </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造一个空的顺序表，返回指针 </span></span><br><span class="line"><span class="function">struct LNode* <span class="title">InitList_Sq</span><span class="params">()</span></span>&#123;<span class="comment">//初始化一个顺序表 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">q</span>;</span></span><br><span class="line">q=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">q-&gt;data=(ElementType*)<span class="built_in">malloc</span>(LIST_INIT_SIZE*<span class="keyword">sizeof</span>(ElementType));</span><br><span class="line"><span class="keyword">if</span>(!q-&gt;data)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"内存空间不足\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">q-&gt;length=<span class="number">0</span>;</span><br><span class="line">q-&gt;listsize=LIST_INIT_SIZE;</span><br><span class="line"><span class="keyword">return</span> q;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//按值查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(ElementType X,struct LNode *p)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;p-&gt;length &amp;&amp; p-&gt;data[i]!=X) &#123;i++;&#125;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=p-&gt;length)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> i+<span class="number">1</span>;<span class="comment">//返回下标要+1才是位置 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除 按位置删除 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> i,struct LNode *p)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;p-&gt;length)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"位置不合法\n"</span>);</span><br><span class="line"><span class="comment">//return ; </span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(j=i;j&lt;=p-&gt;length;j++)<span class="comment">//=将a[10]不存在转换到a[9] </span></span><br><span class="line">p-&gt;data[j<span class="number">-1</span>]=p-&gt;data[j];</span><br><span class="line">p-&gt;length--;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入 从后往前先挪数，再插入到i-1下标，第i个元素下标0开始 </span></span><br><span class="line"><span class="function">struct LNode* <span class="title">Insert</span><span class="params">(ElementType X,<span class="keyword">int</span> i,struct LNode *p)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;length==p-&gt;listsize)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"表满了，插不进去\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//跳出函数 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;=p-&gt;length+<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"位置不合法\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j=p-&gt;length;j&gt;=i<span class="number">-1</span>;j--)</span><br><span class="line">        p-&gt;data[j+<span class="number">1</span>]=p-&gt;data[j];</span><br><span class="line">    p-&gt;data[i<span class="number">-1</span>]=X;</span><br><span class="line">    p-&gt;length++;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">struct LNode* <span class="title">InitList_Sq</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(ElementType X,struct LNode *p)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">q</span>;</span></span><br><span class="line">q=InitList_Sq();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">q-&gt;data[i]=i;</span><br><span class="line">q-&gt;length+=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找 </span></span><br><span class="line"><span class="keyword">int</span> g=Find(<span class="number">13</span>,q);</span><br><span class="line"><span class="keyword">if</span>(g==<span class="number">-1</span>)<span class="built_in">printf</span>(<span class="string">"不在\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"在%d个位置\n"</span>,g);  </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;q-&gt;length;j++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,q-&gt;data[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n%d\n"</span>,q-&gt;length);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除 </span></span><br><span class="line">Delete(<span class="number">6</span>,q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;q-&gt;length;j++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,q-&gt;data[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n%d\n"</span>,q-&gt;length);</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入 </span></span><br><span class="line">q=Insert(<span class="number">10</span>,<span class="number">11</span>,q);</span><br><span class="line"><span class="keyword">if</span>(q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;q-&gt;length;j++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,q-&gt;data[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n%d\n"</span>,q-&gt;length);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>链式存储，抽象表示</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    List Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> <span class="title">L</span>;</span></span><br><span class="line">List PtrL;</span><br><span class="line"><span class="comment">//求表长</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(List PtrL)</span></span>&#123;</span><br><span class="line">    List p=PtrL;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        p=p-&gt;Next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;<span class="comment">//O(n)</span></span><br><span class="line"><span class="comment">//按序号查找</span></span><br><span class="line"><span class="function">List <span class="title">FindKth</span><span class="params">(<span class="keyword">int</span> K,List PtrL)</span></span>&#123;</span><br><span class="line">    List p=PtrL;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;i&lt;K)&#123;</span><br><span class="line">        p=p-&gt;Next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i==K)<span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;<span class="comment">//O(n)</span></span><br><span class="line"><span class="comment">//按值查找</span></span><br><span class="line"><span class="function">List <span class="title">Find</span><span class="params">(ElementType X,List Ptrl)</span></span>&#123;</span><br><span class="line">    List p=Ptrl;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;Data!=X)</span><br><span class="line">        p=p-&gt;Next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;<span class="comment">//O(n)</span></span><br><span class="line"><span class="comment">//插入结点，找i-1</span></span><br><span class="line"><span class="function">List <span class="title">Insert</span><span class="params">(ElementType X,<span class="keyword">int</span> i,List PtrL)</span></span>&#123;</span><br><span class="line">    List p,s;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;<span class="comment">//新节点插入表头，将头指针改变，替换原来的头指针</span></span><br><span class="line">        s=(List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">        s-&gt;Data=X;</span><br><span class="line">        s-&gt;Next=PtrL;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    p = FindKth(i<span class="number">-1</span>,PtrL);</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"参数错误"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        s=(List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">        s-&gt;Data=X;</span><br><span class="line">        s-&gt;Next=p-&gt;Next;</span><br><span class="line">        p-&gt;Next=s;</span><br><span class="line">        <span class="keyword">return</span> PtrL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//O(n)</span></span><br><span class="line"><span class="comment">//删除结点，找i-1</span></span><br><span class="line"><span class="function">List <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> i,List Ptrl)</span></span>&#123;</span><br><span class="line">    List p,s;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">        s=PtrL;</span><br><span class="line">        <span class="keyword">if</span>(PtrL!=<span class="literal">NULL</span>)PtrL=PtrL-&gt;Next;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(s);</span><br><span class="line">        <span class="keyword">return</span> PtrL;</span><br><span class="line">    &#125;</span><br><span class="line">    p=FindKth(i<span class="number">-1</span>,PtrL);</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"结点不存在"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;Next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"结点不存在"</span>);<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        s=p-&gt;Next;</span><br><span class="line">        p-&gt;Next=s-&gt;Next;</span><br><span class="line">        <span class="built_in">free</span>(s);</span><br><span class="line">        <span class="keyword">return</span> PtrL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//O(n)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链表实现</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Data;</span><br><span class="line">    List Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">List <span class="title">FindKth</span><span class="params">(<span class="keyword">int</span> K,List PtrL)</span></span>&#123;</span><br><span class="line">    List p=PtrL;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;<span class="comment">//插入到第二个结点 </span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; i&lt;K)&#123;</span><br><span class="line">        p=p-&gt;Next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    printf("第一%d\n 第二%d",i,K); </span></span><br><span class="line">    <span class="keyword">if</span>(i==K)<span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;<span class="comment">//O(n)</span></span><br><span class="line"><span class="function">List <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> X,<span class="keyword">int</span> i,List PtrL)</span></span>&#123;</span><br><span class="line">    List p,s;<span class="comment">//本身List就是指针类型，属于加*</span></span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;<span class="comment">//新节点插入表头，将头指针改变，替换原来的头指针</span></span><br><span class="line">        s=(List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">        s-&gt;Data=X;</span><br><span class="line">        s-&gt;Next=PtrL;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    p = FindKth(i<span class="number">-1</span>,PtrL);</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"参数错误"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        s=(List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">        s-&gt;Data=X;</span><br><span class="line">        s-&gt;Next=p-&gt;Next;</span><br><span class="line">        p-&gt;Next=s;</span><br><span class="line">        <span class="keyword">return</span> PtrL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">List <span class="title">FindKth</span><span class="params">(<span class="keyword">int</span> K,List PtrL)</span></span>;</span><br><span class="line"><span class="function">List <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> X,<span class="keyword">int</span> i,List PtrL)</span></span>;</span><br><span class="line">LNode *head,*p,*q,*w;</span><br><span class="line">w=(List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">w-&gt;Data=<span class="number">3</span>;</span><br><span class="line">w-&gt;Next=<span class="literal">NULL</span>;</span><br><span class="line">q=(List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">q-&gt;Data=<span class="number">2</span>;</span><br><span class="line">q-&gt;Next=w;</span><br><span class="line">p=(List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">p-&gt;Data=<span class="number">1</span>;</span><br><span class="line">p-&gt;Next=q;</span><br><span class="line"></span><br><span class="line">head=p;</span><br><span class="line"></span><br><span class="line">p=Insert(<span class="number">4</span>,<span class="number">3</span>,p); </span><br><span class="line"></span><br><span class="line">p=Insert(<span class="number">5</span>,<span class="number">3</span>,p);</span><br><span class="line">p=Insert(<span class="number">6</span>,<span class="number">3</span>,p);</span><br><span class="line">p=Insert(<span class="number">7</span>,<span class="number">3</span>,p);</span><br><span class="line">p=Insert(<span class="number">8</span>,<span class="number">3</span>,p);</span><br><span class="line"><span class="keyword">while</span>(head-&gt;Data!=<span class="literal">NULL</span>)&#123;<span class="comment">//不要漏掉结点</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,head-&gt;Data);</span><br><span class="line">head=head-&gt;Next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="考-堆栈"><a href="#考-堆栈" class="headerlink" title="(考)堆栈"></a>(考)堆栈</h3><ul><li>插入数据：入栈(Push)</li><li>删除数据：出栈(Pop)</li><li>后入先出：Last In First Out(LIFO)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//！！！顺序存储实现，抽象</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MaxSize<span class="meta-string">&lt;个数&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span>&#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> Top;<span class="comment">//栈顶数组下标</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(Stack PtrS,ElementType item)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(PtrS-&gt;Top==MaxSize<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"堆栈满"</span>);<span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        PtrS-&gt;Data[++(P-&gt;Top)]=item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">(Stack PtrS)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(PtrS-&gt;Top==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"堆栈空"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>(PtrS-&gt;Data[(PrtS-&gt;Top)--]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElementType int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxsize 10</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span>&#123;</span></span><br><span class="line"><span class="comment">//ElementType *data;//如果使用动态分配需要指针 </span></span><br><span class="line">ElementType data[Maxsize];</span><br><span class="line"><span class="keyword">int</span> top;<span class="comment">//数组栈顶下标 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct SNode* <span class="title">Init_Stack</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">p</span>=(<span class="title">SNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">SNode</span>));</span></span><br><span class="line"><span class="comment">//p-&gt;data =(ElementType*)malloc(Maxsize*sizeof(ElementType));</span></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"内存不足"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p-&gt;top=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进栈 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(ElementType k,struct SNode *p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;top==Maxsize<span class="number">-1</span>)&#123;<span class="comment">//如果使用动态分配，Maxsize要传入</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"栈满"</span>); </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">p-&gt;data[++(p-&gt;top)]=k;<span class="comment">//先自增在进栈</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈 </span></span><br><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">(struct SNode *p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;top==<span class="number">-1</span>)&#123;<span class="comment">//0可能有数 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"堆栈空"</span>); </span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">//抛出异常 退出 </span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> p-&gt;data[(p-&gt;top)--];<span class="comment">//先弹出在自减 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">p</span>;</span></span><br><span class="line">p=Init_Stack();</span><br><span class="line">Push(<span class="number">1</span>,p);</span><br><span class="line">Push(<span class="number">2</span>,p);</span><br><span class="line"><span class="keyword">int</span> i=Pop(p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">Push(<span class="number">3</span>,p); </span><br><span class="line">Push(<span class="number">4</span>,p); </span><br><span class="line">Push(<span class="number">5</span>,p); </span><br><span class="line">i=Pop(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=p-&gt;top;i++)<span class="built_in">printf</span>(<span class="string">"栈内有：%d\n"</span>,p-&gt;data[i]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,p-&gt;top);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用一个数组实现两个堆栈，要求最大地利用数组空间，使数组只要有空间入栈操作就可以成功。(使这两个栈分别从数组的两头开始向中间生长，当两个栈的栈顶指针相遇时，表示两个栈都满了)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MaxSize<span class="meta-string">&lt;个数&gt;</span></span></span><br><span class="line"><span class="comment">//typedef struct Dstack *S;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DStack</span>&#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> Top1;<span class="comment">//栈顶数组下标</span></span><br><span class="line">    <span class="keyword">int</span> Top2;</span><br><span class="line">&#125;S;</span><br><span class="line">S.Top1=<span class="number">-1</span>;<span class="comment">//数组两边下标，越界所以需要先自增或先自减</span></span><br><span class="line">S.Top2=MaxSize;</span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(Stack Dstack *PtrS,ElementType item,<span class="keyword">int</span> Tag)</span></span>&#123;<span class="comment">//当Tag=1为第一个堆栈，2为第二个堆栈</span></span><br><span class="line">    <span class="keyword">if</span>(PtrS-&gt;Top2-PtrS-&gt;Top1==<span class="number">1</span>)&#123;<span class="comment">//相邻右边减左边</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"堆栈满"</span>);<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Tag==<span class="number">1</span>)</span><br><span class="line">        PtrS-&gt;Data[++(P-&gt;Top1)]=item;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        PtrS-&gt;Data[--(P-&gt;Top2)]=item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">(Stack Dstack *PtrS,<span class="keyword">int</span> Tag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Tag==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(PtrS-&gt;Top1==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"堆栈1空"</span>); <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> PtrS-&gt;Data[(PrtS-&gt;Top1)--];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(PtrS-&gt;Top2==MaxSize)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"堆栈2空"</span>);<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> PtrS-&gt;Data[(PrtS-&gt;Top2)++];       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>表达式求值(中缀转后缀)<ul><li>运算数：直接输出；</li><li>左括号：压入堆栈；</li><li>右括号：将栈顶的运算符弹出并输出，直到遇到左括号(出栈，不输出)；</li><li>运算符：<ul><li>若优先级<strong>大于</strong>栈顶运算符时，把它进行压栈；</li><li>若优先级<strong>小于等于</strong>栈顶运算符时，将栈顶运算符弹出并输出；再比较新的栈顶运算符，直到该运算符大于栈顶运算符优先级为止，然后将该运算符压栈；</li></ul></li><li>若各对象处理完毕，则把堆栈中留存的运算符<strong>一并输出</strong>。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><hr><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul><li>插入数据：入队列(AddQ)</li><li>删除数据：出队列(DeleteQ)</li><li>先来先服务</li><li>先进先出：FIFO</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize<span class="meta-string">&lt;个数&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> rear;<span class="comment">//队头，插入</span></span><br><span class="line">    <span class="keyword">int</span> front;<span class="comment">//队尾，删除</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">Queue</span>;</span></span><br><span class="line"><span class="comment">//循环队列 数组内只放放n-1个元素防止误判 满/空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddQ</span><span class="params">(Queue PtrQ,ElementType item)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((PtrQ-&gt;rear+<span class="number">1</span>)%MaxSize==PtrQ-&gt;front)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列满"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PtrQ-&gt;rear=(PtrQ-&gt;rear+<span class="number">1</span>)%MaxSize;<span class="comment">//最后一位会变零</span></span><br><span class="line">    ptrQ-&gt;Data[PtrQ-&gt;rear]=item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出队列</span></span><br><span class="line"><span class="function">ElementType <span class="title">DeleteQ</span><span class="params">(Queue PtrQ)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(PtrQ-&gt;front==PtrQ-&gt;rear)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列空"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        PtrQ-&gt;front=(PtrQ-&gt;front+<span class="number">1</span>)%MaxSize;</span><br><span class="line">        <span class="keyword">return</span>  ptrQ-&gt;Data[PtrQ-&gt;front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElementType int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR -99</span></span><br><span class="line"><span class="comment">//构建结点信息 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">Next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span><span class="comment">//链队列结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">rear</span>;</span><span class="comment">//指向队尾</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">front</span>;</span><span class="comment">//指向队头</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ElementType <span class="title">DeleteQ</span><span class="params">(struct QNode *PtrQ)</span></span>&#123;</span><br><span class="line"><span class="comment">//    pNode FrontCell;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">FrontCell</span>;</span></span><br><span class="line">    ElementType FrontElem;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(PtrQ-&gt;front==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列空"</span>);<span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    FrontCell=PtrQ-&gt;front;</span><br><span class="line">    <span class="keyword">if</span>(PtrQ-&gt;front==PtrQ-&gt;rear)<span class="comment">//若队列只有一个元素</span></span><br><span class="line">        PtrQ-&gt;front=PtrQ-&gt;rear=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        PtrQ-&gt;front=PtrQ-&gt;front-&gt;Next;</span><br><span class="line">    FrontElem=FrontCell-&gt;Data;<span class="comment">//将删除的元素返回</span></span><br><span class="line">    <span class="built_in">free</span>(FrontCell);</span><br><span class="line">    <span class="keyword">return</span> FrontElem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddQ</span><span class="params">(struct QNode *q,ElementType i)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">qNode</span>;</span></span><br><span class="line">    qNode=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!qNode)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"内存空间不足\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    qNode-&gt;Data=i;</span><br><span class="line">    qNode-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;front==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        q-&gt;front = qNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;rear == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        q-&gt;rear = qNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//头尾不为null，则执行下列操作</span></span><br><span class="line">        q-&gt;rear-&gt;Next=qNode;<span class="comment">//连上上一个指针  </span></span><br><span class="line">        q-&gt;rear=qNode;<span class="comment">//队尾指针从新被定义</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmptyQ</span><span class="params">(struct QNode *q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (q-&gt;front == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrientQueue</span><span class="params">(struct QNode *q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsEmptyQ(q))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"空队列\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"打印队列所有元素：\n"</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">qnode</span> = <span class="title">q</span>-&gt;<span class="title">front</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(qnode != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,qnode-&gt;Data);</span><br><span class="line">        qnode= qnode-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">ElementType <span class="title">DeleteQ</span><span class="params">(struct QNode *PtrQ)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddQ</span><span class="params">(struct QNode *q,ElementType i)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="keyword">int</span> w;</span><br><span class="line">p=(QNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct QNode));</span><br><span class="line">p-&gt;front=p-&gt;rear=<span class="literal">NULL</span>;</span><br><span class="line">AddQ(p,<span class="number">1</span>);</span><br><span class="line">AddQ(p,<span class="number">2</span>);</span><br><span class="line">AddQ(p,<span class="number">3</span>);</span><br><span class="line">AddQ(p,<span class="number">4</span>);</span><br><span class="line">AddQ(p,<span class="number">5</span>);</span><br><span class="line">PrientQueue(p);</span><br><span class="line">DeleteQ(p);</span><br><span class="line">DeleteQ(p);</span><br><span class="line"></span><br><span class="line">PrientQueue(p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h3><p>顺序查找</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElementType Element[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> Length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SequentialSearch</span> <span class="params">(struct LNode *Tb1,ElementType K)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    Tb1-&gt;Element[<span class="number">0</span>]=K;</span><br><span class="line">    <span class="keyword">for</span>(i =Tb1-&gt;Length; Tb1-&gt;Element[i]!=K;i--);<span class="comment">//建立哨兵，返回数组下标没有返回0，哨兵坐标。</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;<span class="comment">//O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SequentialSearch</span><span class="params">(ElementType A[],ElementType K,<span class="keyword">int</span> N)</span></span>&#123;<span class="comment">//顺序查找 </span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(A[i]==K)<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a><strong>二分查找</strong></h4><ul><li>假设<code>n</code>个数据元素的关键字满足<strong>有序</strong>(比如：小到大)(k1&lt;k2&lt;····&lt;kn)并且是连续存放<strong>（数组）</strong>，那么可以进行二分查找。</li><li>二叉排序树-&gt;动态查找问题</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElementType Element[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> Length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(struct LNode *Tb1,ElementType K)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left,right,mid,NoFound=<span class="number">-1</span>;</span><br><span class="line">    left=<span class="number">1</span>;<span class="comment">//左边界</span></span><br><span class="line">    right=Tb1-&gt;Length;<span class="comment">//右边界</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        mid=(left+right)/<span class="number">2</span>;<span class="comment">//计算中间元素</span></span><br><span class="line">        <span class="keyword">if</span>(K&lt;Tb1-&gt;Element[mid]) right=mid<span class="number">-1</span>;<span class="comment">//调整右边界</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(K&gt;Tb1-&gt;Element[mid]) left=mid+<span class="number">1</span>;<span class="comment">//调整左边界</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid;<span class="comment">//查找成功，返回元素下标。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NotFound;<span class="comment">//查找失败，返回-1  </span></span><br><span class="line">&#125;<span class="comment">//O(logN)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(ElementType A[],ElementType K,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> left,right,mid,Nofound=<span class="number">-1</span>;</span><br><span class="line">left=<span class="number">0</span>;</span><br><span class="line">right=N<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">mid=(left+right)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(K&lt;A[mid])right=mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (K&gt;A[mid])left=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Nofound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/08/24/数据结构/3.jpg" alt></p><hr><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>定义：n(n&gt;=0)个结点的有限集合，n=0时，称为空树，这是一种情况。在任意一科<strong>非空树</strong>中应满足：</p><ul><li>有且仅有一个特定的称为<strong>根</strong>的结点。</li><li>其余结点可分为m(m&gt;0)个<strong>互不相交</strong>的有限集{T1,T2,….,Tm},其中每个集合本身又是一棵树，称为原来树的“子树”。</li></ul><p>树与非树？</p><ul><li>子树是不相交的；</li><li>出了根结点外，每个结点有且仅有一个父结点；</li><li>一棵N个结点的树有<strong>N-1</strong>条边。</li></ul><p>一些基本定义：</p><ul><li><strong>结点的度：</strong>结点的<strong>子树个数</strong>；</li><li><strong>树的度：</strong>树的所有结点中<strong>最大</strong>的<strong>度数</strong>；</li><li><strong>叶结点：</strong> <strong>度为0</strong>的结点；</li><li><strong>父结点：</strong>有子树的结点是其子树的根结点的父结点；</li><li><strong>子结点：</strong>子结点也称孩子结点；</li><li><strong>兄弟结点：</strong>具有同一父结点的各结点彼此是兄弟结点。</li><li><strong>路径和路径长度：</strong>从n1-&gt;nk的路径为一个<strong>结点序列</strong>，路径所包含<strong>边的个数</strong>为路径长度。</li><li><strong>祖先结点：</strong>沿<strong>树根到某一结点路径上所有结点</strong>都是这个结点的祖先结点。</li><li><strong>子孙结点：</strong>某结点的<strong>子树中所有结点</strong>都是这个结点的子孙结点。</li><li><strong>结点的层次：</strong>根节点为1层，<strong>向下累加</strong>。</li><li><strong>数的深度：</strong>树中所有结点<strong>最大层次</strong>是这棵树的深度。</li></ul><p>基本性质：</p><ul><li>树中的结点数等于所有结点的度+1；</li><li>度为<strong>m</strong>的树中第<strong>i</strong>层上至多有$m^{i-1}$个结点(i&gt;=1);</li><li>高度为h的m叉树至多有($m^h$-1)/(m-1)个结点。</li><li>具有n个结点的m叉树的最小高度为┌$log_m(n(m-1)+1)$┐</li></ul><hr><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//儿子兄弟表示法</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    ElementType Element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">firstChild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">NextSibling</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>二叉树有左右之分，5中形态(空，根，根左，根左右，根右)，其中特殊的二叉树有，<strong>满二叉树，完全二叉树(不满但是结点序号和顺序必须一致)，二叉排序树(左小右大，二分查找)，平衡二叉树(任一结点左子树和右子树深度之差不超过1)。</strong></p><p>操作集：</p></li><li><p>Boolean IsEmpty(struct tree *BT):判别BT是否为空；</p></li><li>Void Traversal(struct tree *BT):遍历，按某个顺序访问每个结点；<ul><li>void PreOrderTraversal(struct tree *BT):先序遍历—- 根，左，右；</li><li>void InOrderTraversal(struct tree *BT):中序遍历—-左，根，右；</li><li>void PostOrderTraversal(struct tree *BT):后序遍历—-左，右，根；</li><li>void LevelOrderTraversal(struct tree *BT):层次遍历，从上到下，从左到右</li></ul></li><li>struct tree CreatBinTree():创建一个二叉树。</li></ul><p><img src="/2020/08/24/数据结构/4.jpg" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表存储</span></span><br><span class="line"><span class="comment">//儿子兄弟表示法</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    ElementType Element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">Left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">Right</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="考-二叉树遍历"><a href="#考-二叉树遍历" class="headerlink" title="(考)二叉树遍历"></a>(考)二叉树遍历</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">(struct tree *BT)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BT)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,BT-&gt;Data);</span><br><span class="line">        PreOrderTraversal(BT-&gt;Left);</span><br><span class="line">        PreOrderTraversal(BT-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">(struct tree *BT)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(BT)&#123; </span><br><span class="line">        InOrderTraversal(BT-&gt;Left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,BT-&gt;Data);</span><br><span class="line">        InOrderTraversal(BT-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后续遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraversal</span><span class="params">(struct tree *BT)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BT)&#123; </span><br><span class="line">        PostOrderTraversal(BT-&gt;Left);</span><br><span class="line">        PostOrderTraversal(BT-&gt;Right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,BT-&gt;Data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历非递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal1</span><span class="params">(struct tree *BT,<span class="keyword">int</span> Maxsize)</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">T</span>=<span class="title">BT</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> *<span class="title">S</span>=<span class="title">CreatStack</span>(<span class="title">Maxsize</span>);</span><span class="comment">//创建并初始化堆栈S</span></span><br><span class="line"><span class="keyword">while</span>(T || !IsEmpty(S))&#123;</span><br><span class="line"><span class="keyword">while</span>(T)&#123;<span class="comment">//一直向左并将沿途压入堆栈</span></span><br><span class="line">Push(S,T);</span><br><span class="line">T=T-&gt;Left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!IsEmpty(S))&#123;</span><br><span class="line">T=Pop(S);<span class="comment">//结点弹出堆栈</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,T-&gt;Data);<span class="comment">//访问打印结点</span></span><br><span class="line">T=T-&gt;Right; <span class="comment">//转向右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历非递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal1</span><span class="params">(struct tree *BT,<span class="keyword">int</span> Maxsize)</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">T</span>=<span class="title">BT</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> *<span class="title">S</span>=<span class="title">CreatStack</span>(<span class="title">Maxsize</span>);</span><span class="comment">//创建并初始化堆栈S</span></span><br><span class="line"><span class="keyword">while</span>(T || !IsEmpty(S))&#123;</span><br><span class="line"><span class="keyword">while</span>(T)&#123;<span class="comment">//一直向左并将沿途压入堆栈</span></span><br><span class="line">Push(S,T);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,T-&gt;Data);<span class="comment">//访问打印结点</span></span><br><span class="line">T=T-&gt;Left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!IsEmpty(S))&#123;</span><br><span class="line">T=Pop(S);<span class="comment">//结点弹出堆栈</span></span><br><span class="line">T=T-&gt;Right; <span class="comment">//转向右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层序遍历队列实现，每次出队时入队左右儿子结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrderTraversal</span><span class="params">(struct tree *BT)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">T</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">Q</span>;</span><span class="comment">//数组</span></span><br><span class="line">    <span class="keyword">if</span>(!BT) <span class="keyword">return</span>;</span><br><span class="line">    Q = CreatQueue(MaxSize);</span><br><span class="line">    AddQ(Q,BT);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmptyQ(Q))&#123;</span><br><span class="line">        T=DeleteQ(Q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,T-&gt;Data);</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;Left) AddQ(Q,T-&gt;Left);</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;Right) AddQ(Q,T-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码测试</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElementType int</span></span><br><span class="line"><span class="comment">//儿子兄弟表示法</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line"> ElementType Data;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">Left</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">Right</span>;</span></span><br><span class="line"> &#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">data</span>;</span></span><br><span class="line"><span class="keyword">int</span> top;</span><br><span class="line"><span class="keyword">int</span> Maxsize;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct Stack* <span class="title">CreatStack</span><span class="params">(<span class="keyword">int</span> Maxsize)</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> *<span class="title">p</span>=(<span class="title">Stack</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Stack</span>));</span></span><br><span class="line">p-&gt;data=(tree*)<span class="built_in">malloc</span>(Maxsize*<span class="keyword">sizeof</span>(struct tree));</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span> || p-&gt;data==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"内存不足"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//exit(0); </span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">p-&gt;top=<span class="number">-1</span>;</span><br><span class="line">p-&gt;Maxsize=Maxsize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(struct Stack *s,struct tree *p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s-&gt;top==s-&gt;Maxsize<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"堆栈满"</span>); </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">s-&gt;data[++(s-&gt;top)]=*p; <span class="comment">//※※※※※※※重点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct tree* <span class="title">Pop</span><span class="params">(struct Stack *s)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s-&gt;top==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"堆栈空"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;(s-&gt;data[(s-&gt;top)--]);<span class="comment">//※※※※※※重点</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(struct Stack *p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;top==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">struct tree *<span class="title">add</span><span class="params">(struct tree *q,ElementType k,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">p</span>=(<span class="title">tree</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">tree</span>));</span></span><br><span class="line">p-&gt;Data=k;</span><br><span class="line">p-&gt;Left=<span class="literal">NULL</span>;</span><br><span class="line">p-&gt;Right=<span class="literal">NULL</span>;</span><br><span class="line">q-&gt;Left=p;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">struct tree *p=(tree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct tree));</span><br><span class="line">p-&gt;Data=k;</span><br><span class="line">p-&gt;Left=<span class="literal">NULL</span>;</span><br><span class="line">p-&gt;Right=<span class="literal">NULL</span>;</span><br><span class="line">q-&gt;Right=p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct tree *<span class="title">creat</span><span class="params">(ElementType k)</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">q</span>=(<span class="title">tree</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">tree</span>));</span></span><br><span class="line">q-&gt;Data=k;</span><br><span class="line">q-&gt;Left=<span class="literal">NULL</span>;</span><br><span class="line">q-&gt;Right=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">struct Stack* <span class="title">CreatStack</span><span class="params">(<span class="keyword">int</span> Maxsize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">(struct tree *BT)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">(struct tree *BT)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraversal</span><span class="params">(struct tree *BT)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal1</span><span class="params">(struct tree *BT,<span class="keyword">int</span> Maxsize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal1</span><span class="params">(struct tree *BT,<span class="keyword">int</span> Maxsize)</span></span>;</span><br><span class="line"><span class="function">struct tree *<span class="title">add</span><span class="params">(struct tree *q,ElementType k,<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function">struct tree *<span class="title">creat</span><span class="params">(ElementType k)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">q</span>,*<span class="title">w</span>,*<span class="title">root</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="comment">//p=CreatStack(10);</span></span><br><span class="line">q=creat(<span class="number">1</span>);</span><br><span class="line">q=add(q,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">q=add(q,<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">root=w=q;</span><br><span class="line">w=w-&gt;Right;</span><br><span class="line">q=q-&gt;Left; </span><br><span class="line">w=add(w,<span class="number">6</span>,<span class="number">1</span>);</span><br><span class="line">w=add(w,<span class="number">7</span>,<span class="number">2</span>);</span><br><span class="line">q=add(q,<span class="number">4</span>,<span class="number">1</span>);</span><br><span class="line">q=add(q,<span class="number">5</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"先序遍历\n"</span>); </span><br><span class="line">PreOrderTraversal(root);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n中序遍历\n"</span>);</span><br><span class="line">InOrderTraversal(root);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n后序遍历\n"</span>);</span><br><span class="line">PostOrderTraversal(root);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n中序遍历非递归算法\n"</span>);</span><br><span class="line">InOrderTraversal1(root,<span class="number">7</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n先序遍历非递归算法\n"</span>);</span><br><span class="line">PreOrderTraversal1(root,<span class="number">7</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二叉树遍历应用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出二叉树中叶子结点，先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">(struct tree *BT)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BT)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!BT-&gt;Left &amp;&amp; !BT-&gt;Right)<span class="comment">//没有二子结点</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,BT-&gt;Data);</span><br><span class="line">        PreOrderTraversal(BT-&gt;Left);</span><br><span class="line">        PreOrderTraversal(BT-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求树高度，左右子树最高高度+1</span></span><br><span class="line"><span class="comment">//使用后序遍历改</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PostOrderGetHeight</span><span class="params">(struct tree *BT)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> HL,HR,MaxH;</span><br><span class="line">    <span class="keyword">if</span>(BT)&#123; </span><br><span class="line">        HL=PreOrderGetHeight(BT-&gt;Left);<span class="comment">//左子树深度</span></span><br><span class="line">        HR=PreOrderGetHeight(BT-&gt;Right);<span class="comment">//右子树深度</span></span><br><span class="line">        MaxH=(HL&gt;HR)?HL:HR;<span class="comment">//取左右最大值</span></span><br><span class="line">        <span class="keyword">return</span> (MaxH+<span class="number">1</span>);<span class="comment">//返回树深度</span></span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二元运算表达式树及其遍历</strong></p><p><img src="/2020/08/24/数据结构/5.jpg" alt></p><p><strong>通过两种序列(必须有中序遍历)就可以确定一个唯一的二叉树</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树静态链表</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MaxTree 10</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> ElementType char</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> Tree int</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> Null -1 <span class="comment">//编译器定义Null（0）</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    ElementType Element;</span><br><span class="line">    Tree Left;</span><br><span class="line">    Tree Right;</span><br><span class="line">&#125;T1[MaxTree],T2[MaxTree];<span class="comment">//数组中没有出现的下标就是根</span></span><br></pre></td></tr></table></figure><p><img src="/2020/08/24/数据结构/6.jpg" alt></p><p><img src="/2020/08/24/数据结构/7.jpg" alt></p><p><img src="/2020/08/24/数据结构/8.jpg" alt><img src="/2020/08/24/数据结构/9.jpg" alt></p><hr><h5 id="考-二叉搜索树-查找树-排序树"><a href="#考-二叉搜索树-查找树-排序树" class="headerlink" title="(考)二叉搜索树/查找树/排序树"></a>(考)二叉搜索树/查找树/排序树</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(ElementType X,struct tree *BST)</span></span>;<span class="comment">//从二叉排序树BST中查找元素X，返回其所在结点的地址；</span></span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">(struct tree *BST)</span></span>;<span class="comment">//找出最小元素所在结点地址</span></span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">(struct tree *BST)</span></span>;</span><br><span class="line"><span class="function">struct tree <span class="title">Insert</span><span class="params">(ElementType X,struct tree *BST)</span></span>;</span><br><span class="line"><span class="function">struct tree <span class="title">Delete</span><span class="params">(ElementType X,struct tree *BST)</span></span>;</span><br></pre></td></tr></table></figure><p>插入操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct tree* <span class="title">Insert</span><span class="params">(ElementType k,struct tree *BST)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!BST)&#123;</span><br><span class="line"><span class="comment">//若原树为空，则生成一个结点得二叉排序树 </span></span><br><span class="line">BST=(tree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct tree));<span class="comment">////!!!!!!!!!!!!!!!!!!!!!!!!!不用结构体声明，直接申请，指针已经传进来了 </span></span><br><span class="line">BST-&gt;data=k;</span><br><span class="line">BST-&gt;Left=BST-&gt;Right=<span class="literal">NULL</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;<span class="comment">//找插入元素得位置 </span></span><br><span class="line"><span class="keyword">if</span>(k&lt;BST-&gt;data)&#123;</span><br><span class="line">BST-&gt;Left=Insert(k,BST-&gt;Left);<span class="comment">//递归插入左子树 </span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(k&gt;BST-&gt;data)&#123;</span><br><span class="line">BST-&gt;Right=Insert(k,BST-&gt;Right);<span class="comment">//递归插入右子树 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//else k已经存在，什么都不做 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> BST; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>删除操作</strong></p><ul><li>当为叶子结点直接删除</li><li>当删除结点只有一个儿子，用儿子代替</li><li>当左右都有儿子结点都有二子结点时<ul><li>右子树最小元素代替</li><li>左子树的最大元素</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若为叶子结点直接删除</span></span><br><span class="line"><span class="comment">//若只有一个孩子结点则用孩子结点代替自己</span></span><br><span class="line"><span class="comment">//若 左右都有儿子结点且都有孙子结点</span></span><br><span class="line"><span class="comment">//用右子树最小元素 或左子树最大元素代替 </span></span><br><span class="line"><span class="function">struct tree* <span class="title">Delete</span><span class="params">(ElementType k,struct tree *BST)</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">Tmp</span>;</span></span><br><span class="line"><span class="keyword">if</span>(!BST)<span class="built_in">printf</span>(<span class="string">"要删除的结点不存在"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k&lt;BST-&gt;data)</span><br><span class="line">BST-&gt;Left=Delete(k,BST-&gt;Left);<span class="comment">//左子树递归查找要删除的结点 </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k&gt;BST-&gt;data)</span><br><span class="line">BST-&gt;Right=Delete(k,BST-&gt;Right);<span class="comment">//右子树递归查找要删除的结点 </span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">//找到要删除的结点 </span></span><br><span class="line"><span class="keyword">if</span>(BST-&gt;Left &amp;&amp; BST-&gt;Right)&#123;</span><br><span class="line">Tmp=FindMin(BST-&gt;Right);<span class="comment">//右子树最小结点 </span></span><br><span class="line"><span class="comment">//Tmp=FindMax(BST-&gt;Left);//左子树最大结点 </span></span><br><span class="line"></span><br><span class="line">BST-&gt;data=Tmp-&gt;data;</span><br><span class="line">BST-&gt;Right=Delete(BST-&gt;data,BST-&gt;Right);<span class="comment">//删除右子树中最小元素 </span></span><br><span class="line"><span class="comment">//BST-&gt;Left=Delete(BST-&gt;data,BST-&gt;Left);</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">Tmp=BST;</span><br><span class="line"><span class="keyword">if</span>(!BST-&gt;Left)<span class="comment">//没有左节点，将右节点当自己 </span></span><br><span class="line">BST=BST-&gt;Right;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!BST-&gt;Right)<span class="comment">//没有右节点，将左结点当自己 </span></span><br><span class="line">BST=BST-&gt;Left;</span><br><span class="line"><span class="comment">//两个都没有直接释放自己 此时BST=NULL; </span></span><br><span class="line"><span class="built_in">free</span>(Tmp);<span class="comment">//释放这个结点 释放的是结构体的空间，并不是指针变量，指针变量是临时的，用完就没了 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> BST;<span class="comment">//返回的是当前结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElementType int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//左小右大树 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">ElementType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">Left</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">Right</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct tree* <span class="title">FindMin</span><span class="params">(struct tree *BST)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(BST-&gt;Left)&#123;</span><br><span class="line">FindMin(BST-&gt;Left);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">struct tree* <span class="title">FindMax</span><span class="params">(struct tree *BST)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(BST-&gt;Right)&#123;</span><br><span class="line">FindMax(BST-&gt;Right);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">(struct tree *BT)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(BT)&#123; </span><br><span class="line">        InOrderTraversal(BT-&gt;Left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,BT-&gt;data);</span><br><span class="line">        InOrderTraversal(BT-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">(struct tree *BT)</span></span>;</span><br><span class="line"><span class="function">struct tree* <span class="title">FindMin</span><span class="params">(struct tree *BST)</span></span>;</span><br><span class="line"><span class="function">struct tree* <span class="title">FindMax</span><span class="params">(struct tree *BST)</span></span>;</span><br><span class="line"><span class="function">struct tree* <span class="title">Insert</span><span class="params">(ElementType k,struct tree *BST)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">p</span>=<span class="title">NULL</span>,*<span class="title">w</span>,*<span class="title">q</span>;</span></span><br><span class="line">p=Insert(<span class="number">6</span>,p);</span><br><span class="line">p=Insert(<span class="number">2</span>,p);</span><br><span class="line">p=Insert(<span class="number">1</span>,p);</span><br><span class="line">p=Insert(<span class="number">3</span>,p);</span><br><span class="line">p=Insert(<span class="number">7</span>,p);</span><br><span class="line">p=Insert(<span class="number">9</span>,p);</span><br><span class="line">w=FindMin(p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"最小值%d\n"</span>,w-&gt;data);</span><br><span class="line">q=FindMax(p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"最大值%d\n"</span>,q-&gt;data);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"中序遍历\n"</span>);</span><br><span class="line">InOrderTraversal(p);</span><br><span class="line">p=Delete(<span class="number">2</span>,p); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">InOrderTraversal(p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h5><ul><li>任一结点左子树和右子树深度之差不超过1</li><li>搜索树结点不同插入次序，将导致不同的<strong>深度</strong>和平均查找长度<strong>ASL</strong></li><li>斐波那契数列(1,1,2,3,5,….)，nh=n(h-1)+n(h-2)+1 =》给定结点数为n的平衡二叉树（AVL）最大高度为<strong>h=O(log2n)</strong>.</li></ul><p>调整：</p><ul><li>RR旋转</li></ul><p><img src="/2020/08/24/数据结构/12.jpg" alt></p><ul><li>LL旋转</li></ul><p><img src="/2020/08/24/数据结构/13.jpg" alt></p><ul><li>LR旋转</li></ul><p><img src="/2020/08/24/数据结构/14.jpg" alt></p><hr><h5 id="考-线索二叉树"><a href="#考-线索二叉树" class="headerlink" title="(考)线索二叉树"></a>(考)线索二叉树</h5><p>线索化</p><ul><li>若无左子树，则将左指针指向其前驱结点；</li><li>若无右子树，则将右指针指向其后继结点。</li></ul><p>前驱结点</p><ul><li>若左指针为线索，则其指向结点为前驱结点；</li><li>若左指针为左孩子，则其左子树的最右侧结点为前驱结点。</li></ul><p>后继结点</p><ul><li>若右指针为线索，则其指向结点为后继结点；</li><li>若右指针为右孩子，则其右子树的最左侧结点为后继结点。</li></ul><p><img src="/2020/08/24/数据结构/32.jpg" alt></p><p>中序线索二叉树，将<strong>中序序列</strong>中对应的结点结构中空指针设置<strong>前驱</strong>和<strong>后继</strong>，并设置头节点，指向<strong>根</strong>和<strong>尾结点</strong>，而<strong>左子树最后一个元素的前驱</strong>和<strong>右子树的尾结点元素的后继</strong>指向头节点。称为线索链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElementType int</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">ElementType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">Left</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">Right</span>;</span></span><br><span class="line"><span class="keyword">int</span> Ltag;<span class="comment">//0代表左孩子,1代表前驱 </span></span><br><span class="line"><span class="keyword">int</span> Rtag; <span class="comment">//0代表右孩子,1代表后继 </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//中序线索二叉树线索化 </span></span><br><span class="line"><span class="comment">//&amp;引用结构体得到的只是一个对象，不能当指针用，需要加*标记为指针才可以使用 ！！！！！！！！！！ </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThread</span><span class="params">(struct ThreadNode *&amp;p,struct ThreadNode *&amp;pre)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">InThread(p-&gt;Left,pre);<span class="comment">//递归左孩子</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//对叶子节点的左孩子制作线索，线索为前驱结点 </span></span><br><span class="line"><span class="keyword">if</span>(p-&gt;Left==<span class="literal">NULL</span>)&#123;</span><br><span class="line">p-&gt;Left=pre;</span><br><span class="line">p-&gt;Ltag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从第二个结点开始前驱结点的右孩子如果空则将其线索指向当前结点 </span></span><br><span class="line"><span class="keyword">if</span>(pre!=<span class="literal">NULL</span> &amp;&amp; pre-&gt;Right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">pre-&gt;Right=p;</span><br><span class="line">pre-&gt;Rtag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pre=p;<span class="comment">//将前驱结点置为当前结点 </span></span><br><span class="line"></span><br><span class="line">InThread(p-&gt;Right,pre);<span class="comment">//递归右孩子 </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化和收尾工作，传入第一个NULL为前驱，</span></span><br><span class="line"><span class="comment">将最后一个结点右孩子后继设置为NULL，也可以设置一个头节点，</span></span><br><span class="line"><span class="comment">将第一个结点的左孩子和最后一个结点的右孩子指向头节点，</span></span><br><span class="line"><span class="comment">头节点中左孩子和右孩子指向根节点和最后一个结点*/</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createThread</span><span class="params">(struct ThreadNode *p)</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">pre</span>=<span class="title">NULL</span>;</span></span><br><span class="line"><span class="keyword">if</span> (p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">InThread(p,pre);</span><br><span class="line">pre-&gt;Right=<span class="literal">NULL</span>;</span><br><span class="line">pre-&gt;Rtag=<span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//线索二叉树的遍历</span></span><br><span class="line"> <span class="function">struct ThreadNode *<span class="title">Firstnode</span><span class="params">(struct ThreadNode *p)</span></span>&#123;</span><br><span class="line"> <span class="keyword">while</span>(p-&gt;Ltag==<span class="number">0</span>)</span><br><span class="line"> p=p-&gt;Left;</span><br><span class="line"> <span class="keyword">return</span> p;</span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="function">struct ThreadNode *<span class="title">Nextnode</span><span class="params">(struct ThreadNode *p)</span></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(p-&gt;Rtag==<span class="number">0</span>)</span><br><span class="line"> <span class="keyword">return</span> Firstnode(p-&gt;Right);</span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line"> <span class="keyword">return</span> p-&gt;Right;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//遍历主函数</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">(struct ThreadNode *T)</span></span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(struct ThreadNode *p=Firstnode(T);p!=<span class="literal">NULL</span>;p=Nextnode(p))</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%d"</span>,p-&gt;data);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">struct ThreadNode* <span class="title">Insert</span><span class="params">(ElementType k,struct ThreadNode *BST)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!BST)&#123;</span><br><span class="line"><span class="comment">//若原树为空，则生成一个结点得二叉排序树 </span></span><br><span class="line">BST=(ThreadNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ThreadNode));<span class="comment">////!!!!!!!!!!!!!!!!!!!!!!!!!不用结构体声明，直接申请，指针已经传进来了 </span></span><br><span class="line">BST-&gt;data=k;</span><br><span class="line">BST-&gt;Ltag=BST-&gt;Rtag=<span class="number">0</span>;</span><br><span class="line">BST-&gt;Left=BST-&gt;Right=<span class="literal">NULL</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;<span class="comment">//找插入元素得位置 </span></span><br><span class="line"><span class="keyword">if</span>(k&lt;BST-&gt;data)&#123;</span><br><span class="line">BST-&gt;Left=Insert(k,BST-&gt;Left);<span class="comment">//递归插入左子树 </span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(k&gt;BST-&gt;data)&#123;</span><br><span class="line">BST-&gt;Right=Insert(k,BST-&gt;Right);<span class="comment">//递归插入右子树 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//else k已经存在，什么都不做 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> BST; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序线索二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">struct ThreadNode* <span class="title">Insert</span><span class="params">(ElementType k,struct ThreadNode *BST)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createThread</span><span class="params">(struct ThreadNode *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">(struct ThreadNode *T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">(struct ThreadNode *BT)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">p</span>=<span class="title">NULL</span>;</span></span><br><span class="line">p=Insert(<span class="number">6</span>,p);</span><br><span class="line">p=Insert(<span class="number">2</span>,p);</span><br><span class="line">p=Insert(<span class="number">1</span>,p);</span><br><span class="line">p=Insert(<span class="number">3</span>,p);</span><br><span class="line">p=Insert(<span class="number">7</span>,p);</span><br><span class="line">p=Insert(<span class="number">9</span>,p);</span><br><span class="line">createThread(p);</span><br><span class="line">Inorder(p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="完全二叉搜索树"><a href="#完全二叉搜索树" class="headerlink" title="完全二叉搜索树"></a>完全二叉搜索树</h5><p>完全二叉搜索树=二叉搜索树+完全二叉树</p><p>特点：不浪费空间，使用数组更加方便，使用层序遍历==直接输出</p><p>算法思想:首先从小到大排序，找根节点，分为左右子树，再递归将左右子树分别填入</p><hr><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p><strong>优先队列：</strong>特殊的“<strong>队列</strong>”，取出元素的顺序是依照元素的<strong>优先权（关键字）</strong>大小，而不是元素进入队列的先后顺序。</p><p><img src="/2020/08/24/数据结构/15.jpg" alt></p><p>基本结构体及构建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span>&#123;</span></span><br><span class="line">ElementType *data;<span class="comment">//储存堆元素的数组</span></span><br><span class="line"><span class="keyword">int</span> Size;<span class="comment">//堆当前元素的个数 </span></span><br><span class="line"><span class="keyword">int</span> Capacity; <span class="comment">//堆的最大容量 </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="function">struct HeapStruct* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> Maxsize)</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span> *<span class="title">p</span>=(<span class="title">HeapStruct</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">HeapStruct</span>));</span></span><br><span class="line">p-&gt;data=(ElementType*)<span class="built_in">malloc</span>((Maxsize+<span class="number">1</span>) * <span class="keyword">sizeof</span>(ElementType));<span class="comment">//从1开始存 </span></span><br><span class="line">p-&gt;Size=<span class="number">0</span>;</span><br><span class="line">p-&gt;Capacity=Maxsize;</span><br><span class="line">p-&gt;data[<span class="number">0</span>]=Maxdata;</span><br><span class="line"><span class="comment">//定义哨兵，大于堆中所有可能元素的值，便于以后更快操作；</span></span><br><span class="line"><span class="keyword">return</span> p; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆的插入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*保证插入后仍然是完全二叉树，且每个结点都是其子树所有结点的最大值 </span></span><br><span class="line"><span class="comment">1.按顺序插入到最后一个位置</span></span><br><span class="line"><span class="comment">2.调整整个树使其称为最大堆 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(struct HeapStruct *p,ElementType k)</span></span>&#123;</span><br><span class="line"><span class="comment">//将元素k插入最大堆p，其中p-&gt;data[0]已经定义为哨兵 </span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">if</span>(IsFull(p))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"最大堆已满"</span>);</span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br><span class="line">i=++p-&gt;Size;<span class="comment">//i指向插入堆中的最后一个元素的位置 </span></span><br><span class="line"><span class="keyword">for</span>(;p-&gt;data[i/<span class="number">2</span>]&lt;k;i/=<span class="number">2</span>)<span class="comment">//如果不加哨兵，需要增加 &amp;&amp; i&gt;1  </span></span><br><span class="line">p-&gt;data[i]=p-&gt;data[i/<span class="number">2</span>];<span class="comment">//向下过滤结点i/2是父节点位置 </span></span><br><span class="line">p-&gt;data[i]=k; <span class="comment">//将k插入 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆的删除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*删除最大元素或某个元素用最后一个元素代替当前位置，</span></span><br><span class="line"><span class="comment">并调整堆为最大堆，向下比较，并交换位置 */</span></span><br><span class="line"><span class="function">ElementType <span class="title">DeleteMax</span><span class="params">(struct HeapStruct *p)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> parent,Child;</span><br><span class="line">ElementType Max,temp;</span><br><span class="line"><span class="keyword">if</span>(IsEmpty(p))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"最大堆已空"</span>);</span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line">&#125; </span><br><span class="line">Max=p-&gt;data[<span class="number">1</span>];<span class="comment">//取出树根结点最大值；</span></span><br><span class="line"><span class="comment">/*用最大堆中最后一个元素从根节点开始向上过滤下层结点*/</span></span><br><span class="line">temp=p-&gt;data[p-&gt;Size--];<span class="comment">//取出最后一个元素并且将整体Size减一 </span></span><br><span class="line"><span class="keyword">for</span>(Parent=<span class="number">1</span>;Parent*<span class="number">2</span>&lt;=p-&gt;Size;Parent=Child);&#123;<span class="comment">//第三个函数在每一轮结束后执行 </span></span><br><span class="line">Child=Parent*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>((Child!=p-&gt;Size) &amp;&amp; (p-&gt;data[Child]&lt;p-&gt;data[Child+<span class="number">1</span>]))</span><br><span class="line">Child++;<span class="comment">//Child 指向左右子结点较大者</span></span><br><span class="line"><span class="keyword">if</span>(temp&gt;=p-&gt;data[Child])<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> p-&gt;data[Parent]=p-&gt;data[Child]; </span><br><span class="line">&#125;</span><br><span class="line">p-&gt;data[Parent]=temp;</span><br><span class="line"><span class="keyword">return</span> Max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最小堆</span></span><br><span class="line"><span class="function">ElementType <span class="title">DeleteMin</span><span class="params">(struct HeapStruct *p)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> Parent,Child;</span><br><span class="line">ElementType Min,temp;</span><br><span class="line"><span class="keyword">if</span>(IsEmpty(p))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"最小堆已空"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line">Min=p-&gt;data[<span class="number">1</span>];<span class="comment">//取出树根结点最小值；</span></span><br><span class="line"><span class="comment">/*用最小堆中最后一个元素从根节点开始向上过滤下层结点*/</span></span><br><span class="line">temp=p-&gt;data[p-&gt;Size--];<span class="comment">//取出最后一个元素并且将整体Size减一 </span></span><br><span class="line"><span class="keyword">for</span>(Parent=<span class="number">1</span>;Parent*<span class="number">2</span>&lt;=p-&gt;Size;Parent=Child)&#123;<span class="comment">//第三个函数在每一轮结束后执行 </span></span><br><span class="line">Child=Parent*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>((Child!=p-&gt;Size) &amp;&amp; (p-&gt;data[Child]&gt;p-&gt;data[Child+<span class="number">1</span>]))</span><br><span class="line">Child++;<span class="comment">//Child 指向左右子结点较小者</span></span><br><span class="line"><span class="keyword">if</span>(temp&lt;=p-&gt;data[Child])<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> p-&gt;data[Parent]=p-&gt;data[Child]; </span><br><span class="line">&#125;</span><br><span class="line">p-&gt;data[Parent]=temp;</span><br><span class="line"><span class="keyword">return</span> Min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如何建立一个堆？<ul><li>一个一个的插入(效率低)</li><li>在<strong>线性时间复杂度</strong>下建立最大堆。<ul><li>将N个元素按输入顺序存入，先满足<strong>完全二叉树的结构性</strong>；</li><li>调整各结点位置，以满足最大堆的<strong>有序特性。</strong></li></ul></li></ul></li><li>思路：从倒数第一个有儿子的父结点(size/2)开始一个一个调整(删除结点的思路)为堆</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调整为最大堆</span></span><br><span class="line"><span class="function">struct HeapStruct* <span class="title">CreatMaxHeap</span><span class="params">(struct HeapStruct *p)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> Parent,Child,Parent1,Child1;</span><br><span class="line">ElementType temp;</span><br><span class="line"><span class="keyword">if</span>(IsEmpty(p))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"最大堆已空"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*用最后一个元素从倒数第一个父结点开始自下向上过滤结点*/</span></span><br><span class="line"><span class="keyword">for</span>(Parent=p-&gt;Size/<span class="number">2</span>;Parent&gt;=<span class="number">1</span>;Parent--)&#123;<span class="comment">//从倒数第一个父结点开始依次递减 ， </span></span><br><span class="line">Child=Parent*<span class="number">2</span>;</span><br><span class="line">Parent1=Parent;</span><br><span class="line">Child1=Child;</span><br><span class="line"><span class="keyword">for</span>(;Parent1*<span class="number">2</span>&lt;=p-&gt;Size;Parent1=Child1)&#123;</span><br><span class="line">Child1=Parent1*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>((Parent1*<span class="number">2</span>!=p-&gt;Size)&amp;&amp;(p-&gt;data[Child1]&lt;p-&gt;data[Child1+<span class="number">1</span>]))</span><br><span class="line">Child1++;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;data[Child1]&gt;p-&gt;data[Parent1])&#123;</span><br><span class="line">temp=p-&gt;data[Parent1];</span><br><span class="line">p-&gt;data[Parent1]=p-&gt;data[Child1];</span><br><span class="line">p-&gt;data[Child1]=temp; </span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//调整为最小堆</span></span><br><span class="line"><span class="function">struct HeapStruct* <span class="title">CreatMinHeap</span><span class="params">(struct HeapStruct *p)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> Parent,Child,Parent1,Child1;</span><br><span class="line">ElementType temp;</span><br><span class="line"><span class="keyword">if</span>(IsEmpty(p))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"最小堆已空"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*用最后一个元素从倒数第一个父结点开始自下向上过滤结点*/</span></span><br><span class="line"><span class="keyword">for</span>(Parent=p-&gt;Size/<span class="number">2</span>;Parent&gt;=<span class="number">1</span>;Parent--)&#123;<span class="comment">//从倒数第一个父结点开始依次递减 ， </span></span><br><span class="line">Child=Parent*<span class="number">2</span>;</span><br><span class="line">Parent1=Parent;</span><br><span class="line">Child1=Child;</span><br><span class="line"><span class="keyword">for</span>(;Parent1*<span class="number">2</span>&lt;=p-&gt;Size;Parent1=Child1)&#123;</span><br><span class="line">Child1=Parent1*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>((Parent1*<span class="number">2</span>!=p-&gt;Size)&amp;&amp;(p-&gt;data[Child1]&gt;p-&gt;data[Child1+<span class="number">1</span>]))</span><br><span class="line">Child1++;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;data[Child1]&lt;p-&gt;data[Parent1])&#123;</span><br><span class="line">temp=p-&gt;data[Parent1];</span><br><span class="line">p-&gt;data[Parent1]=p-&gt;data[Child1];</span><br><span class="line">p-&gt;data[Child1]=temp; </span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsFull</span><span class="params">(struct HeapStruct *p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;Capacity==p-&gt;Size)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(struct HeapStruct *p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;Size==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">struct HeapStruct* <span class="title">CreatHeap</span><span class="params">(struct HeapStruct *p)</span></span>;</span><br><span class="line"><span class="function">ElementType <span class="title">DeleteMax</span><span class="params">(struct HeapStruct *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(struct HeapStruct *p,ElementType k)</span></span>;</span><br><span class="line"><span class="function">struct HeapStruct* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> Maxsize)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span> *<span class="title">p</span>=<span class="title">Create</span>(12);</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="comment">//Insert1(p,83);</span></span><br><span class="line"><span class="comment">//Insert1(p,87);</span></span><br><span class="line"><span class="comment">//Insert1(p,43);</span></span><br><span class="line"><span class="comment">//Insert1(p,72);</span></span><br><span class="line"><span class="comment">//Insert1(p,91);</span></span><br><span class="line"><span class="comment">//for(int i=1;i&lt;6;i++)printf("%d",p-&gt;data[i]);</span></span><br><span class="line"><span class="comment">//int a=DeleteMax(p);</span></span><br><span class="line"><span class="comment">//int b=DeleteMin(p);</span></span><br><span class="line"><span class="comment">//printf("\n");</span></span><br><span class="line"><span class="comment">//for(int i=1;i&lt;5;i++)printf("%d",p-&gt;data[i]);</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">13</span>;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">p-&gt;data[i]=a;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;Size=<span class="number">12</span>;</span><br><span class="line">p=CreatMinHeap(p); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">13</span>;j++)<span class="built_in">printf</span>(<span class="string">"%d "</span>,p-&gt;data[j]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">a=DeleteMin(p);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">12</span>;j++)<span class="built_in">printf</span>(<span class="string">"%d "</span>,p-&gt;data[j]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="哈夫曼树和编码"><a href="#哈夫曼树和编码" class="headerlink" title="哈夫曼树和编码"></a>哈夫曼树和编码</h4><h5 id="考-哈夫曼树"><a href="#考-哈夫曼树" class="headerlink" title="(考)哈夫曼树"></a>(考)哈夫曼树</h5><p>定义：<strong>带权路径长度(WPL)：</strong>设二叉树有<strong>n个叶子结点</strong>，每个叶子结点带有权值$W<em>k$,从根结点到每个叶子结点的长度为$L_k$,则每个叶子结点的带权路径长度之和就是：$WPL=\sum</em>{k=1}^nW_kL_k$</p><p><strong>最优二叉树</strong>或<strong>哈夫曼树</strong>：<strong>WPL</strong>最小的二叉树。</p><p>哈夫曼树构造：</p><ul><li>由一段<strong>有序序列</strong>（可以用<strong>堆</strong>实现，效率更高<strong>O(NlogN</strong>)）中挑选<strong>最小的两个合并为一棵树</strong>后将权值重新加入排序，重复上述过程直到创建树成功.</li></ul><p>哈夫曼树特点：</p><ul><li>没有度为<strong>1</strong>的结点</li><li><strong>n</strong>个叶子结点的哈夫曼树共有<strong>2n-1</strong>个结点；</li><li>哈夫曼树的任意非叶子结点的<strong>左右子树交换后</strong>仍是哈夫曼树；</li><li>对同一组权值<strong>{$w_1,w_2,…,w_n$},</strong>存在<strong>不同构</strong>的哈夫曼树，但<strong>WPL</strong>值相同。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElementType int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mindata 0; </span></span><br><span class="line"><span class="comment">//数据结构部分</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">ElementType data;<span class="comment">//数据 </span></span><br><span class="line"><span class="keyword">int</span> Weight;<span class="comment">//权重 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">Left</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">Right</span>;</span> </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">data</span>;</span><span class="comment">//储存堆元素的数组</span></span><br><span class="line"><span class="keyword">int</span> Size;<span class="comment">//堆当前元素的个数 </span></span><br><span class="line"><span class="keyword">int</span> Capacity; <span class="comment">//堆的最大容量 </span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsFull</span><span class="params">(struct HeapStruct *p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;Capacity==p-&gt;Size)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(struct HeapStruct *p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;Size==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个堆</span></span><br><span class="line"><span class="function">struct HeapStruct* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> Maxsize)</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span> *<span class="title">p</span>=(<span class="title">HeapStruct</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">HeapStruct</span>));</span></span><br><span class="line">p-&gt;data=(tree*)<span class="built_in">malloc</span>((Maxsize+<span class="number">1</span>)*<span class="keyword">sizeof</span>(struct tree));<span class="comment">//从1开始存 </span></span><br><span class="line">p-&gt;Size=<span class="number">0</span>;</span><br><span class="line">p-&gt;Capacity=Maxsize;</span><br><span class="line">p-&gt;data[<span class="number">0</span>].data= Mindata;<span class="comment">//结构体中嵌套结构体是对象，并不是指针</span></span><br><span class="line">p-&gt;data[<span class="number">0</span>].Weight=Mindata;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Maxsize;i++)&#123;</span><br><span class="line">p-&gt;data[i].Left=<span class="literal">NULL</span>;<span class="comment">//树的左右指针要置空，否则最后遍历无法运行</span></span><br><span class="line">p-&gt;data[i].Right=<span class="literal">NULL</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//定义哨兵，大于堆中所有可能元素的值，便于以后更快操作；</span></span><br><span class="line"><span class="keyword">return</span> p; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//将一个结构体插入最小堆</span></span><br><span class="line"><span class="comment">//将结构体插入最小堆 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertMin</span><span class="params">(struct HeapStruct *p,struct tree q)</span></span>&#123;</span><br><span class="line"><span class="comment">//将元素k插入最小堆p，其中p-&gt;data[0]已经定义为哨兵 </span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">if</span>(IsFull(p))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"最小堆已满"</span>);</span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br><span class="line">i=++p-&gt;Size;<span class="comment">//i指向插入堆中的最后一个元素的位置 </span></span><br><span class="line"><span class="keyword">for</span>(;p-&gt;data[i/<span class="number">2</span>].Weight&gt;q.Weight;i/=<span class="number">2</span>)<span class="comment">//如果不加哨兵，需要增加 &amp;&amp; i&gt;1  </span></span><br><span class="line">p-&gt;data[i]=p-&gt;data[i/<span class="number">2</span>];<span class="comment">//向下过滤结点i/2是父节点位置 </span></span><br><span class="line">p-&gt;data[i]=q; <span class="comment">//将q插入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除最小元素</span></span><br><span class="line"><span class="function">struct tree <span class="title">DeleteMin</span><span class="params">(struct HeapStruct *p)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> Parent,Child;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> <span class="title">Min</span>,<span class="title">temp</span>;</span></span><br><span class="line"><span class="keyword">if</span>(IsEmpty(p))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"最小堆已空"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">Min=p-&gt;data[<span class="number">1</span>];<span class="comment">//取出树根结点最小值；</span></span><br><span class="line"><span class="comment">/*用最大堆中最后一个元素从根节点开始向上过滤下层结点*/</span></span><br><span class="line">temp=p-&gt;data[p-&gt;Size--];<span class="comment">//取出最后一个元素并且将整体Size减一 </span></span><br><span class="line"><span class="keyword">for</span>(Parent=<span class="number">1</span>;Parent*<span class="number">2</span>&lt;=p-&gt;Size;Parent=Child)&#123;<span class="comment">//第三个函数在每一轮结束后执行 </span></span><br><span class="line">Child=Parent*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>((Child!=p-&gt;Size) &amp;&amp; (p-&gt;data[Child].Weight&gt;p-&gt;data[Child+<span class="number">1</span>].Weight))</span><br><span class="line">Child++;<span class="comment">//Child 指向左右子结点较大者</span></span><br><span class="line"><span class="keyword">if</span>(temp.Weight&lt;=p-&gt;data[Child].Weight)<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> p-&gt;data[Parent]=p-&gt;data[Child]; </span><br><span class="line">&#125;</span><br><span class="line">p-&gt;data[Parent]=temp;</span><br><span class="line"><span class="keyword">return</span> Min;<span class="comment">//返回的是一个结构体变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调整一个堆为最小堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatMinHeap</span><span class="params">(struct HeapStruct *&amp;p)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> Parent,Child,Parent1,Child1;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> <span class="title">temp</span>;</span></span><br><span class="line"><span class="keyword">if</span>(IsEmpty(p))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"最小堆已空"</span>);</span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*用最后一个元素从倒数第一个父结点开始自下向上过滤结点*/</span></span><br><span class="line"><span class="keyword">for</span>(Parent=p-&gt;Size/<span class="number">2</span>;Parent&gt;=<span class="number">1</span>;Parent--)&#123;<span class="comment">//从倒数第一个父结点开始依次递减 ， </span></span><br><span class="line">Child=Parent*<span class="number">2</span>;</span><br><span class="line">Parent1=Parent;</span><br><span class="line">Child1=Child;</span><br><span class="line"><span class="keyword">for</span>(;Parent1*<span class="number">2</span>&lt;=p-&gt;Size;Parent1=Child1)&#123;</span><br><span class="line">Child1=Parent1*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>((Parent1*<span class="number">2</span>!=p-&gt;Size)&amp;&amp;(p-&gt;data[Child1].Weight&gt;p-&gt;data[Child1+<span class="number">1</span>].Weight))</span><br><span class="line">Child1++;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;data[Child1].Weight&lt;p-&gt;data[Parent1].Weight)&#123;</span><br><span class="line">temp=p-&gt;data[Parent1];</span><br><span class="line">p-&gt;data[Parent1]=p-&gt;data[Child1];</span><br><span class="line">p-&gt;data[Child1]=temp; </span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//哈夫曼树  </span></span><br><span class="line"><span class="function">struct tree* <span class="title">Huffmantree</span><span class="params">(struct HeapStruct *&amp;p)</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">T</span>;</span></span><br><span class="line">CreatMinHeap(p);<span class="comment">//调整堆</span></span><br><span class="line"><span class="keyword">while</span>(p-&gt;Size&gt;<span class="number">1</span>)&#123;<span class="comment">//做p-&gt;size -1 次合并</span></span><br><span class="line">T=(tree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct tree));<span class="comment">//建立新的结点</span></span><br><span class="line">T-&gt;Left=(tree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct tree));<span class="comment">//没有申请空间不能使用 </span></span><br><span class="line">T-&gt;Right=(tree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct tree));</span><br><span class="line">*T-&gt;Left=DeleteMin(p);<span class="comment">//将从堆中删除的结构体置入新T的左子结点</span></span><br><span class="line">*T-&gt;Right=DeleteMin(p);<span class="comment">//将从堆中删除的结构体置入新T的右子结点</span></span><br><span class="line"></span><br><span class="line">T-&gt;Weight=T-&gt;Left-&gt;Weight+T-&gt;Right-&gt;Weight;<span class="comment">//合并左右子结点权重</span></span><br><span class="line">InsertMin(p,*T);<span class="comment">//将T插入到堆中重新排序</span></span><br><span class="line">&#125;</span><br><span class="line">*T=DeleteMin(p);<span class="comment">//最后一个结点就是根节点，直接弹出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> T; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//一定要和函数对应上TAT 特别是改了以后</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">(struct tree *BT)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">(struct tree *BT)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatMinHeap</span><span class="params">(struct HeapStruct *&amp;p)</span></span>;</span><br><span class="line"><span class="function">struct tree* <span class="title">Huffmantree</span><span class="params">(struct HeapStruct *&amp;p)</span></span>;</span><br><span class="line"><span class="function">struct tree <span class="title">DeleteMin</span><span class="params">(struct HeapStruct *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertMin</span><span class="params">(struct HeapStruct *p,struct tree q)</span></span>;</span><br><span class="line"><span class="function">struct HeapStruct* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> Maxsize)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span> *<span class="title">pp</span>;</span></span><br><span class="line">    pp=Create(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;pp-&gt;data[i].Weight);</span><br><span class="line">&#125;</span><br><span class="line">    pp-&gt;Size=<span class="number">6</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,pp-&gt;data[i].Weight);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    w=Huffmantree(pp);</span><br><span class="line">    PreOrderTraversal(w);<span class="comment">//先序遍历</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">InOrderTraversal(w);<span class="comment">//中序遍历</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h5><p>Q:给定一段字符串，如何对字符进行编码，可以使该字符串的编码存储空间最少？</p><ul><li>按照<strong>频率</strong>给定<strong>权值</strong></li></ul><p>Q:如何避免二义性？</p><ul><li><strong>前缀码：任何字符的编码都不是另一字符编码的前缀</strong></li></ul><p>用二叉树进行编码：</p><ul><li><strong>左右分支：0、1</strong></li><li>字符只在<strong>叶结点</strong>上</li></ul><p><img src="/2020/08/24/数据结构/16.jpg" alt></p><hr><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><ul><li>表示<strong>多对多</strong>的关系</li><li>包含<ul><li>一组顶点：通常用 <strong>V(Vertex)</strong> 表示顶点集合</li><li>一组边：通常用 <strong>E(Edge)</strong> 表示边的集合<ul><li>边是顶点对：<strong>(v,w) ∈ E</strong>，其中 <strong>v,w ∈ V</strong></li><li>有向边 <strong><v,w></v,w></strong> 表示从 <strong>v</strong> 指向 <strong>w</strong> 的边(单行线)</li><li>不考虑重边和自回路</li></ul></li></ul></li></ul><h4 id="图的表示法"><a href="#图的表示法" class="headerlink" title="图的表示法"></a>图的表示法</h4><h5 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h5><p><img src="/2020/08/24/数据结构/17.jpg" alt></p><p>Q:对于无向图的存储，怎样可以省一半的空间？</p><ul><li>用一个长度为N/(N+1)/2 的1 维数组 A 存储{$G<em>{00},G</em>{10},G<em>{11},G</em>{20},G<em>{21},…,G</em>{n-1, 0}，…，G<em>{n-1,n-1}$},则$G</em>{i,j}$在A中对应的下标为：$(i*(i+1)/2+j)$</li><li>对于网络，只要把$G[i][j]$的值定义为边&lt;$v_i,v_j$&gt;的权重即可。</li></ul><p><img src="/2020/08/24/数据结构/18.jpg" alt></p><p>对于稀疏图浪费空间(稠密图还是很合算)，也浪费时间。</p><h5 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h5><p><img src="/2020/08/24/数据结构/19.jpg" alt></p><ul><li>方便找任一顶点的所有“邻接点”</li><li>节约稀疏图的空间<ul><li>需要N个头指针 + 2E 个结点（每个结点至少2个域）</li></ul></li><li>只方便计算无向图的度，不太适合有向图</li></ul><h4 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h4><h5 id="考-DFS-深度优先搜索"><a href="#考-DFS-深度优先搜索" class="headerlink" title="(考)DFS 深度优先搜索"></a>(考)DFS 深度优先搜索</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归访问,抽象表示，类似于树的先序遍历，栈也可</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Vertex V)</span></span>&#123;<span class="comment">//传入一个起始点</span></span><br><span class="line">    visited[V]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> ( V的每个邻接点 W )</span><br><span class="line">        <span class="keyword">if</span>(!visited [W])</span><br><span class="line">            DFS(w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先搜索 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(struct GNode *Graph,<span class="keyword">int</span> n,<span class="keyword">int</span> visited[])</span></span>&#123;<span class="comment">//G为已知图，n为起始点 </span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,Graph-&gt;Data[n]);<span class="comment">//先输出起始顶点，再输出访问的其他顶点</span></span><br><span class="line">visited[n]=<span class="number">1</span>;<span class="comment">//事先将起始顶点标记为true</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Graph-&gt;Nv;i++)&#123;</span><br><span class="line"> <span class="keyword">if</span>(Graph-&gt;G[n][i]!=<span class="number">0</span> &amp;&amp; visited[i]==<span class="number">0</span>)<span class="comment">///若第i个顶点与G-&gt;Data[n]有关，并且未被访问</span></span><br><span class="line">        &#123;</span><br><span class="line">            DFS(Graph,i,visited);<span class="comment">///用递归的方式继续搜寻</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Graph-&gt;Nv;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[i]==<span class="number">0</span>)<span class="comment">///此循环用于判断顶点是否访问完成</span></span><br><span class="line">        &#123;</span><br><span class="line">             DFS(Graph,i,visited);<span class="comment">///用递归的方式继续搜寻，直至所有顶点访问完毕</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>采用队列实现</li></ul><p>若有N个顶点、E条边，时间复杂度是</p><ul><li>用邻接表存储图，有O(N+E)</li><li>用临界矩阵存储图，有O(N^2)</li></ul><h5 id="考-BFS-广度优先搜索"><a href="#考-BFS-广度优先搜索" class="headerlink" title="(考)BFS 广度优先搜索"></a>(考)BFS 广度优先搜索</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类似层序遍历队列实现，每次出队时入队相邻未访问元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Vertex V)</span></span>&#123;</span><br><span class="line">    visited[V]= <span class="literal">true</span>;</span><br><span class="line">    Enqueue(V,Q);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">        V = Dequeue(Q);</span><br><span class="line">        <span class="keyword">for</span>(V 的每个邻接点 W)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[W])&#123;</span><br><span class="line">                visited[W] = <span class="literal">true</span>;</span><br><span class="line">                Enqueue(W,Q);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElementType int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WeightType int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DataType int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxsize 5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">ElementType Data[Maxsize];</span><br><span class="line"><span class="keyword">int</span> front;</span><br><span class="line"><span class="keyword">int</span> rear;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function">struct Node* <span class="title">initNode</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">p</span>;</span></span><br><span class="line">p=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">p-&gt;front=<span class="number">0</span>;</span><br><span class="line">p-&gt;rear=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环队列 数组内只放放n-1个元素防止误判 满/空 尾(rear)进头(front)出 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(struct Node *p,ElementType k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>((p-&gt;rear+<span class="number">1</span>)%Maxsize==p-&gt;front)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"队列满"</span>); </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">p-&gt;rear=(p-&gt;rear+<span class="number">1</span>)%Maxsize;<span class="comment">//最后一位会变零</span></span><br><span class="line">p-&gt;Data[p-&gt;rear]=k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队列</span></span><br><span class="line"><span class="function">ElementType <span class="title">Delete</span><span class="params">(struct Node *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;front==p-&gt;rear)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列空"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        p-&gt;front=(p-&gt;front+<span class="number">1</span>)%Maxsize;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;Data[p-&gt;front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(struct GNode *Graph,<span class="keyword">int</span> visited[],struct Node *p)</span></span>&#123;<span class="comment">//图、起始点、顶点数量、辅助数组、辅助队列 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Graph-&gt;Nv;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!visited[i])&#123;<span class="comment">//从未访问过该顶点 </span></span><br><span class="line">visited[i]=<span class="number">1</span>; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Graph-&gt;Data[i]);</span><br><span class="line">Add(p,i);</span><br><span class="line"><span class="keyword">while</span>(p-&gt;front!=p-&gt;rear)&#123;</span><br><span class="line">i=Delete(p);<span class="comment">//出队需要访问的顶点下标 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Graph-&gt;Nv;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(Graph-&gt;G[i][j]==<span class="number">1</span> &amp;&amp; !visited[j])&#123;<span class="comment">//其他顶点与改顶点有联系 且未访问 </span></span><br><span class="line">visited[j]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Graph-&gt;Data[j]);<span class="comment">//访问已出队的顶点 </span></span><br><span class="line">Add(p,j);<span class="comment">//入队未访问的顶点下标 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若有N个顶点、E条边，时间复杂度是</p><ul><li>用邻接表存储图，有O(N+E)</li><li>用临界矩阵存储图，有O(N^2)</li></ul><p>每调用一次<strong>BFS/BFS</strong> 就是把 <strong>V</strong> 所在的连通分量遍历了一遍。</p><h4 id="如何建立一个图"><a href="#如何建立一个图" class="headerlink" title="如何建立一个图"></a>如何建立一个图</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span> *<span class="title">PtrToGNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Nv;<span class="comment">//顶点数</span></span><br><span class="line">    <span class="keyword">int</span> Ne;<span class="comment">//边数</span></span><br><span class="line">    WeightType G[MaxVertexNum][MaxVertexNum];</span><br><span class="line">    DataType Data[MaxVertexNum];<span class="comment">//存放顶点的数据，顶点表vertex</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToGNode MGraph;<span class="comment">//指针别名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤1：初始化一个有VertexNum 个顶点但 没有边 的图</span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">int</span> Vertex;<span class="comment">//用顶点下标表示顶点，为整型</span></span><br><span class="line"><span class="function">MGraph <span class="title">CreateGraph</span><span class="params">(<span class="keyword">int</span> VertexNum)</span></span>&#123;</span><br><span class="line">    Vertex V,W;<span class="comment">//区分出入的顶点个数VertexNum</span></span><br><span class="line">    MGraph Graph;</span><br><span class="line">    </span><br><span class="line">    Graph = (MGraph)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct GNode));</span><br><span class="line">    Graph-&gt;Nv = VertexNum;</span><br><span class="line">    Graph-&gt;Ne = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意这里默认顶点编号从0开始，到(Graph-&gt;Nv-1)</span></span><br><span class="line">    <span class="keyword">for</span>(V=<span class="number">0</span>;V&lt;Graph-&gt;Nv;V++)</span><br><span class="line">        <span class="keyword">for</span> (W=<span class="number">0</span>;W&lt;Graph-&gt;Nv;W++)</span><br><span class="line">            Graph-&gt;G[V][W]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//步骤2：向图中插入边</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ENode</span> *<span class="title">PtrToENode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ENode</span>&#123;</span></span><br><span class="line">  Vertex V1,V2;<span class="comment">//有向边&lt;V1,V2&gt;,两个顶点</span></span><br><span class="line">  WeightType Weight;<span class="comment">//权重</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToENode Edge;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertEdge</span><span class="params">(MGraph Graph,Edge E)</span></span>&#123;</span><br><span class="line">    <span class="comment">//插入边，有向图只用插一边&lt;V1,V2&gt;，无向图要两边</span></span><br><span class="line">    Graph-&gt;G[E-&gt;V1][E-&gt;V2]=E-&gt;Weight;</span><br><span class="line">    <span class="comment">//无向图 插入&lt;V2,V1&gt;</span></span><br><span class="line">    Graph-&gt;G[E-&gt;V2][E-&gt;V1]=E-&gt;Weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//完整的建立一个图</span></span><br><span class="line"><span class="function">MGraph <span class="title">BuildGraph</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MGraph Graph;</span><br><span class="line">    Edge E;</span><br><span class="line">    Vertex V;</span><br><span class="line">    <span class="keyword">int</span> Nv,i;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Nv);</span><br><span class="line">    Graph = CreateGraph(Nv);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;(Graph-&gt;Ne));<span class="comment">//直接读入 赋值边 输入函数不能加花里胡哨的东西</span></span><br><span class="line">    <span class="keyword">if</span> (Graph-&gt;Ne!=<span class="number">0</span>)&#123;</span><br><span class="line">        E = (Edge)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ENode));<span class="comment">//临时</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Graph-&gt;Ne;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;E-&gt;V1,&amp;E-&gt;V2,&amp;E-&gt;Weight);</span><br><span class="line">            InsertEdge(Graph,E);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果顶点有数据的话，读入数据</span></span><br><span class="line">    <span class="keyword">for</span>(V=<span class="number">0</span>; V&lt;Graph-&gt;Nv;V++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">" %c"</span>,&amp;(Graph-&gt;Data[V]));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//考试应急</span></span><br><span class="line"><span class="keyword">int</span> G[MAXN][MAXN],Nv,Ne;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildGraph</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,v1,v2,w;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Nv);</span><br><span class="line">    <span class="comment">//创建图</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Nv;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;Nv;j++)&#123;</span><br><span class="line">            G[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Ne);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Ne;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;v1,&amp;v2,&amp;w);</span><br><span class="line">        <span class="comment">//插入</span></span><br><span class="line">        G[v1][v2]=w;</span><br><span class="line">        G[v2][v1]=w;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="单元最短路径"><a href="#单元最短路径" class="headerlink" title="单元最短路径"></a>单元最短路径</h4><h5 id="考-Dijkstra"><a href="#考-Dijkstra" class="headerlink" title="(考)Dijkstra"></a>(考)Dijkstra</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Dijkstra</span>(<span class="title">int</span> <span class="title">n</span>,<span class="title">int</span> <span class="title">v</span>,<span class="title">Type</span> <span class="title">dist</span>[],<span class="title">int</span> <span class="title">prev</span>[],<span class="title">Type</span> **<span class="title">c</span>)&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> s[maxint];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dist[i]=c[v][i];</span><br><span class="line">        s[i]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(dist[i]==maxint)</span><br><span class="line">            prev[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            prev[i]=v;<span class="comment">//当前i顶点对应的前一个顶点下标</span></span><br><span class="line">    &#125;</span><br><span class="line">    dist[v]=<span class="number">0</span>;s[v]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=maxint;</span><br><span class="line">        <span class="keyword">int</span> u=v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((!s[j])&amp;&amp;(dist[j]&lt;temp))&#123;</span><br><span class="line">                u=j;</span><br><span class="line">                temp = dist[j];</span><br><span class="line">            &#125;</span><br><span class="line">            s[u]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((!s[j])&amp;&amp;(c[u][j]&lt;maxint))&#123;</span><br><span class="line">                    Type newdist =dist[u]+c[u][j];</span><br><span class="line">                    <span class="keyword">if</span>(newdist&lt;dist[j])&#123;</span><br><span class="line">                        dist[j]=newdist;</span><br><span class="line">                        prev[j] = u;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><p>定义：</p><ul><li>是一棵树<ul><li>无回路</li><li><code>V</code>个顶点一定有<code>V-1</code>条边</li></ul></li><li>是生成树<ul><li>包含全部顶点</li><li><code>V-1</code>条边都在图里</li></ul></li><li>边的权重和最小</li></ul><p><strong>等价于图连通</strong></p><p>贪心算法：</p><ul><li>贪：每一步要求最<strong>好</strong></li><li>好：权重最小的边</li><li><strong>需要约束：</strong><ul><li>只能用途中有的边</li><li>只能正好用掉<code>V-1</code>条边</li><li>不能有回路</li></ul></li></ul><hr><h5 id="考-Prim算法"><a href="#考-Prim算法" class="headerlink" title="(考)Prim算法"></a>(考)Prim算法</h5><p>算法思想：</p><p>从连通网 N={V,E}中的某一顶点U0出发，选择与它关联的具有最小权值的边(U0,v)，将其顶点加入到生成树的顶点集合U中。以后每一步从集合U中的所有顶点边中选择一条最小权值边(u,v)同时此边(u,v)所连接的顶点不包含在集合U中的任何顶点，则把它的顶点加入到集合U中。如此继续下去，直到网中的所有顶点都加入到生成树顶点集合U中为止。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(|V|2)适合稠密图</span></span><br><span class="line"><span class="comment">//Prim</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Void</span> <span class="title">Prim</span>(<span class="title">int</span> <span class="title">n</span>,<span class="title">Type</span> **<span class="title">c</span>)&#123;</span></span><br><span class="line">    Type lowcost[maxint];</span><br><span class="line">    <span class="keyword">int</span> closest[maxint];</span><br><span class="line">    <span class="keyword">bool</span> s[maxint];</span><br><span class="line">    s[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        lowcost[i]=c[<span class="number">1</span>][i];</span><br><span class="line">        closest[i]=<span class="number">1</span>;</span><br><span class="line">        s[i]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        Type min=inf;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//找中使用权值最小的顶点j</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>;k&lt;=n;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((lowcost[k]&lt;min)&amp;&amp; (!s[k]))&#123;</span><br><span class="line">                min=lowcost[k];</span><br><span class="line">                j=k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到符合贪心选择方式的边，将顶点j加入到集合S</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;j&lt;&lt;<span class="string">' '</span>&lt;&lt;closest[j]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        s[j]=<span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//找到一条边后，更新数组closest和lowcost</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((c[j][k]&lt;lowcost[k]) &amp;&amp; (!s[k]))&#123;</span><br><span class="line">            lowcost[k]=c[j][k];</span><br><span class="line">                closest[k]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h5><p>算法思想：</p><p>把森林合并成树</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度（使用最小堆放权重集合 并查集检查回路）O(|E|log|E|) 适合稀疏图</span></span><br></pre></td></tr></table></figure><hr><h3 id="考-查找和内部排序"><a href="#考-查找和内部排序" class="headerlink" title="(考)查找和内部排序"></a>(考)查找和内部排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElementType int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(ElementType *x,ElementType *y)</span></span>&#123;</span><br><span class="line">    ElementType temp;</span><br><span class="line">    temp = *x;</span><br><span class="line">    *x=*y;</span><br><span class="line">    *y=temp;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap1</span><span class="params">(ElementType &amp;x,ElementType &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    temp = x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=temp;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble_Sort</span><span class="params">(ElementType A[],<span class="keyword">int</span> N)</span></span>;</span><br><span class="line"><span class="keyword">int</span> x[]=&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>&#125;; </span><br><span class="line">Bubble_Sort(x,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,x[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单排序"><a href="#简单排序" class="headerlink" title="简单排序"></a>简单排序</h4><h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><p>算法思想：比较相邻两个元素大小，若从小到大排则将大元素始终置后，<strong>每一趟</strong>完成会将<strong>最大的元素</strong>放到确定的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble_Sort</span><span class="params">(ElementType A[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> p=N<span class="number">-1</span>;p&gt;=<span class="number">0</span>;p--)&#123;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;<span class="comment">//判断是否在一趟排序过程中有序，没有触发Swap</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;p;i++)&#123;<span class="comment">//一趟</span></span><br><span class="line">    <span class="keyword">if</span>(A[i]&gt;A[i+<span class="number">1</span>])&#123;</span><br><span class="line">    <span class="comment">//a=&amp;A[i];</span></span><br><span class="line">    <span class="comment">//b=&amp;A[i+1];</span></span><br><span class="line">        <span class="comment">//Swap(a,b);</span></span><br><span class="line">        Swap1(A[i],A[i+<span class="number">1</span>]);</span><br><span class="line">        flag=<span class="number">1</span>;<span class="comment">//发生了交换</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//适合单向链表，同一顺序，稳定 最好O(N)最坏O(N^2) 平均O(N^2)</span></span><br></pre></td></tr></table></figure><h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><p>算法思想：从前往后取数，并从取数位置从后向前比较，将每一个数向后移，插入到合适得位置，从<strong>第一个数开始</strong>，<strong>第零个不动</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insertion_Sort</span><span class="params">(ElementType A[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">    ElementType tmp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> P=<span class="number">1</span>;P&lt;N;P++)&#123;</span><br><span class="line">tmp=A[P];<span class="comment">//摸下一张，从前往后 </span></span><br><span class="line"><span class="keyword">for</span>( i=P;i&gt;<span class="number">0</span> &amp;&amp; A[i<span class="number">-1</span>]&gt;tmp;i--)&#123;</span><br><span class="line">A[i]=A[i<span class="number">-1</span>];<span class="comment">//移出空位 </span></span><br><span class="line">&#125;</span><br><span class="line">    A[i]=tmp;<span class="comment">//新牌落位 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//稳定，最好O(N)最坏O(N^2) 平均O(N^2)</span></span><br></pre></td></tr></table></figure><h5 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h5><p>算法思想：通过设定增量序列，实现插入排序</p><p><img src="/2020/08/24/数据结构/20.jpg" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shell_sort</span><span class="params">(ElementType A[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">    ElementType tmp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> D=N/<span class="number">2</span>;D&gt;<span class="number">0</span>;D/=<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> P=D;P&lt;N;P++)&#123;</span><br><span class="line">tmp=A[P];<span class="comment">//摸下一张，从前往后 </span></span><br><span class="line"><span class="keyword">for</span>( i=P;i&gt;=D &amp;&amp; A[i-D]&gt;tmp;i-=D)&#123;</span><br><span class="line">A[i]=A[i-D];<span class="comment">//移出空位 </span></span><br><span class="line">&#125;</span><br><span class="line">    A[i]=tmp;<span class="comment">//新牌落位 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//最坏O(N^2) Hibbard 增量 Dk=2^k-1-相邻元素互质，不互质小增量排序没效果，最坏(O^3/2)</span></span><br></pre></td></tr></table></figure><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Selection_Sort</span><span class="params">(ElementType A[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        MinPosition = ScanForMin(A,i,N<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//从A[i]到A[i-1]中找到最小元，并将其位置赋值给MinPosition</span></span><br><span class="line">        Swap1(A[i],A[MinPosition]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1 时间O(NlogN) 并且需要额外O(N)空间，并且复制元素需要时间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap_Sort</span><span class="params">(ElementType A[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    BuildHeap(A);<span class="comment">// O(n)小顶堆/最小堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        TmpA[i]=DeleteMin(A);<span class="comment">//O(logN)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)<span class="comment">//O(N)</span></span><br><span class="line">        A[i]=TmpA[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//算法2 时间2NlogN-O(NloglogN) </span></span><br><span class="line"><span class="comment">//通过调整最大堆，完成后将根结点最大元素与最小元素交换位置，并剔除最大元素，将剩余元素继续执行上述过程 由小到大排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap_Sort</span><span class="params">(ElementType A[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=N/<span class="number">2</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)<span class="comment">//BuildHeap</span></span><br><span class="line">        PercDown(A , i ,N);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=N<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        swap(A[<span class="number">0</span>],A[i]);<span class="comment">//deleteMax</span></span><br><span class="line">        PercDown(A,<span class="number">0</span>,i);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PercDown</span><span class="params">(ElementType A[],<span class="keyword">int</span> i,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> parent,child;</span><br><span class="line">    ElementType temp;</span><br><span class="line"><span class="keyword">for</span>(parent=i;parent*<span class="number">2</span>+<span class="number">1</span>&lt;N;parent=child)&#123;<span class="comment">//A[0]不是哨兵了</span></span><br><span class="line">        child=parent*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(child!=N<span class="number">-1</span> &amp;&amp; A[child]&lt;A[child+<span class="number">1</span>])</span><br><span class="line">            child++;</span><br><span class="line">        <span class="keyword">if</span>(A[parent]&lt;A[child])&#123;</span><br><span class="line">temp=A[parent];</span><br><span class="line">            A[parent]=A[child];</span><br><span class="line">            A[child]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>核心：<strong>两个有序子列得归并</strong></p><p>思想：比较两个序列中元素得大小，挑出小元素放到第三个序列中,适合<strong>外部排序</strong></p><p><img src="/2020/08/24/数据结构/21.jpg" alt></p><h5 id="递归方式"><a href="#递归方式" class="headerlink" title="递归方式"></a>递归方式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间 O(N) 两个子列一共有N个元素</span></span><br><span class="line"><span class="comment">//L=左边起始位置(Aptr) R=右边起始位置(Bptr) RightEnd=右边终点位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(ElementType A[],ElementType TmpA[],<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> RightEnd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leftEnd=R<span class="number">-1</span>;<span class="comment">//左边终点位置，假设左右两列挨着 在一个数组里面</span></span><br><span class="line">    <span class="keyword">int</span> Tmp=L;<span class="comment">//存放结果得数组得初始位置，从第二个数组得哪个地方开始</span></span><br><span class="line">    <span class="keyword">int</span> NumElements = RightEnd - L + <span class="number">1</span>;<span class="comment">//归并结束后总元素数</span></span><br><span class="line">    <span class="keyword">while</span>(L&lt;=leftEnd &amp;&amp; R&lt;=RightEnd)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[L]&lt;=A[R])TmpA[Tmp++]=A[L++];</span><br><span class="line">        <span class="keyword">else</span> TmpA[Tmp++]=A[R++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(L&lt;=leftEnd)</span><br><span class="line">        TmpA[Tmp++]=A[L++];<span class="comment">//直接复制左边剩下的</span></span><br><span class="line">    <span class="keyword">while</span>(R&lt;=RightEnd)</span><br><span class="line">        TmpA[Tmp++]=A[R++];<span class="comment">//直接复制右边剩下得</span></span><br><span class="line">    <span class="comment">//两个只会执行一个</span></span><br><span class="line">    <span class="comment">//最后将TmpA数组倒回A数组，RightEnd 始终没变(传进来后，传进来前始终在变)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;NumElements;i++,RightEnd--)</span><br><span class="line">        A[RightEnd]=TmpA[RightEnd];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分而治之 时间复杂度T(N)=T(N/2)+T(N/2)+O(N)=&gt;T(N)=O(NlogN) 稳定</span></span><br><span class="line"><span class="comment">//RightEnd 始终在变 递归调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MSort</span><span class="params">(ElementType A[],ElementType TmpA[],<span class="keyword">int</span> L,<span class="keyword">int</span> RightEnd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Center;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;RightEnd)&#123;</span><br><span class="line">        Center = (L+RightEnd)/<span class="number">2</span>;</span><br><span class="line">        MSort(A,TmpA,L,Center);</span><br><span class="line">        MSort(A,TmpA,Center+<span class="number">1</span>,RightEnd);</span><br><span class="line">        Merge(A,TmpA,L,Center+<span class="number">1</span>,RightEnd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统一接口 重要！！！！</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_sort</span><span class="params">(ElementType A[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    ElementType *TmpA;</span><br><span class="line">    TmpA=(ElementType*)<span class="built_in">malloc</span>(N * <span class="keyword">sizeof</span>(ElementType));</span><br><span class="line">    <span class="keyword">if</span> (TmpA!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        MSort(A,TmpA,<span class="number">0</span>,N<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">free</span>(TmpA);<span class="comment">//释放临时数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> Error(<span class="string">"内存不足"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过程图解：解决一段导回去一段</p><p><img src="/2020/08/24/数据结构/22.jpg" alt></p><p><img src="/2020/08/24/数据结构/23.jpg" alt></p><p><strong>不合算，重复malloc</strong></p><p><img src="/2020/08/24/数据结构/24.jpg" alt></p><h5 id="非递归方式"><a href="#非递归方式" class="headerlink" title="非递归方式"></a>非递归方式</h5><p>算法思想：利用临时数组，两边倒</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge1</span><span class="params">(ElementType A[],ElementType TmpA[],<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> RightEnd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leftEnd=R<span class="number">-1</span>;<span class="comment">//左边终点位置，假设左右两列挨着 在一个数组里面</span></span><br><span class="line">    <span class="keyword">int</span> Tmp=L;<span class="comment">//存放结果得数组得初始位置，从第二个数组得哪个地方开始</span></span><br><span class="line">    <span class="keyword">int</span> NumElements = RightEnd - L + <span class="number">1</span>;<span class="comment">//归并结束后总元素数</span></span><br><span class="line">    <span class="keyword">while</span>(L&lt;=leftEnd &amp;&amp; R&lt;=RightEnd)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[L]&lt;=A[R])TmpA[Tmp++]=A[L++];</span><br><span class="line">        <span class="keyword">else</span> TmpA[Tmp++]=A[R++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(L&lt;=leftEnd)</span><br><span class="line">        TmpA[Tmp++]=A[L++];<span class="comment">//直接复制左边剩下的</span></span><br><span class="line">    <span class="keyword">while</span>(R&lt;=RightEnd)</span><br><span class="line">        TmpA[Tmp++]=A[R++];<span class="comment">//直接复制右边剩下得</span></span><br><span class="line">    <span class="comment">//两个只会执行一个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_pass</span><span class="params">(ElementType A[],ElementType TmpA[],<span class="keyword">int</span> N,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> length)</span></span>&#123;<span class="comment">//length = 当前有序子序列长度</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=N<span class="number">-2</span>*length;i+=<span class="number">2</span>*length)</span><br><span class="line">        Merge1(A,TmpA,i,i+length,i+<span class="number">2</span>*length<span class="number">-1</span>);<span class="comment">//将A中元素归并到TmpA而不直接倒回来</span></span><br><span class="line">    <span class="comment">//处理最后两个</span></span><br><span class="line">    <span class="keyword">if</span>(i+length&lt;N)<span class="comment">//归并最后两个子列</span></span><br><span class="line">        Merge1(A,TmpA,i,i+length,N<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//最后剩一个,直接倒进去就可以了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;N;j++)TmpA[j]=A[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统一接口 重要！！！！</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_sort1</span><span class="params">(ElementType A[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    ElementType *TmpA;</span><br><span class="line">    <span class="keyword">int</span> length=<span class="number">1</span>;<span class="comment">//长度为1开始一次两个</span></span><br><span class="line">    TmpA=(ElementType*)<span class="built_in">malloc</span>(N * <span class="keyword">sizeof</span>(ElementType));</span><br><span class="line">    <span class="keyword">if</span> (TmpA!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(length&lt;N)&#123;</span><br><span class="line">            Merge_pass(A,TmpA,N,length);</span><br><span class="line">        length *=<span class="number">2</span>;</span><br><span class="line">            Merge_pass(TmpA,A,N,length);</span><br><span class="line">            length *=<span class="number">2</span>;<span class="comment">//两边确保最后一次将TmpA中得序列倒回 A中</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="built_in">free</span>(TmpA);<span class="comment">//释放临时数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> Error(<span class="string">"内存不足"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>算法思想：<strong>分而治之(递归)</strong>，首先随机找一个数作为主元，将集合分为以主元为标识得左右两集合，通过递归将两个集合排序，最后合并三部分(左集合，主元，右集合)。</p><p><img src="/2020/08/24/数据结构/25.jpg" alt></p><p><img src="/2020/08/24/数据结构/26.jpg" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最好情况，每次主元中分两个数组O(nlogn) 最坏O(N^2)</span></span><br><span class="line"><span class="comment">//选取头 中 尾得中位数 采用交换得方式，将头 中 尾处理为小到大得序列，选中间</span></span><br><span class="line"><span class="function">ElementType <span class="title">Median3</span><span class="params">(ElementType A[],<span class="keyword">int</span> Left,<span class="keyword">int</span> Right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Center=(Left+Right)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(A[Left]&gt;A[Center])</span><br><span class="line">        Swap(A[Left],A[Center]);</span><br><span class="line">    <span class="keyword">if</span>(A[Left]&gt;A[Right])</span><br><span class="line">        Swap(A[Left],A[Right]);</span><br><span class="line">    <span class="keyword">if</span>(A[Center]&gt;A[Right])</span><br><span class="line">        Swap(A[Center],A[Right]);</span><br><span class="line">    <span class="comment">//A[Left]&lt;=A[Center]&lt;=A[Right]</span></span><br><span class="line">    Swap(A[Center],A[Right<span class="number">-1</span>]);<span class="comment">//将pivot藏到右边倒数第二个，</span></span><br><span class="line">    <span class="comment">//只需考虑A[Left+1],A[Right-2]，因为第一个和最后一个已经比它小和大</span></span><br><span class="line">    <span class="keyword">return</span> A[Right<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/08/24/数据结构/27.jpg" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quicksort</span><span class="params">(ElementType A[],<span class="keyword">int</span> Left,<span class="keyword">int</span> Right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Right<span class="number">-1</span>&gt;<span class="number">0</span> &amp;&amp; Left+<span class="number">1</span>&lt;Right)&#123;<span class="comment">//判断数组是否越界，越界直接退出</span></span><br><span class="line"><span class="keyword">int</span> Pivot=Median3(A,Left,Right);</span><br><span class="line">    <span class="keyword">int</span> i=Left;</span><br><span class="line">    <span class="keyword">int</span> j=Right<span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>( ; ; )&#123;</span><br><span class="line">        <span class="comment">//A[Left+1],A[Right-2]</span></span><br><span class="line">        <span class="keyword">while</span>(A[++i]&lt;Pivot)&#123;&#125;</span><br><span class="line">        <span class="keyword">while</span>(A[--j]&gt;Pivot)&#123;&#125;</span><br><span class="line">        <span class="comment">//两边都出现问题</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">            <span class="comment">//说明都出现问题 可以调换</span></span><br><span class="line">            Swap(&amp;A[i],&amp;A[j]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;<span class="comment">//i&gt;j 调换</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Swap(&amp;A[i],&amp;A[Right<span class="number">-1</span>]);<span class="comment">//将Center这个数放到自己得位置上</span></span><br><span class="line">    Quicksort(A,Left,i<span class="number">-1</span>);<span class="comment">//递归将两边集合继续划分子集排序</span></span><br><span class="line">    Quicksort(A,i+<span class="number">1</span>,Right);</span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quick_Sort</span><span class="params">(ElementType A[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    Quicksort(A,<span class="number">0</span>,N<span class="number">-1</span>);<span class="comment">//数组下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="表排序"><a href="#表排序" class="headerlink" title="表排序"></a>表排序</h4><p>算法思想：间接排序，定义一个<strong>指针数组</strong>(数组下标/指针)作为“表”(table)</p><p><img src="/2020/08/24/数据结构/28.jpg" alt></p><ul><li><strong>N个数字得排列一定是由若干个独立得环组成</strong><ul><li>每完成一个移动就重置<code>table</code>等于自己，最后一个环放置第一个拿出去的临时数</li></ul></li></ul><p><img src="/2020/08/24/数据结构/29.jpg" alt></p><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>算法思想：采用LSD”次位优先“， 首先根据<strong>个位数</strong>的数值，在走访数值时将它们分配至编号0到9的桶子中， 接下来将这些桶子中的数值重新串接起来 ， 接着再进行一次分配，这次是根据<strong>十位数</strong>来分配 ， 接下来将这些桶子中的数值重新串接起来 ， 这时候整个数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至<strong>最高位数</strong>为止。 </p><p><img src="/2020/08/24/数据结构/31.jpg" alt></p><h4 id="排序算法比较"><a href="#排序算法比较" class="headerlink" title="排序算法比较"></a>排序算法比较</h4><p><img src="/2020/08/24/数据结构/30.jpg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言复习</title>
      <link href="/2020/08/20/c%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0/"/>
      <url>/2020/08/20/c%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="C-C-语言复习"><a href="#C-C-语言复习" class="headerlink" title="C/C++语言复习"></a>C/C++语言复习</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">include&lt;stdio.h&gt;</span><br><span class="line">基本头函数 </span><br><span class="line">include&lt;<span class="built_in">string</span>.h&gt;</span><br><span class="line">字符串处理函数 </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;<span class="comment">//第三个函数体最后循环结束时才运行，++i和i++一样 </span></span><br><span class="line">    </span><br><span class="line">    a[i]=++j;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i); </span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">char</span> c[<span class="number">4</span>]=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'\0'</span>,<span class="string">'d'</span>&#125;;<span class="comment">//单个字符用‘’\0表示结束，“”超过一个字符 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,getchar());</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">13</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str);<span class="comment">//c语言中如果输入是数据变量则不需要加&amp;引用，数组本身就是引用地址 </span></span><br><span class="line"><span class="keyword">int</span> a ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a); </span><br><span class="line"><span class="keyword">char</span> c[]=&#123;<span class="string">"China\n12223"</span>&#125;;<span class="comment">//会在字符组后自动 添加\0 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,c);</span><br><span class="line"><span class="built_in">puts</span>(c);<span class="comment">//输出已经定义得字符组 </span></span><br><span class="line"></span><br><span class="line">gets(c);<span class="comment">//从键盘获取char数组字符+1位返回值时c得起始地址，puts和gets只能输出和输入一个字符串 </span></span><br><span class="line"><span class="built_in">puts</span>(c);</span><br><span class="line"><span class="keyword">char</span> c[<span class="number">20</span>]=&#123;<span class="string">"China\n12223"</span>&#125;;<span class="comment">//会在字符组后自动 添加\0 </span></span><br><span class="line"><span class="keyword">char</span> str[]=&#123;<span class="string">"\nxxx"</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,<span class="built_in">strcat</span>(c,str));<span class="comment">//strcat可以链接两个字符串，且第一个字符串要足够大可以容纳下1，2两个数组，不满得位置都是\0</span></span><br><span class="line"><span class="keyword">char</span> str1[<span class="number">10</span>],str2[]=<span class="string">"China"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,<span class="built_in">strcpy</span>(str1,str2));<span class="comment">//将字符串2复制到1中也可以strcpy(str1,"China") </span></span><br><span class="line"><span class="built_in">strcmp</span>(str1,<span class="string">"China"</span>);<span class="comment">//比较两个字符串相等=0左大为正数，右大为负数 </span></span><br><span class="line"><span class="built_in">strlen</span>(<span class="string">"asdasd"</span>);<span class="comment">//统计字符串完整长度，不包括\0</span></span><br><span class="line"><span class="comment">//strlwr将字符串中大转小 strupr 小转大</span></span><br></pre></td></tr></table></figure><p>函数写在<code>main</code>下面得时候，要在<code>main</code>函数里面声明，例如 <code>viod test();</code>调用<code>test()；</code></p><p>带返回值得函数都需加类型，没有返回值得用void 传递数组时，传递首地址，所以声明函数中数组可以不加大小<br><code>void test(int array[])</code>但是类型要一致 ，多维要加最高维度大小 <code>int test(int array[][10])</code></p><p>寄存器变量 <code>register</code> 减少去内存读取数量 </p><p>全局变量定义域一般从定义处开始到文件末，使用<code>extern</code>可以把下面得全局变量扩展到此处。两个文件间使用扩展得话<br>就是一个文件定义全局变量，另一个文件使用<code>extern</code>进行扩展链接 ，如果一个文件中全局变量被<code>static</code>修饰，<br>则其他文件中不能用<code>extern</code>扩展</p><p><code>static</code> 修饰函数时不能被其他文件调用  <code>extern</code> 修饰函数可以被其他文件声明使用 是默认，可省 </p><a id="more"></a><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><ul><li><p><strong>&amp;</strong>  取地址运算符。<strong>&amp;a</strong>是变量a的地址</p></li><li><p><code>*</code>指针运算符(或称“间接访问”运算符)，<strong>*p</strong> 代表指针变量 <strong>p</strong> 指向的对象。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p=&amp;a;<span class="comment">//相当于 int *p; p=&amp;a;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a);<span class="comment">//变量a的值</span></span><br><span class="line"><span class="comment">//p=&amp;a; </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,*p);<span class="comment">//间接访问变量a的值</span></span><br><span class="line">*p=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,p);<span class="comment">//变量a的地址</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">6487572</span></span><br></pre></td></tr></table></figure><ul><li>指针指向数组包括：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p=&amp;a[<span class="number">1</span>];<span class="comment">//得到a[1]元素的地址</span></span><br><span class="line">p=a;<span class="comment">//相当于p=&amp;a[0]获得数组a首元素a[0]的地址</span></span><br></pre></td></tr></table></figure><p>数组名赋值给指针只能代表首元素地址，并不能表示整个数组。</p><p>因为数组在内存中是<strong>顺序存储</strong>，所以可以采用<code>p+1</code>的方式使指针指向下一个元素。注意：执行<code>p+1</code>时并不是将<code>p</code>的值（地址）简单的加<strong>1</strong>，而是加上一个数组元素所占用的字节数。所以<code>p+1</code>意味着使<code>p</code>的值（是地址）加上<strong>4</strong>个字节，所代表的地址实际上是<code>（p+1）*d</code>（<strong>int d=4字节, float和long d=4字节, char d=1字节</strong>）,二维数组名指针指向首行首元素，加1后相当于加了1行，地址加了一整行的大小，表示下一个元素使用 <strong>a[0]+1</strong></p><hr><p><strong>指针数组</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a [<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">4</span>];</span><br><span class="line">p=&amp;a;<span class="comment">//指向一维数组，不能写成“p=a;”，因为这样表示p是&amp;a[0]，指向a[0]。“p=&amp;a;”表示p指向一维数组（行），（*p）[3]是p所指向的行中序号为3的元素。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,(*p)[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="function"><span class="keyword">void</span> <span class="title">average</span><span class="params">(<span class="keyword">float</span> *p,<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">float</span> (*p)[<span class="number">4</span>] ,<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">float</span> a[<span class="number">3</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line"> average(*a,<span class="number">12</span>);<span class="comment">//传入参数为*a 即a[0],也就是&amp;a[0][0],即a[0][0]的地址。</span></span><br><span class="line"> serach(a,<span class="number">2</span>);<span class="comment">//传入实参a，因为对应float (*p)[4]是包含4个元素的一组数组的指针变量，所以p指向的是a[0],第0行的地址。p+n是a[n]的起始地址，*（p+n）+i是a[n][i]的地址，*(*(p+n)+i)是a[n][i]的元素值 a+i=a[i]=*(a+i)=&amp;a[i]=&amp;a[i][0]</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">average</span><span class="params">(<span class="keyword">float</span> *p,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> *p_end;</span><br><span class="line">    <span class="keyword">float</span> sum=<span class="number">0</span>,aver;</span><br><span class="line">    p_end=p+n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;p&lt;=p_end;p++)</span><br><span class="line">        sum=sum+(*p);</span><br><span class="line">    aver=sum/n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"average%5.2f\n"</span>,aver);<span class="comment">//5.2是指结果总长是五位数（注意小数点也算一位数长），就是小数点前两个数字，不足就用空格表示，小数点后保留两位，不足四舍五入！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">float</span> (* p)[<span class="number">4</span>],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"第%d行\n"</span>,n);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%5.2f"</span>,*(*(p+n)+i));<span class="comment">//等价*(p[n]+i)等价*(&amp;p[n][i])</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于字符串来说</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[]=<span class="string">"asadad"</span>;<span class="comment">//str[4]相当于*（str+4）</span></span><br><span class="line"><span class="keyword">char</span> *str=<span class="string">"asdasdd"</span>;<span class="comment">//相当于 char *str;str="asdasdd";字符串并没有被放入指针，而是“asdasdd”的第一个字符的地址赋值给了指针变量str</span></span><br></pre></td></tr></table></figure><p>对于字符串中字符的存取，可以用下标方法，也可以用指针方法，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[]=<span class="string">"paniford"</span>,b[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;*(a+i)!=<span class="string">'\0'</span>,i++)</span><br><span class="line">        *(b+i)=*(a+i);<span class="comment">//将a[i]给b[i]</span></span><br><span class="line">    *(b+i)=<span class="string">'\0'</span>;<span class="comment">//在最后加\0 ！！注意！！使用‘’对单个char</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"string a is: %s\n"</span>,a);<span class="comment">//输出a中全部有效字符，%s输出字符串时不用*计算双重时加一个*</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"string b is;"</span>);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;b[i]!=<span class="string">'\0'</span>,i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,b[i]);<span class="comment">//逐个输出b组中全部有效字符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>注意：</p><ul><li><p><strong>字符数组由若干个元素组成，每个元素中放一个字符，而字符指针变量中存放的是地址</strong>（字符串第1个字符地址），绝不是将字符串放到字符指针变量中。</p></li><li><p>赋值方式。<strong>可以对字符指针变量赋值，但不能对数组名赋值</strong></p><p>可以才采用一下方法对字符指针变量赋值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *a;</span><br><span class="line">a=<span class="string">"test"</span>;<span class="comment">//a并不代表字符串，而是第一个元素地址</span></span><br></pre></td></tr></table></figure><p>不能用以下方法对字符数组名赋值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">14</span>];</span><br><span class="line">str[<span class="number">0</span>]=<span class="string">'i'</span>;<span class="comment">//对字符元素赋值，√</span></span><br><span class="line">str=<span class="string">"test"</span>;<span class="comment">//×</span></span><br></pre></td></tr></table></figure></li><li><p>初始化含义。对字符变量赋值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *a = <span class="string">"test"</span>;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *a;</span><br><span class="line">a=<span class="string">"test"</span>;</span><br></pre></td></tr></table></figure><p>而对数组初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">5</span>]=<span class="string">"test"</span>;</span><br></pre></td></tr></table></figure><p>不等价于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">5</span>];</span><br><span class="line">str[]=<span class="string">"test"</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用输入时，不能直接将内容输入指针，指针必须指向一段地址：</p><p>错误：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br></pre></td></tr></table></figure><p>正确：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *a,str[<span class="number">5</span>];</span><br><span class="line">a=str;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br></pre></td></tr></table></figure></li><li><p>字符数组中各元素的值是可以被改变的（可以对它们再赋值），但字符指针变量指向的字符串常量中的内容是不可以被取代的（不能对它们再赋值）。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[]=<span class="string">"house"</span>;</span><br><span class="line"><span class="keyword">char</span> *str=<span class="string">"house"</span>;</span><br><span class="line">a[<span class="number">2</span>]=<span class="string">'r'</span>;<span class="comment">//合法，r取代a数组元素a[2]的原值u</span></span><br><span class="line">str[<span class="number">2</span>]=<span class="string">'r'</span>;<span class="comment">//非法，字符串常量不能改变</span></span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>函数指针：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> (*p)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line">p=test;<span class="comment">//将函数入口地址赋给p</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">2</span>,b=<span class="number">3</span>;</span><br><span class="line">c=(*p)(a,b);</span><br></pre></td></tr></table></figure></li><li><p>利用函数指针向函数中传递函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> (*x1)(<span class="keyword">int</span>),<span class="keyword">int</span>(*x2)(<span class="keyword">int</span>,<span class="keyword">int</span>))</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,i=<span class="number">3</span>,j=<span class="number">5</span>;</span><br><span class="line">    a=(*x1)(i);</span><br><span class="line">    b=(*x2)(i,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回指针值的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">a</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;<span class="comment">//()优先级高于*</span></span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>指针数组和多重指针</strong>：</p><ul><li><p>一个数组其元素均为指针类型数据，称为<strong>指针数组</strong>，也就是说，指针数组中每个元素存放一个地址，相当于一个指针变量，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p[<span class="number">4</span>];</span><br></pre></td></tr></table></figure><ul><li>由于 <strong>[]</strong> 优先级高于“ <code>*</code> ”，所以 <strong>p</strong> 先和 <strong>[]</strong> 结合为一个数组，再和“ <code>*</code> ” 结合成为一个指针数组，每个数组元素相当于指针变量，可指向一个整形变量。</li><li>注意：不要写成 <code>int (*p)[4]</code>这是指向一维数组的指针变量</li><li>例题：定义一个指针数组 name，用各字符串对它进行初始化，即把各字符串中第1个字符的地址赋值给指针数组的各元素。然后用选择法排序，但不移动字符串，只改变数组的各元素指向,从小到大排序。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">char</span> *name[],<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span>  *name[],<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">    <span class="keyword">char</span> *name[]=&#123;<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>,<span class="string">"four"</span>,<span class="string">"five"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">    sort(name,n);</span><br><span class="line">    print(name,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">char</span> *name[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *temp;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        k=i;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            <span class="function"><span class="keyword">if</span> <span class="title">strcmp</span><span class="params">(name[k],name[j]&gt;<span class="number">0</span>)</span>k</span>=j; <span class="comment">//不能写成if(*name[k]&gt;*name[j])k=j;因为这样只比较了所指向字符串的第一个字符，而不是整个字符串</span></span><br><span class="line">        <span class="keyword">if</span>(k!=i)</span><br><span class="line">        &#123;temp=name[i];name[i]=name[k];name[k]=temp;&#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> *name[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        print(<span class="string">"%s\n"</span>,name[i])；<span class="comment">//%s根据地址解析字符串，不用加*引用计算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>**p</code> 从右向左读相当于 <code>*(*p)</code> 其中 <code>*p</code> 表示指针变量 而前面加 <code>*</code>则可以表示指向指针变量的指针，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *name[]=&#123;<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>,<span class="string">"four"</span>,<span class="string">"five"</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> **p;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        p=name+i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,*p);<span class="comment">//指向字符串时%s可以直接解析地址输出字符串，%d则输出地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *num[<span class="number">5</span>]=&#123;&amp;a[<span class="number">0</span>],&amp;a[<span class="number">1</span>],&amp;a[<span class="number">2</span>],&amp;a[<span class="number">3</span>],&amp;a[<span class="number">4</span>]&#125;;</span><br><span class="line">    <span class="keyword">int</span> **p,i;</span><br><span class="line">    p=num;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,**p);<span class="comment">//指向整型数组时p时指向指针型数据的指针变量</span></span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>动态分配内存</strong></p><ul><li>C99允许使用基类型为<code>void</code>的指针类型。可以定义一个基类型为<code>void</code>的指针变量（即 <code>void *</code> 型变量），它不指向任何类型的数据。请注意：不要把 “指向<code>void</code>类型” 理解为能指向 “任何的类型” 的数据，而应理解为 “指向<strong>空类型</strong>” 或 “<strong>不指向确定</strong>的类型” 的数据。在将它的值赋给另一指针变量时由系统对它进行类型转换，使之适合于被赋值的变量的类型。例如</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a =<span class="number">3</span>;<span class="comment">//定义a为整型变量</span></span><br><span class="line"><span class="keyword">int</span> *p1 = &amp;a;<span class="comment">//p1 指向int型变量</span></span><br><span class="line"><span class="keyword">char</span> *p2;<span class="comment">//p2 指向char型变量</span></span><br><span class="line"><span class="keyword">void</span> *p3;<span class="comment">//p3为无类型指针变量（基类型为viod型）</span></span><br><span class="line">p3=(<span class="keyword">void</span> *)p1;<span class="comment">//将p1的值转换为 void* 类型，然后赋值给 p3</span></span><br><span class="line">p2=(<span class="keyword">char</span> *)p3;<span class="comment">//将p3的值转换为 char* 类型，然后赋值给 p2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,* p1);<span class="comment">//合法，输出a的值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,* p2);<span class="comment">//合法，输出a的值</span></span><br><span class="line">p3=&amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,* p3);<span class="comment">//错误，p3是无指向的，不能指向a</span></span><br></pre></td></tr></table></figure><ul><li><p>注意：当把<code>void</code>指针赋值给不同基类型的指针变量（或相反）时，编译系统会自动转换，不必用户自己进行强制转换。例如：</p><p><code>p3=&amp;a;</code></p><p>相当于<code>p3=（void *）&amp;a;</code>,赋值后<code>p3</code>得到<code>a</code>的纯地址，但并不指向<code>a</code>，不能通过<code>* p3</code>输出<code>a</code>的值。</p></li></ul><p>例题：建立动态数组，输入5个学生的成绩，另外用一个函数检查其中有无低于60分的，输出不合格的成绩。</p><p>思路：用<code>malloc</code>函数开辟一个动态自由区域，用来存5个学生的成绩，会得到这个动态域第1个字节的地址，它的基类型是<code>void</code>型。用一个基类型为 <code>int</code> 的指针变量 <code>p</code> 来指向动态数组的各元素，并输出它们的值。但必须先把<code>malloc</code> 函数返回<code>void</code>指针转换为整型指针，然后赋给 <code>p1</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//包含malloc函数的stdlib.h</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">check</span> <span class="params">(<span class="keyword">int</span> *)</span></span>;<span class="comment">//声明函数可省指针</span></span><br><span class="line">    <span class="keyword">int</span> *p1,i;</span><br><span class="line">    p1=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">//开辟动态内存区，将地址转换成 int *型，然后放在p1中，malloc函数的返回值是void * 类型，要把它赋给p1，应先进行类型的转换，把该指针转换成int*型。</span></span><br><span class="line">    <span class="comment">//p1=malloc(5 * sizeof(int));//也合法，编译系统会自动转换</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,p1+i);</span><br><span class="line">    check(p1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"They are fail:"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(p[i]&lt;<span class="number">60</span>)<span class="built_in">printf</span>(<span class="string">"%d"</span>,p[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>要区别指针和指针变量。指针就是地址本身。而指针变量是用来存放地址的变量。指针变量的值是一个地址。</strong></p><p><img src="/2020/08/20/c语言复习/1.jpg" alt="指针表示"></p><p><img src="/2020/08/20/c语言复习/2.jpg" alt="指针表示2"></p><p>指针变量可以有空值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p=NUll;<span class="comment">//NULL是一个符号常量，代表整数0，malloc分配失败时也为NULL</span></span><br></pre></td></tr></table></figure><hr><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">&#125;birthday;<span class="comment">//等价</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Date</span> <span class="title">birthday</span>;</span></span><br><span class="line">    <span class="keyword">char</span> addr[<span class="number">30</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2020/08/20/c语言复习/3.jpg" alt="结构体示意图"></p><p><strong>结构体初始化：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">char</span> sex;</span><br><span class="line">        <span class="keyword">char</span> addr[<span class="number">20</span>];</span><br><span class="line">    &#125;a=&#123;<span class="number">10101</span>,<span class="string">"xiaohong"</span>,<span class="string">'M'</span>,<span class="string">"123123beijing"</span>&#125;;<span class="comment">//定义结构体变量a并初始化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"NO.:%ld\n name:%s\n sex:%c\n address:%s\n"</span>,a.num,a.name,a.sex,a.addr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对结构体中某一项初始化：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">b</span>=&#123;</span>.name=<span class="string">"Zhang Fang"</span>&#125;;</span><br></pre></td></tr></table></figure><p>在引用结构体和使用时不能使用整体结构体进行赋值、存取以及运算，必须具体到元素，如果其中有嵌套其他结构体，要一级一级找到最低级的成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">student1.num</span><br><span class="line">student1.birthday.month</span><br></pre></td></tr></table></figure><p><strong>结构体数组：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125;leader[<span class="number">3</span>]=&#123;<span class="string">"li"</span>,<span class="number">0</span>,<span class="string">"zhang"</span>,<span class="number">0</span>,<span class="string">"wang"</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">leader</span>[3]=&#123;</span><span class="string">"li"</span>,<span class="number">0</span>,<span class="string">"zhang"</span>,<span class="number">0</span>,<span class="string">"wang"</span>,<span class="number">0</span>&#125;;<span class="comment">//等价</span></span><br></pre></td></tr></table></figure><p><strong>结构体指针：</strong></p><p>如果 <code>p</code> 指向一个结构体变量 <code>stu</code> ，以下三种用法等价：</p><ul><li><code>stu</code>.成员名（如 <code>stu.num</code>）;</li><li><code>(*p)</code>.成员名(如 <code>(*p).num</code>);//不能写成<code>*p.num</code>因为<code>.</code>的优先级高于<code>*</code> 相当于<code>*(p.num)</code></li><li><code>p-&gt;</code>成员名(如 <code>p-&gt;num</code>)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> N 2<span class="comment">//不能加=</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">char</span> sex;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">    &#125;a=&#123;<span class="number">10101</span>,<span class="string">"xiaohong"</span>,<span class="string">'M'</span>,<span class="number">22</span>&#125;,b[<span class="number">3</span>]=&#123;<span class="number">10101</span>,<span class="string">"xiaohong"</span>,<span class="string">'M'</span>,<span class="number">22</span>,<span class="number">10102</span>,<span class="string">"xiaohong2"</span>,<span class="string">'M'</span>,<span class="number">27</span>,<span class="number">10103</span>,<span class="string">"xiaohong3"</span>,<span class="string">'M'</span>,<span class="number">21</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(struct Student stu)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">(struct Student stu[])</span></span>;</span><br><span class="line">    <span class="function">struct Student <span class="title">max</span><span class="params">(struct Student stu[])</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">p</span>=&amp;<span class="title">a</span>,*<span class="title">q</span>=<span class="title">b</span>;</span><span class="comment">//等价于struct Student *p,*q;p=&amp;a,q=b;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu1</span>[<span class="title">N</span>],*<span class="title">t</span>=<span class="title">stu1</span>;</span></span><br><span class="line">    </span><br><span class="line">    input(t);</span><br><span class="line">    print(t[<span class="number">0</span>]);</span><br><span class="line">print(t[<span class="number">1</span>]);</span><br><span class="line">    print(max(q));</span><br><span class="line">    print(*p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%5d %-5s %2c %4d\n"</span>,p-&gt;num,p-&gt;name,p-&gt;sex,p-&gt;age);</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">(struct Student stu[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入两位学生信息：学号、姓名、性别(M|W)、年龄\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %s %c %d"</span>,&amp;stu[i].num,&amp;stu[i].name,&amp;stu[i].sex,&amp;stu[i].age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(struct Student stu)</span></span>&#123;<span class="comment">//只传值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %s %c %d\n"</span>,stu.num,stu.name,stu.sex,stu.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct Student <span class="title">max</span><span class="params">(struct Student stu[])</span></span>&#123;<span class="comment">//传地址，返回地址 函数类型要与返回类型一致</span></span><br><span class="line"><span class="keyword">int</span> i ,m=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i =<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (stu[i].age&gt;stu[m].age)m=i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> stu[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可以采用结构体指针做实参传入函数进行处理</strong></p><hr><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">next</span>;</span><span class="comment">//结构体指针指向结构体变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题：建立一个简单链表，有3个学生数据的结点组成，要求输出各个结点的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">next</span>;</span><span class="comment">//结构体指针指向结构体变量</span></span><br><span class="line">&#125;;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">a</span>,<span class="title">b</span>,<span class="title">c</span>,*<span class="title">head</span>,*<span class="title">p</span>;</span></span><br><span class="line">     a.num=<span class="number">101</span>;a.score=<span class="number">90</span>;</span><br><span class="line">     b.bum=<span class="number">102</span>;b.score=<span class="number">89.5</span>;</span><br><span class="line">     c.num=<span class="number">103</span>;c.score=<span class="number">70.5</span>;</span><br><span class="line">     head = &amp;a;</span><br><span class="line">     a.next=&amp;b;</span><br><span class="line">     b.next=&amp;c;</span><br><span class="line">     c.next=<span class="literal">NULL</span>;</span><br><span class="line">     p=head;</span><br><span class="line">     <span class="keyword">do</span>&#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%ld %5.1f\n"</span>,p-&gt;num,p-&gt;score);</span><br><span class="line">         p=p-&gt;next;</span><br><span class="line">     &#125;<span class="keyword">while</span>(p!=<span class="literal">NULL</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>例题：建立一个有3名学生数据的单项动态链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> LEN sizeof(struct Student)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">next</span>;</span><span class="comment">//结构体指针指向结构体变量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function">struct Student *<span class="title">creat</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="comment">//定义函数，此函数返回一个指向链表头的指针，括号中的*不能省，因为返回的head是一个指针类型，</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">head</span>,*<span class="title">p1</span>,*<span class="title">p2</span>;</span></span><br><span class="line">    n=<span class="number">0</span>;</span><br><span class="line">    p1=p2=(struct Student *)<span class="built_in">malloc</span>(LEN);<span class="comment">//开辟一个新单元LEN表示结构体Student的长度</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d，%f"</span>,&amp;p1-&gt;num,&amp;p1-&gt;score);<span class="comment">//输入时%d，%f如果有，号会优先赋值运行，使用空格会使全部输入完成才向下运行</span></span><br><span class="line">    head=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1-&gt;num!=<span class="number">0</span>)&#123;<span class="comment">//输入0，0表示结束</span></span><br><span class="line">        n=n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)head=p1;</span><br><span class="line">        <span class="keyword">else</span> p2-&gt;next=p1;</span><br><span class="line">        p2=p1;</span><br><span class="line">        p1=(struct Student *)<span class="built_in">malloc</span>(LEN);<span class="comment">//括号中的*不能省，否则将强制转换为struct Student类型，而不是指针类型了</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d，%f"</span>,&amp;p1-&gt;num,&amp;p1-&gt;score);<span class="comment">//输入时%d，%f如果有，号会优先赋值运行，使用空格会使全部输入完成才向下运行</span></span><br><span class="line">    &#125;</span><br><span class="line">    p2-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span>(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">pt</span>;</span></span><br><span class="line">    pt=creat();</span><br><span class="line">    <span class="comment">//while(pt!=NULL)&#123;</span></span><br><span class="line">    <span class="comment">//    printf("\n num:%ld \nscore:%5.1f\n",pt-&gt;num,pt-&gt;score);</span></span><br><span class="line">    <span class="comment">//    pt=pt-&gt;next;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//    do&#123;</span></span><br><span class="line"><span class="comment">//    printf("\n num:%ld \nscore:%5.1f\n",pt-&gt;num,pt-&gt;score);</span></span><br><span class="line"><span class="comment">//        pt=pt-&gt;next;</span></span><br><span class="line"><span class="comment">//&#125;while(pt!=NULL);</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n num:%ld \nscore:%5.1f\n"</span>,pt-&gt;num,pt-&gt;score);</span><br><span class="line">     pt=pt-&gt;next;</span><br><span class="line">   &#125;;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h3><p>使几个不同的变量共享一段内存的结构，称为“<strong>共用体</strong>”类型的结构。<strong>在结构体中占用的内存大小是所有的数据类型的大小之和。在共用体中占用的内存大小是所有数据中最大的数据类型的值。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> Data&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">&#125;a,b,c;</span><br><span class="line"><span class="keyword">union</span> Data a,b,c;<span class="comment">//等价</span></span><br></pre></td></tr></table></figure><p>引用共用体的方式：</p><ul><li>只有先定义了共用体变量才能引用他，三个成员<strong>共用一个地址</strong>，但应注意，不能引用共用体变量，而只能引用变量中的成员。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.i</span><br><span class="line">a.ch</span><br><span class="line">a.f</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,a.i);</span><br></pre></td></tr></table></figure><ul><li>在使用公用体时要注意，在每一瞬间，共用体中只能存放一个成员，储存单元只有唯一的内容。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.i=<span class="number">97</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,a.i); <span class="comment">//(输出整数97)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,a.ch);<span class="comment">//输出‘a’,是ASCII码值对应的字符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f"</span>,a.f);<span class="comment">//输出实数0.000000</span></span><br></pre></td></tr></table></figure><ul><li>可以对共用体初始化</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> Data&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">&#125;a=&#123;<span class="number">1</span>,<span class="string">'a'</span>,<span class="number">4.5</span>&#125;;<span class="comment">//错误，不能初始化3个成员</span></span><br><span class="line"><span class="keyword">union</span> Data a=&#123;<span class="number">16</span>&#125;;<span class="comment">//正确，对第1个成员初始化</span></span><br><span class="line"><span class="keyword">union</span> Data a=&#123;.ch=<span class="string">'j'</span>&#125;;<span class="comment">//C99允许对指定一个成员初始化</span></span><br></pre></td></tr></table></figure><hr><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>如果一个变量只有几种可能的值，则可以定义为<strong>枚举类型(enum)</strong>，声明枚举类型用<strong>enum</strong>开头。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Weekday&#123;sun,mon,tue,wed,thu,fri,sat&#125;;</span><br><span class="line"><span class="keyword">enum</span> &#123;sun,mon,tue,wed,thu,fri,sat&#125;Workday,weekend;<span class="comment">//可以不声明有名字的枚举类型，而直接定义变量</span></span><br><span class="line">Weekday=mon;<span class="comment">//合法</span></span><br><span class="line">Weekday=sun;<span class="comment">//合法</span></span><br><span class="line">Weekday=monday;<span class="comment">//非法，不是枚举类中所有的变量</span></span><br></pre></td></tr></table></figure><ul><li>每个枚举元素都代表一个整数，C语言编译按定义时的顺序默认他们的值为0，1，2，3······。在上面的定义中，<strong>sun</strong> 的值为 <strong>0</strong> ，<strong>mon</strong> 的值为 <strong>1</strong>，···<strong>sat</strong> 的值为 <strong>6</strong>。如果有赋值语句：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">workday=mon;</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line">workday=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//可以使用printf输出</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,workday);<span class="comment">//输出为整数1</span></span><br><span class="line"><span class="keyword">enum</span> Weekday&#123;sun=<span class="number">7</span>,mon=<span class="number">1</span>,tue,wed,thu,fri,sat&#125;Workday,weekend;<span class="comment">//也可以自定义，指定sun为7，mon为1，以后顺序加1</span></span><br></pre></td></tr></table></figure><hr><h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><p>使用<strong>typedef</strong>声明新类型(别名)例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Integer;<span class="comment">//指定用Integer为类型名，作用与int相等。</span></span><br></pre></td></tr></table></figure><hr><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul><li>打开文件<code>fopen</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp;<span class="comment">//定义一个指向文件的指针变量fp</span></span><br><span class="line">fp=fopen(<span class="string">"a1"</span>,<span class="string">"r"</span>);<span class="comment">//将fopen函数的返回值赋给指针变量fp</span></span><br></pre></td></tr></table></figure><p><img src="/2020/08/20/c语言复习/4.jpg" alt></p><p><img src="/2020/08/20/c语言复习/5.jpg" alt></p><ul><li>使用<code>fopen</code>时如果出错，如：<strong>用”r“打开一个不存在的文件，磁盘故障，磁盘已满无法建立新文件等</strong>。此时<code>fopen</code>会返回一个空指针值 <code>NULL</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((fp=fopen(<span class="string">"file"</span>,<span class="string">"r"</span>))==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"无法打开此文件\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//关闭所有文件，中止程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关闭文件使用<code>fclose</code>,一般形式为 <code>fclose(文件指针)</code>：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fclose(fp);<span class="comment">//有返回值，成功返回0，否则返回EOF(-1)。</span></span><br></pre></td></tr></table></figure><ul><li>读写操作使用<code>fgetc(fp)</code>和<code>fputc(ch,fp)</code>:</li></ul><p><img src="/2020/08/20/c语言复习/6.jpg" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line"><span class="keyword">char</span> ch,filename[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"文件名："</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,filename);</span><br><span class="line">fp=fopen(filename,<span class="string">"w"</span>);<span class="comment">//使用“w”写时如果不存在则创建，存在相同则删除原有重新创建</span></span><br><span class="line">ch =getchar();<span class="comment">//用来接收输入的回车符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入字符串（以#结束）：\n"</span>);</span><br><span class="line">ch=getchar();</span><br><span class="line"><span class="keyword">while</span>(ch!=<span class="string">'#'</span>)&#123;</span><br><span class="line">fputc(ch,fp);<span class="comment">//向磁盘文件输出第一个字符</span></span><br><span class="line"><span class="built_in">putchar</span>(ch);<span class="comment">//将输出的字符显示在屏幕上</span></span><br><span class="line">ch=getchar();<span class="comment">//再接收字符</span></span><br><span class="line">&#125;</span><br><span class="line">fclose(fp);<span class="comment">//关闭文件</span></span><br><span class="line"><span class="built_in">putchar</span>(<span class="number">10</span>);<span class="comment">//向屏幕输出换行符</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    FILE *in,*out;</span><br><span class="line"><span class="keyword">char</span> ch,infile[<span class="number">10</span>],outfile[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入读入文件名"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,infile);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入输出文件名"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,outfile);</span><br><span class="line"><span class="keyword">if</span>((in=fopen(infile,<span class="string">"r"</span>))==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"无法打开此文件"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>((out=fopen(outfile,<span class="string">"a"</span>))==<span class="literal">NULL</span>)&#123;<span class="comment">//向文件2追加</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"无法打开此文件"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//while(!feof(in))&#123; //如果未遇到输入文件的结束标志，等价于ch！=EOF，</span></span><br><span class="line"><span class="comment">//ch=fgetc(in);//从输入文件读入一个字符，暂放在变量ch中</span></span><br><span class="line"><span class="comment">//fputc(ch,out);//将ch写到输出文件中</span></span><br><span class="line"><span class="comment">//putchar(ch);//将ch显示在屏幕上</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">    <span class="keyword">while</span>((ch = fgetc(in)) != EOF)&#123; <span class="comment">// 多执行一次会使末尾多ÿ </span></span><br><span class="line">fputc(ch,out);</span><br><span class="line"><span class="built_in">putchar</span>(ch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">putchar</span>(<span class="number">10</span>);<span class="comment">//显示完全部字符串后换行</span></span><br><span class="line">fclose(in);</span><br><span class="line">fclose(out);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输入路径时使用<code>\\</code>防止转义字符如：<code>D:\\test\\one.dat</code></li></ul><p>格式化方式读写文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(文件指针,格式字符串,输出列表);</span><br><span class="line">fsacnf(文件指针,格式字符串,输入列表);</span><br><span class="line">例如：</span><br><span class="line"><span class="built_in">fprintf</span>(fp,<span class="string">"%d,%6.2f"</span>,i,f);</span><br><span class="line">输出：</span><br><span class="line">    <span class="number">3</span>，<span class="number">4.50</span></span><br><span class="line">fsacnf(fp,<span class="string">"%d,%6.2f"</span>,&amp;i,&amp;f);</span><br></pre></td></tr></table></figure><p>用二进制防止向文件读写一组数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fread(buffer,size,conunt,fb);</span><br><span class="line">fwrite(buffer,size,count,fp);</span><br></pre></td></tr></table></figure><ul><li>其中，<code>buffer</code>是一个地址，对<code>fread</code>来说时存放文件读入的储存区地址。对<code>fwrite</code>来说，是要把此地址开始的存储区中的数据向文件输出。<code>size</code>表示要读写的字节数。<code>count</code>要读写多少个数据项(每个数据项长度为<code>size</code>)。<code>fp</code>是<code>FILE</code>类型指针。</li></ul><p>在打开文件时指定用二进制文件，这样就可以用<code>fread</code>和<code>fwrite</code>读写任何类型的信息，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fread(f,<span class="number">4</span>,<span class="number">10</span>,fp);<span class="comment">//其中f是一个float类型的数组名(代表数据首元素地址)。这个函数从fp所指向的文件中读入10个4字节的数据，存储到数组f中。</span></span><br></pre></td></tr></table></figure><p>读结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student_type</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> addr[<span class="number">30</span>];</span><br><span class="line">&#125;stud[<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">40</span>;i++)</span><br><span class="line">    fread(&amp;stud[i],<span class="keyword">sizeof</span>(struct Student_type),<span class="number">1</span>,fp);</span><br></pre></td></tr></table></figure><ul><li><code>rewind</code>函数的作用是使文件位置标记重新返回文件开头，此函数没有返回值。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewind(fp1);</span><br></pre></td></tr></table></figure><ul><li><code>fseek</code>函数改变文件位置标记，使用形式 <strong>feek(文件类型指针，位移量，起始点)</strong></li></ul><p><img src="/2020/08/20/c语言复习/7.jpg" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fseek(fp,<span class="number">100L</span>,<span class="number">0</span>);<span class="comment">//将文件位置标记向前移动到离文件开头100字节处</span></span><br><span class="line">fseek(fp,<span class="number">50L</span>,<span class="number">1</span>);<span class="comment">//将文件位置标记向前移动到离当前位置50字节处</span></span><br><span class="line">fseek(fp,<span class="number">-10L</span>,<span class="number">2</span>);<span class="comment">//将文件位置标记从文件末尾向后退10个字节</span></span><br></pre></td></tr></table></figure><ul><li><code>ftell</code>标记当前位置</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i=ftell(fp);<span class="comment">//存放当前位置</span></span><br><span class="line"><span class="keyword">if</span> (i==<span class="number">-1L</span>)<span class="built_in">printf</span>(<span class="string">"error\n"</span>);</span><br></pre></td></tr></table></figure><ul><li><code>ferror</code>读写出错检查，返回0为未出错，如果是非零值则表示出错。</li></ul><hr><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><ul><li>可以进行<code>bool</code>运算使用基本运算符号表示可以判断</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In C99 没有bool</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> BOOL;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TRUE 1;</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> FALSE 0;</span></span><br><span class="line">C++</span><br><span class="line">    </span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//using namespace std;//不建议引入完全名词空间</span></span><br><span class="line"><span class="comment">//using std::cout;</span></span><br><span class="line"><span class="comment">//using std::endl;//可以省略前面std::的书写直接用 cout&lt;&lt;"hello world C++!"&lt;&lt;endl;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> isAlpha;</span><br><span class="line">isAlpha =<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(!isAlpha)&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"isAlpha="</span>&lt;&lt;isAlpha&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="built_in">std</span>::boolalpha&lt;&lt;<span class="string">"isAlpha="</span> &lt;&lt;isAlpha&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类型转换</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C Style:(type)value</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,(<span class="keyword">int</span>)<span class="number">2.5</span>);</span><br><span class="line"></span><br><span class="line">C++ Style:<span class="keyword">static_cast</span>&lt;type&gt;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>)/<span class="number">2</span>;<span class="comment">//double/double输出0.5</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>/<span class="number">2</span>;<span class="comment">//int/int输出0</span></span><br></pre></td></tr></table></figure><ul><li>定义</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">y</span><span class="params">(<span class="number">1</span>)</span></span>;<span class="comment">//相当于int y=1;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span>&amp; rx=x;<span class="comment">//引用别名&amp;靠近类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p1;</span><br><span class="line">p1=&amp;SIZE;<span class="comment">//不能改变其值 *p1=2；</span></span><br></pre></td></tr></table></figure><ul><li>变量作用域，可在两个非嵌套块中声明两个<code>i</code><ul><li>当局部变量与全局冲突时，可使用<code>::</code>访问全局变量</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> v1=<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v1=<span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"局部变量v1:"</span>&lt;&lt;v1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"全局变量v1："</span>&lt;&lt;::v1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        x+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        y+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"x="</span>&lt;&lt;x&lt;&lt;<span class="string">"y="</span>&lt;&lt;y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>重载函数，同名函数，传参类型不同，编译器会自动匹配。</p></li><li><p>默认参数,要后置,这样调用时不会有歧义。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> b,<span class="keyword">double</span> a=<span class="number">1.0</span>)</span></span>&#123;&#125;;</span><br><span class="line">test(<span class="number">3</span>);</span><br><span class="line">test(<span class="number">3</span>,<span class="number">4.0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y =<span class="number">10</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+<span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    add(<span class="number">1</span>);<span class="comment">//歧义，两个都可以匹配</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h3><ul><li>C++中通过运算符<code>new</code>申请动态内存<ul><li>如果申请成功，返回指定类型内存的地址；</li><li>如果申请失败，返回空指针（整数0，C++中废弃了NULL）；</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> &lt;类型名&gt;（初值）；<span class="comment">//申请一个变量的空间</span></span><br><span class="line"><span class="keyword">new</span> &lt;类型名&gt;[常量表达式]；<span class="comment">//申请数组</span></span><br></pre></td></tr></table></figure><ul><li>动态内存使用完毕后，要用delete运算符来释放。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> &lt;指针名&gt;；<span class="comment">//删除一个变量的空间</span></span><br><span class="line"><span class="keyword">delete</span> []&lt;指针名&gt;；<span class="comment">//删除一个数组空间</span></span><br></pre></td></tr></table></figure><p><img src="/2020/08/20/c语言复习/8.jpg" alt></p><ul><li>常量指针 VS 指针常量<ul><li>在前先读，在前不变，<code>const</code>在谁前面谁就不允许被改变。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * X;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> y;</span><br></pre></td></tr></table></figure><p><img src="/2020/08/20/c语言复习/9.jpg" alt></p><hr><h3 id="C-数据类型"><a href="#C-数据类型" class="headerlink" title="C++数据类型"></a>C++数据类型</h3><ul><li>C++中数据类型分布</li></ul><p><img src="/2020/08/20/c语言复习/10.jpg" alt></p><ul><li><code>Constructors</code>构造函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:<span class="comment">//表示公共可以被其他调用内部，默认是private</span></span><br><span class="line">    <span class="keyword">int</span> test;</span><br><span class="line">    </span><br><span class="line">    Name()&#123;</span><br><span class="line">        test =<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Name(<span class="keyword">double</span> newTest)&#123;</span><br><span class="line">        test=newTest;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> test*<span class="number">2</span>;<span class="comment">//直接访问了类中的成员变量test，并没有传</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="comment">//不能忘</span></span><br></pre></td></tr></table></figure><p>项目属性参数C++中加<code>-O0</code>表示不做任何优化</p><hr><h3 id="类的声明和使用"><a href="#类的声明和使用" class="headerlink" title="类的声明和使用"></a>类的声明和使用</h3><ul><li>类的声明和实现：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Test.cpp<span class="comment">//函数实现::-》二元作用域分隔符，域分隔符</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"Test.h"</span></span></span><br><span class="line"></span><br><span class="line">Test::Test()&#123;</span><br><span class="line">    num=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test::Test(<span class="keyword">double</span> newNum)&#123;</span><br><span class="line">    num=newNum;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">double</span> Test::getNum()&#123;</span><br><span class="line">    <span class="keyword">return</span> num*<span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">Test.h<span class="comment">//类声明，包括成员声明和函数声明</span></span><br><span class="line">Class Test&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> num;</span><br><span class="line">    </span><br><span class="line">    Test();</span><br><span class="line">    </span><br><span class="line">    Test(<span class="keyword">double</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getNum</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">TestMain.cpp<span class="comment">//主函数</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"Test.h"</span></span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Test test1;</span><br><span class="line">    <span class="function">Test <span class="title">test</span><span class="params">(<span class="number">5.0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"test1的数据:"</span>&lt;&lt;test1.num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"test2的数据:"</span>&lt;&lt;test2.num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    test2.num=<span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"test2的数据改变后："</span>&lt;&lt;test2.num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="C-指针"><a href="#C-指针" class="headerlink" title="C++指针"></a>C++指针</h3><ul><li>用指针访问对象</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Test test1;</span><br><span class="line">Test *ptest=&amp;test1;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"test1的数据:"</span>&lt;&lt; (*ptest).num &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"test1的数据:"</span>&lt;&lt; ptest-&gt;num &lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><ul><li>在堆区创建对象（不会在执行完后被从栈区销毁）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Test *ptest1=<span class="keyword">new</span> Test();</span><br><span class="line">Test *ptest1=<span class="keyword">new</span> Test(<span class="number">5.0</span>);</span><br><span class="line"><span class="comment">//程序结束时动态对象会被销毁，或者</span></span><br><span class="line"><span class="keyword">delete</span> ptest1;<span class="comment">//用delete显式销毁</span></span><br></pre></td></tr></table></figure><hr><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> </span></span><br><span class="line"><span class="built_in">string</span> newString;<span class="comment">//构造一个空字符串</span></span><br><span class="line"><span class="function">streing <span class="title">mssage</span><span class="params">(<span class="string">"hello world"</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span> charArray[]=&#123;<span class="string">'H'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>,<span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">massage</span><span class="params">(charArray)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//追加新值append</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"test"</span>)</span></span>;</span><br><span class="line">str.append(<span class="string">"qwe"</span>);<span class="comment">//向后添加</span></span><br><span class="line">str.append(<span class="string">"qwezxc"</span>，<span class="number">3</span>，<span class="number">1</span>);<span class="comment">//从3号index位开始，向后2个字符zx添加进去</span></span><br><span class="line">str.append(<span class="string">"qwezxc"</span>，<span class="number">3</span>);<span class="comment">//将qwez向后加</span></span><br><span class="line">str.apped(<span class="number">3</span>,<span class="string">'G'</span>);<span class="comment">//向后加GGG</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//赋新值assign</span></span><br><span class="line">str.assign(<span class="string">"newchar"</span>);</span><br><span class="line"></span><br><span class="line">at(index);<span class="comment">//返回当前字符串中index位字符</span></span><br><span class="line">clear();<span class="comment">//清空字符串</span></span><br><span class="line">erase(index,n);<span class="comment">//删除字符串从index开始的n个字符</span></span><br><span class="line">empty();<span class="comment">//检测字符串是否为空，return 1</span></span><br><span class="line">compare();<span class="comment">//比较字符串s1.compare(s2),相等=0</span></span><br><span class="line">substr(index,n);<span class="comment">//字符串从index开始的n个字符，只有一个整数时为从该位置开始到末尾的所有字符</span></span><br><span class="line">find(<span class="string">"co"</span>,n);<span class="comment">//查找子串，n为起始位置</span></span><br><span class="line">insert();<span class="comment">//插入字符串</span></span><br><span class="line">replace();<span class="comment">//替换字符串中子串</span></span><br><span class="line">str.replace(<span class="number">3</span>,<span class="number">4</span>,<span class="string">"C++"</span>);<span class="comment">//从3号位置开始替换后面的4个字符串 C++3个后面还有个'\0'一共4个字符</span></span><br></pre></td></tr></table></figure><ul><li>字符串运算符</li></ul><p><img src="/2020/08/20/c语言复习/11.jpg" alt></p><hr><h3 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Test2.cpp<span class="comment">//函数实现::-》二元作用域分隔符，域分隔符</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"Test.h"</span></span></span><br><span class="line">Test::Test()&#123;</span><br><span class="line">    num=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test::Test(<span class="keyword">int</span> newNum)&#123;</span><br><span class="line">    num=newNum;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> Test::getNum()&#123;</span><br><span class="line">    <span class="keyword">return</span> num*<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Test::setNum(<span class="keyword">int</span> newNum)&#123;</span><br><span class="line">    num=newNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Test.h<span class="comment">//类声明，包括成员声明和函数声明</span></span><br><span class="line">Class Test&#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">double</span> num; </span><br><span class="line">    Test(); </span><br><span class="line">    Test(<span class="keyword">int</span>);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;<span class="comment">//不能忘</span></span><br></pre></td></tr></table></figure><hr><h3 id="变量作用域和this指针"><a href="#变量作用域和this指针" class="headerlink" title="变量作用域和this指针"></a>变量作用域和this指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Test();</span><br><span class="line">    Test(<span class="keyword">double</span> num)&#123;<span class="comment">//局部变量与私有变量冲突</span></span><br><span class="line">        <span class="comment">//num=num;</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;num=num;<span class="comment">//this引用当前函数的调用对象,私有变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> num;<span class="comment">//或使用规范，私有类变量后加_</span></span><br><span class="line">    <span class="keyword">double</span> num_;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>对象数组</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Test testarray[<span class="number">10</span>];<span class="comment">//相当于testarray[1].getNum()</span></span><br><span class="line">Test testarray[<span class="number">3</span>]=&#123;</span><br><span class="line">    Test(<span class="number">3</span>);<span class="comment">//匿名函数赋值</span></span><br><span class="line">    Test(<span class="number">4</span>);</span><br><span class="line">    Test(<span class="number">5</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于SSD目标检测网络的树莓派控制系统（三）</title>
      <link href="/2020/05/12/%E5%9F%BA%E4%BA%8ESSD%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%BD%91%E7%BB%9C%E7%9A%84%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2020/05/12/%E5%9F%BA%E4%BA%8ESSD%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%BD%91%E7%BB%9C%E7%9A%84%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="基于PyQt5的SSD目标检测软件（三）"><a href="#基于PyQt5的SSD目标检测软件（三）" class="headerlink" title="基于PyQt5的SSD目标检测软件（三）"></a>基于PyQt5的SSD目标检测软件（三）</h1><h4 id="续上节。。。。"><a href="#续上节。。。。" class="headerlink" title="续上节。。。。"></a>续上节。。。。</h4><h4 id="2-训练部分"><a href="#2-训练部分" class="headerlink" title="2. 训练部分"></a>2. 训练部分</h4><h5 id="2-1-真实框得处理"><a href="#2-1-真实框得处理" class="headerlink" title="2.1 真实框得处理"></a>2.1 真实框得处理</h5><p>​        预测部分实际上是没有计算loss的向前传播，主要是通过模型进行预测结果，而训练过程主要通过反向传播来修正权重减小整体的成本loss和精度loss从而使模型更加准确。</p><p>​        在预测部分，每个特征层的预测结果，<strong>num_priors x 4 的卷积</strong> 用于预测 <strong>该特征层上</strong> <strong>每一个网格点上 每一个先验框</strong> 的 <strong>微调</strong> 情况(<strong>bounding box regression</strong>（<strong>边界框回归 在训练中 微调边界框大小匹配真实框)</strong>)。 </p><p>​        所以说，我们直接利用SSD网络预测到的结果只是直接<strong>匹配相同类别</strong>所得到的原来<strong>初始化先验框</strong>的结果，而我们需要的是进行<strong>bounding box regression 回归后</strong> <strong>调整过的准确预测框的位置。</strong></p><p>​        而在训练的时候，<strong>我们需要计算loss（分类loss和边界框回归loss（IOU））函数，这个loss函数是相对于ssd网络的预测结果的</strong>。我们需要把图片输入<strong>到当前的ssd网络中，得到预测结果；同时还需要把真实框的信息，进行编码</strong>，这个编码是把<strong>真实框的位置信息格式转化为ssd预测结果的格式信息</strong>。 </p><p>​         我们需要找到 <strong>每一张用于训练的图片</strong>的<strong>每一个真实框对应的先验框</strong>，并通过 <strong>回归预测的方法</strong> 让模型学会如何调整<strong>预测生成的先验框</strong>才能得到<strong>真实框对应的先验框</strong>。</p><p><strong>从预测结果获得真实框的过程被称作解码，而从真实框获得预测结果的过程就是编码的过程。</strong> </p><a id="more"></a><p>​         因此我们只需要将<strong>解码过程逆过来就是编码过程了。</strong> </p><p><strong>代码实现</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode</span><span class="params">(matched, priors, variances)</span>:</span></span><br><span class="line">    g_cxcy = (matched[:, :<span class="number">2</span>] + matched[:, <span class="number">2</span>:])/<span class="number">2</span> - priors[:, :<span class="number">2</span>]</span><br><span class="line">    g_cxcy /= (variances[<span class="number">0</span>] * priors[:, <span class="number">2</span>:])</span><br><span class="line">    g_wh = (matched[:, <span class="number">2</span>:] - matched[:, :<span class="number">2</span>]) / priors[:, <span class="number">2</span>:]</span><br><span class="line">    g_wh = torch.log(g_wh) / variances[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> torch.cat([g_cxcy, g_wh], <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>​        训练时选取  <strong>IOU最大的框</strong>  做为  <strong>预测生成的先验框</strong>。</p><p>​         因此我们还要经过一次筛选，将上述代码获得的<strong>真实框对应的所有的iou较大先验框的预测结果</strong>中，iou最大的那个筛选出来。 </p><p><strong>代码实现</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(threshold, truths, priors, variances, labels, loc_t, conf_t, idx)</span>:</span></span><br><span class="line">    <span class="comment"># 计算所有的先验框和真实框的重合程度</span></span><br><span class="line">    overlaps = jaccard(</span><br><span class="line">        truths,</span><br><span class="line">        point_form(priors)</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 所有真实框和先验框的最好重合程度</span></span><br><span class="line">    <span class="comment"># [truth_box,1]</span></span><br><span class="line">    best_prior_overlap, best_prior_idx = overlaps.max(<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">    best_prior_idx.squeeze_(<span class="number">1</span>)</span><br><span class="line">    best_prior_overlap.squeeze_(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 所有先验框和真实框的最好重合程度</span></span><br><span class="line">    <span class="comment"># [1,prior]</span></span><br><span class="line">    best_truth_overlap, best_truth_idx = overlaps.max(<span class="number">0</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">    best_truth_idx.squeeze_(<span class="number">0</span>)</span><br><span class="line">    best_truth_overlap.squeeze_(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 找到与真实框重合程度最好的先验框，用于保证每个真实框都要有对应的一个先验框</span></span><br><span class="line">    best_truth_overlap.index_fill_(<span class="number">0</span>, best_prior_idx, <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 对best_truth_idx内容进行设置</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(best_prior_idx.size(<span class="number">0</span>)):</span><br><span class="line">        best_truth_idx[best_prior_idx[j]] = j</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 找到每个先验框重合程度最好的真实框</span></span><br><span class="line">    matches = truths[best_truth_idx]          <span class="comment"># Shape: [num_priors,4]</span></span><br><span class="line">    conf = labels[best_truth_idx] + <span class="number">1</span>         <span class="comment"># Shape: [num_priors]</span></span><br><span class="line">    <span class="comment"># 如果重合程度小于threhold则认为是背景</span></span><br><span class="line">    conf[best_truth_overlap &lt; threshold] = <span class="number">0</span>  <span class="comment"># label as background</span></span><br><span class="line">    loc = encode(matches, priors, variances)</span><br><span class="line">    loc_t[idx] = loc    <span class="comment"># [num_priors,4] encoded offsets to learn</span></span><br><span class="line">    conf_t[idx] = conf  <span class="comment"># [num_priors] top class label for each prior</span></span><br></pre></td></tr></table></figure><h5 id="2-2-利用处理完的真实框与对应图片的预测结果计算loss"><a href="#2-2-利用处理完的真实框与对应图片的预测结果计算loss" class="headerlink" title="2.2 利用处理完的真实框与对应图片的预测结果计算loss"></a>2.2 利用处理完的真实框与对应图片的预测结果计算loss</h5><p> loss的计算分为三个部分：<br> 1、获取所有正标签的框的预测结果的回归loss。<br> 2、获取所有正标签的种类的预测结果的交叉熵loss。<br> 3、获取一定负标签的种类的预测结果的交叉熵loss。 </p><p>​        由于在ssd的训练过程中，<strong>正负样本极其不平衡，即 存在对应真实框的先验框可能只有十来个，但是不存在对应真实框的负样本却有几千个，这就会导致负样本的loss值极大</strong>,因此<strong>我们可以考虑减少负样本的选取，对于ssd的训练来讲，常见的情况是取三倍正样本数量的负样本用于训练</strong>。这个三倍呢，也可以修改，调整成自己喜欢的数字。 </p><p><strong>代码实现</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiBoxLoss</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_classes, overlap_thresh, prior_for_matching,</span></span></span><br><span class="line"><span class="function"><span class="params">                 bkg_label, neg_mining, neg_pos, neg_overlap, encode_target,</span></span></span><br><span class="line"><span class="function"><span class="params">                 use_gpu=False)</span>:</span></span><br><span class="line">        super(MultiBoxLoss, self).__init__()</span><br><span class="line">        self.use_gpu = use_gpu</span><br><span class="line">        self.num_classes = num_classes</span><br><span class="line">        self.threshold = overlap_thresh</span><br><span class="line">        self.background_label = bkg_label</span><br><span class="line">        self.encode_target = encode_target</span><br><span class="line">        self.use_prior_for_matching = prior_for_matching</span><br><span class="line">        self.do_neg_mining = neg_mining</span><br><span class="line">        self.negpos_ratio = neg_pos</span><br><span class="line">        self.neg_overlap = neg_overlap</span><br><span class="line">        self.variance = Config[<span class="string">'variance'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, predictions, targets)</span>:</span></span><br><span class="line">        <span class="comment"># 回归信息，置信度，先验框</span></span><br><span class="line">        loc_data, conf_data, priors = predictions</span><br><span class="line">        <span class="comment"># 计算出batch_size</span></span><br><span class="line">        num = loc_data.size(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 取出所有的先验框</span></span><br><span class="line">        priors = priors[:loc_data.size(<span class="number">1</span>), :]</span><br><span class="line">        <span class="comment"># 先验框的数量</span></span><br><span class="line">        num_priors = (priors.size(<span class="number">0</span>))</span><br><span class="line">        num_classes = self.num_classes</span><br><span class="line">        <span class="comment"># 创建一个tensor进行处理</span></span><br><span class="line">        loc_t = torch.Tensor(num, num_priors, <span class="number">4</span>)</span><br><span class="line">        conf_t = torch.LongTensor(num, num_priors)</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> range(num):</span><br><span class="line">            <span class="comment"># 获得框</span></span><br><span class="line">            truths = targets[idx][:, :<span class="number">-1</span>].data</span><br><span class="line">            <span class="comment"># 获得标签</span></span><br><span class="line">            labels = targets[idx][:, <span class="number">-1</span>].data</span><br><span class="line">            <span class="comment"># 获得先验框</span></span><br><span class="line">            defaults = priors.data</span><br><span class="line">            <span class="comment"># 找到标签对应的先验框 ！！！</span></span><br><span class="line">            match(self.threshold, truths, defaults, self.variance, labels,</span><br><span class="line">                  loc_t, conf_t, idx)</span><br><span class="line">        <span class="comment"># if self.use_gpu:</span></span><br><span class="line">        <span class="comment">#     loc_t = loc_t.cuda()</span></span><br><span class="line">        <span class="comment">#     conf_t = conf_t.cuda()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 所有conf_t&gt;0的地方，代表内部包含物体</span></span><br><span class="line">        pos = conf_t &gt; <span class="number">0</span></span><br><span class="line">        <span class="comment"># 求和得到每一个图片内部有多少正样本</span></span><br><span class="line">        num_pos = pos.sum(dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 回归</span></span><br><span class="line">        <span class="comment"># 计算回归loss，使用正样本的先验框进行计算，背景框无意义</span></span><br><span class="line">        pos_idx = pos.unsqueeze(pos.dim()).expand_as(loc_data)</span><br><span class="line">        loc_p = loc_data[pos_idx].view(<span class="number">-1</span>, <span class="number">4</span>)</span><br><span class="line">        loc_t = loc_t[pos_idx].view(<span class="number">-1</span>, <span class="number">4</span>)</span><br><span class="line">        loss_l = F.smooth_l1_loss(loc_p, loc_t, reduction = <span class="string">'sum'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算置信度loss，分类</span></span><br><span class="line">        <span class="comment"># 转化形式</span></span><br><span class="line">        batch_conf = conf_data.view(<span class="number">-1</span>, self.num_classes)</span><br><span class="line">        <span class="comment"># 你可以把softmax函数看成一种接受任何数字并转换为概率分布的非线性方法</span></span><br><span class="line">        <span class="comment"># 获得每个框预测到真实框的类的概率</span></span><br><span class="line">        loss_c = log_sum_exp(batch_conf) - batch_conf.gather(<span class="number">1</span>, conf_t.view(<span class="number">-1</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="comment"># 对预测结果分布进行修改 批量归一化</span></span><br><span class="line">        loss_c = loss_c.view(num, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        loss_c[pos] = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 获得每一张图新的softmax的结果</span></span><br><span class="line">        _, loss_idx = loss_c.sort(<span class="number">1</span>, descending=<span class="literal">True</span>)</span><br><span class="line">        _, idx_rank = loss_idx.sort(<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 计算每一张图的正样本数量</span></span><br><span class="line">        num_pos = pos.long().sum(<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># 限制负样本数量</span></span><br><span class="line">        num_neg = torch.clamp(self.negpos_ratio*num_pos, max=pos.size(<span class="number">1</span>)<span class="number">-1</span>)</span><br><span class="line">        neg = idx_rank &lt; num_neg.expand_as(idx_rank)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算正样本的loss和负样本的loss</span></span><br><span class="line">        <span class="comment"># 平衡正负样本1：3 8732个框 可能只有十几个正样本</span></span><br><span class="line">        pos_idx = pos.unsqueeze(<span class="number">2</span>).expand_as(conf_data)</span><br><span class="line">        neg_idx = neg.unsqueeze(<span class="number">2</span>).expand_as(conf_data)</span><br><span class="line">        conf_p = conf_data[(pos_idx+neg_idx).gt(<span class="number">0</span>)].view(<span class="number">-1</span>, self.num_classes)</span><br><span class="line">        targets_weighted = conf_t[(pos+neg).gt(<span class="number">0</span>)]</span><br><span class="line">        <span class="comment"># loss_c = F.cross_entropy(conf_p, targets_weighted, size_average=False) size_average (bool, optional) – 默认情况下，是mini-batchloss的平均值，然而，如果size_average=False，则是mini-batchloss的总和</span></span><br><span class="line">        loss_c = F.cross_entropy(conf_p, targets_weighted, reduction = <span class="string">'sum'</span>) <span class="comment">#改版后使用sum</span></span><br></pre></td></tr></table></figure><h3 id="四、数据集准备"><a href="#四、数据集准备" class="headerlink" title="四、数据集准备"></a>四、数据集准备</h3><p>​        本项目采用得是VOC数据集格式具体存放在 <code>VOCdevkit</code>文件夹下，其中<code>voc2ssd.py</code>为综合<code>VOCdevkit/VOC2007/JPEGImages</code>文件夹下图像文件及<code>VOCdevkit/VOC2007/Annotations</code>下标签文件生成索引文件并存放与<code>VOCdevkit/VOC2007/ImageSets/Main</code>的txt文件中分别为训练集/测试集/验证集的索引，而<code>uitils/voc_annotation.py</code>为生成索引绝对路径在<code>2007_test.txt/2007_train.txt/2007_val.txt</code>中</p><p>​        对图像生成标签文件的软件使用labelimg进行目标检测数据集标注，labelimg是基于pyqt的一个软件，使用很方便，用以下命令即可安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install labelimg</span><br></pre></td></tr></table></figure><p>运行直接在shell内运行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">labelimg</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> deep learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于SSD目标检测网络的树莓派控制系统（二）</title>
      <link href="/2020/05/11/%E5%9F%BA%E4%BA%8ESSD%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%BD%91%E7%BB%9C%E7%9A%84%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/05/11/%E5%9F%BA%E4%BA%8ESSD%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%BD%91%E7%BB%9C%E7%9A%84%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="基于PyQt5的SSD目标检测软件（二）"><a href="#基于PyQt5的SSD目标检测软件（二）" class="headerlink" title="基于PyQt5的SSD目标检测软件（二）"></a>基于PyQt5的SSD目标检测软件（二）</h1><h2 id="SSD-目标检测网络详解"><a href="#SSD-目标检测网络详解" class="headerlink" title="SSD 目标检测网络详解"></a>SSD 目标检测网络详解</h2><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>​        这次SSD目标检测网络是基于pytorch版本的并且我的代码中去掉了cuda加速(<del>部分代码残留没有删除</del>)，原因很简单，因为我得AMD不YES了，等有机会用intel的显卡再说吧，b站up主的原版代码有加速部分可以参考增加，不过仅使用cpu硬算这样效率确实降低了很多，有待以后更改。</p><h3 id="二、SSD是什么"><a href="#二、SSD是什么" class="headerlink" title="二、SSD是什么?"></a>二、SSD是什么?</h3><p>​        目标检测近年来已经取得了很多重要的发展，那么主流的算法也主要分为两个部分：</p><ul><li>Two-stage方法，如R-CNN系列算法，其主要思路是先通过启发式方法（ selective search ） 或者CNN网络（RPN)产生一系列稀疏的候选框，然后对这些候选框进行分类与回归，因为中间使用了一些图像分割方法判别特征后进行候选框的生成，所以two-stage方法的优势是准确度高；</li><li>One-stage方法，如Yolo 和SSD ， YOLO在卷积层后接全连接层，即检测时只利用了最高层Feature maps（包括Faster RCNN也是如此），SSD主要思路是对图片进行均匀的分割如38<em>38而后对每一块区域进行抽样，抽样时可以采用不同尺度和长宽比， 然后利用CNN提取特征后<em>*同时</em></em>进行分类与回归，整个过程只需要一步，所以其优势是速度快，但是均匀的密集采样的一个重要缺点是训练比较困难，这主要是因为正样本与负样本（背景）极其不均衡，导致模型准确度稍低。 </li></ul><p>​        <strong>SSD全称为 Single Shot MultiBox Detector，Single shot说明SSD算法属于one-stage方法，MultiBox说明SSD算法基于多框预测。</strong> SSD是Wei Liu在ECCV 2016上提出的一种目标检测算法， 截至目前是主要的检测框架之一，相比Faster RCNN有明显的速度优势，相比YOLO又有明显的mAP优势（不过已经被CVPR 2017的YOLO9000超越）。 </p><a id="more"></a><h3 id="三、代码实现及原理介绍"><a href="#三、代码实现及原理介绍" class="headerlink" title="三、代码实现及原理介绍"></a>三、代码实现及原理介绍</h3><h4 id="1-预测部分"><a href="#1-预测部分" class="headerlink" title="1.预测部分"></a>1.预测部分</h4><h5 id="1-1-主干网络原理介绍"><a href="#1-1-主干网络原理介绍" class="headerlink" title="1.1 主干网络原理介绍"></a>1.1 主干网络原理介绍</h5><p>​        SSD网络模型是由VGG16网络修改而来，而VGG是由Simonyan和Ziss而man在文献《Very Deep Convolutional Networks for Large Scale Image Recognition》提出的卷积神经网络模型，其名称来源于作者所在的牛津大学视觉几何组（ Visual Geometry Group ）的缩写。</p><p><strong>VGG16的原理图如下所示：</strong></p><p><img src="/2020/05/11/基于SSD目标检测网络的树莓派控制系统（二）/VGG16.png" alt="VGG16"></p><p><strong>1、一张原始图片被resize到(224,224,3)。</strong><br><strong>2、conv1两次[3,3]卷积网络，输出的特征层为64，输出为(224,224,64)，再2X2最大池化，输出net为(112,112,64)。</strong><br><strong>3、conv2两次[3,3]卷积网络，输出的特征层为128，输出net为(112,112,128)，再2X2最大池化，输出net为(56,56,128)。</strong><br><strong>4、conv3三次[3,3]卷积网络，输出的特征层为256，输出net为(56,56,256)，再2X2最大池化，输出net为(28,28,256)。</strong><br><strong>5、conv4三次[3,3]卷积网络，输出的特征层为512，输出net为(28,28,512)，再2X2最大池化，输出net为(14,14,512)。</strong><br><strong>6、conv5三次[3,3]卷积网络，输出的特征层为512，输出net为(14,14,512)，再2X2最大池化，输出net为(7,7,512)。</strong><br><strong>7、利用卷积的方式模拟全连接层，效果等同，输出net为(1,1,4096)。共进行两次。</strong><br><strong>8、利用卷积的方式模拟全连接层，效果等同，输出net为(1,1,1000)。</strong><br><strong>最后输出的就是每个类的预测。</strong></p><h2 id="SSD网络模型图"><a href="#SSD网络模型图" class="headerlink" title="SSD网络模型图"></a><center><b><font size="5">SSD网络模型图</font></b></center></h2><p><img src="/2020/05/11/基于SSD目标检测网络的树莓派控制系统（二）/原理图.png" alt="SSD网络模型"></p><p>其中<strong>不同</strong>的地方在于：</p><ul><li><strong>将VGG16的FC6和FC7层转化为卷积层</strong></li><li><strong>去掉所有的Dropout层和FC8层</strong></li><li><strong>新增了Conv6、Conv7、Conv8、Conv9层</strong></li></ul><h5 id="1-2-SSD-VGG-前"><a href="#1-2-SSD-VGG-前" class="headerlink" title="1.2 SSD_VGG(前)"></a>1.2 SSD_VGG(前)</h5><p><img src="/2020/05/11/基于SSD目标检测网络的树莓派控制系统（二）/SSD2.png" alt="SSD原理图"></p><p>如图所示，当图片输入进网络模型时，首先经过<strong>VGG16网络（Conv1-FC7）</strong>然后进行<strong>特征提取</strong>进行<strong>分类和回归预测</strong>，紧接着进入增加的几个<strong>卷积层（Conv6-Conv9</strong>），<strong>每经过一层</strong>便进行一次<strong>特征提取</strong>进行<strong>分类和回归预测</strong>：</p><p><strong>a、输入一张图片后，被Resize到300x300x3的shape</strong></p><p><strong>b、Conv1，经过两次 [3,3] 卷积，输出的特征层为64，输出为(300,300,64)，再2X2最大池化，输出net为(150,150,64)。</strong></p><p><strong>c、Conv2，经过两次 [3,3] 卷积，输出的特征层为128，输出net为(150,150,128)，再2X2最大池化，输出net为(75,75,128)。</strong></p><p><strong>d、Conv3，经过三次 [3,3] 卷积，输出的特征层为256，输出net为(75,75,256)，再2X2最大池化，输出net为(38,38,256)。</strong></p><p><strong>e、Conv4，经过三次 [3,3] 卷积，输出的特征层为512，输出net为(38,38,512)，再2X2最大池化，输出net为(19,19,512)。</strong></p><p><strong>f、Conv5，经过三次 [3,3] 卷积，输出的特征层为512，输出net为(19,19,512)，再2X2最大池化，输出net为(19,19,512)。</strong></p><p><strong>g、利用卷积代替全连接层，进行了两次 [3,3] 卷积，输出的特征层为1024，因此输出的net为(19,19,1024)。（从这里往前都是VGG的结构）</strong></p><p><img src="/2020/05/11/基于SSD目标检测网络的树莓派控制系统（二）/SSD_VGG.jpg" alt="SSD_VGG"></p><p><strong>代码实现</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">base = [<span class="number">64</span>, <span class="number">64</span>, <span class="string">'M'</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="string">'M'</span>, <span class="number">256</span>, <span class="number">256</span>, <span class="number">256</span>, <span class="string">'C'</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="string">'M'</span>,</span><br><span class="line">            <span class="number">512</span>, <span class="number">512</span>, <span class="number">512</span>]</span><br><span class="line"><span class="comment"># 300,300,3-&gt; input</span></span><br><span class="line"><span class="comment"># 实际上从0层开始算 输入层不算 整体减1</span></span><br><span class="line"><span class="comment"># Conv1_1 300,300,64 -&gt;1</span></span><br><span class="line"><span class="comment"># ReLU -&gt;2</span></span><br><span class="line"><span class="comment"># Conv1_2 300,300,64 -&gt;3</span></span><br><span class="line"><span class="comment"># ReLU -&gt;4</span></span><br><span class="line"><span class="comment"># Pooling1 150,150,64 -&gt;5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Conv2_1 150,150,128 -&gt;6</span></span><br><span class="line"><span class="comment"># ReLU -&gt;7</span></span><br><span class="line"><span class="comment"># Conv2_2 150,150,128 -&gt;8</span></span><br><span class="line"><span class="comment"># ReLU -&gt;9</span></span><br><span class="line"><span class="comment"># Pooling2 75,75,128 -&gt;10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Conv3_1 75,75,256 -&gt;11</span></span><br><span class="line"><span class="comment"># ReLU -&gt;12</span></span><br><span class="line"><span class="comment"># Conv3_2 75,75,256 -&gt;13</span></span><br><span class="line"><span class="comment"># ReLU -&gt;14</span></span><br><span class="line"><span class="comment"># Conv3_3 75,75,256 -&gt; 15    注意75是单数 最大池化默认ceil==false 会省略单数边缘-&gt;37</span></span><br><span class="line"><span class="comment"># ReLU -&gt;16</span></span><br><span class="line"><span class="comment"># Pooling3 38,38,256 -&gt;17</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Conv4_1 38,38,512 -&gt; 18</span></span><br><span class="line"><span class="comment"># ReLU -&gt; 19</span></span><br><span class="line"><span class="comment"># Conv4_2 38,38,512 -&gt; 20</span></span><br><span class="line"><span class="comment"># ReLU -&gt; 21</span></span><br><span class="line"><span class="comment"># Conv4_3 38,38,512 -&gt; 22 做分类预测</span></span><br><span class="line"><span class="comment"># ReLU -&gt; 23</span></span><br><span class="line"><span class="comment"># L2Norm -&gt; 24</span></span><br><span class="line"><span class="comment"># Pooling4 19,19,512 -&gt; 25 同上理</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Conv5_1 19,19,512 -&gt; 26</span></span><br><span class="line"><span class="comment"># ReLU -&gt; 27</span></span><br><span class="line"><span class="comment"># Conv5_2 19,19,512 -&gt; 28</span></span><br><span class="line"><span class="comment"># ReLU -&gt; 29</span></span><br><span class="line"><span class="comment"># Conv5_3 19,19,512 -&gt; 30</span></span><br><span class="line"><span class="comment"># ReLU -&gt; 31</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pools 19,19,512 -&gt; 32</span></span><br><span class="line"><span class="comment"># Conv6 19,19,1024 -&gt; 33 具有膨胀率 模拟全连接</span></span><br><span class="line"><span class="comment"># ReLU -&gt; 34</span></span><br><span class="line"><span class="comment"># Conv7 19,19,1024 -&gt; 35 做分类预测</span></span><br><span class="line"><span class="comment"># ReLU -&gt; 36</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vgg</span><span class="params">(i)</span>:</span></span><br><span class="line">    layers = []</span><br><span class="line">    <span class="comment"># i = 3 三通道</span></span><br><span class="line">    in_channels = i</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> base:</span><br><span class="line">        <span class="keyword">if</span> v == <span class="string">'M'</span>:</span><br><span class="line">            layers += [nn.MaxPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>)]</span><br><span class="line">        <span class="keyword">elif</span> v == <span class="string">'C'</span>:</span><br><span class="line">            layers += [nn.MaxPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>, ceil_mode=<span class="literal">True</span>)]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            conv2d = nn.Conv2d(in_channels, v, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">            layers += [conv2d, nn.ReLU(inplace=<span class="literal">True</span>)]</span><br><span class="line">            in_channels = v</span><br><span class="line">    pool5 = nn.MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>)</span><br><span class="line">    conv6 = nn.Conv2d(<span class="number">512</span>, <span class="number">1024</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">6</span>, dilation=<span class="number">6</span>) <span class="comment"># 具有膨胀率 模拟全连接</span></span><br><span class="line">    conv7 = nn.Conv2d(<span class="number">1024</span>, <span class="number">1024</span>, kernel_size=<span class="number">1</span>) <span class="comment"># 全连接</span></span><br><span class="line">    layers += [pool5, conv6,</span><br><span class="line">               nn.ReLU(inplace=<span class="literal">True</span>), conv7, nn.ReLU(inplace=<span class="literal">True</span>)]</span><br><span class="line">    <span class="keyword">return</span> layers</span><br></pre></td></tr></table></figure><h5 id="1-3-追加层（后）"><a href="#1-3-追加层（后）" class="headerlink" title="1.3 追加层（后）"></a>1.3 追加层（后）</h5><p><strong>h、Conv6，经过一次 [1,1] 卷积，调整通道数，一次步长为2的[3,3]卷积网络，输出的特征层为512，因此输出的net为(10,10,512)。</strong></p><p><strong>i、Conv7，经过一次 [1,1] 卷积，调整通道数，一次步长为2的[3,3]卷积网络，输出的特征层为256，因此输出的net为(5,5,256)。</strong></p><p><strong>j、Conv8，经过一次 [1,1] 卷积，调整通道数，一次padding为valid的[3,3]卷积网络，输出的特征层为256，因此输出的net为(3,3,256)。</strong></p><p><strong>k、Conv9，经过一次 [1,1] 卷积，调整通道数，一次padding为valid的[3,3]卷积网络，输出的特征层为256，因此输出的net为(1,1,256)。</strong></p><p><img src="/2020/05/11/基于SSD目标检测网络的树莓派控制系统（二）/SSD3.jpg" alt="SSD追加层"></p><p><strong>代码实现：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_extras</span><span class="params">(i, batch_norm=False)</span>:</span></span><br><span class="line">    <span class="comment"># 向VGG添加了额外的图层以进行特征缩放</span></span><br><span class="line">    layers = []</span><br><span class="line">    in_channels = i</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Block 6</span></span><br><span class="line">    <span class="comment"># 19,19,1024 -&gt; 10,10,512</span></span><br><span class="line">    layers += [nn.Conv2d(in_channels, <span class="number">256</span>, kernel_size=<span class="number">1</span>, stride=<span class="number">1</span>)]  <span class="comment"># [0]</span></span><br><span class="line">    <span class="comment"># C6_2</span></span><br><span class="line">    layers += [nn.Conv2d(<span class="number">256</span>, <span class="number">512</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Block 7</span></span><br><span class="line">    <span class="comment"># 10,10,512 -&gt; 5,5,256</span></span><br><span class="line">    layers += [nn.Conv2d(<span class="number">512</span>, <span class="number">128</span>, kernel_size=<span class="number">1</span>, stride=<span class="number">1</span>)]</span><br><span class="line">    layers += [nn.Conv2d(<span class="number">128</span>, <span class="number">256</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Block 8</span></span><br><span class="line">    <span class="comment"># 5,5,256 -&gt; 3,3,256</span></span><br><span class="line">    layers += [nn.Conv2d(<span class="number">256</span>, <span class="number">128</span>, kernel_size=<span class="number">1</span>, stride=<span class="number">1</span>)]</span><br><span class="line">    layers += [nn.Conv2d(<span class="number">128</span>, <span class="number">256</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Block 9</span></span><br><span class="line">    <span class="comment"># 3,3,256 -&gt; 1,1,256</span></span><br><span class="line">    layers += [nn.Conv2d(<span class="number">256</span>, <span class="number">128</span>, kernel_size=<span class="number">1</span>, stride=<span class="number">1</span>)]</span><br><span class="line">    layers += [nn.Conv2d(<span class="number">128</span>, <span class="number">256</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> layers</span><br></pre></td></tr></table></figure><h5 id="1-4-从特征获取预测结果"><a href="#1-4-从特征获取预测结果" class="headerlink" title="1.4.从特征获取预测结果"></a>1.4.从特征获取预测结果</h5><p><img src="/2020/05/11/基于SSD目标检测网络的树莓派控制系统（二）/predict.png" alt="特征预测"></p><p>​        红框部分圈出SSD网络模型在预测时与yolo最大得差别就是：YOLO在卷积层后接全连接层，即检测时只利用了最高层Feature maps（包括Faster RCNN也是如此），而SSD是取 <strong>Conv4的第三次卷积(Conv4_3即第21层)的特征、FC7的特征、Conv6的第二次卷积(Conv6_2)的特征、Conv7的第二次卷积(Conv7_2)的特征、Conv8的第二次卷积(Conv8_2)的特征、Conv9的第二次卷积(Conv9_2)的特征,一共6个特征层</strong>，为了和普通特征层区分，我们称之为<strong>有效特征层</strong>，来获取预测结果。<strong>Relu激活函数和L2Norm并不影响特征。</strong></p><p>对获取到的<strong>每一个有效特征层，我们分别对其进行一次num_priors x 4的卷积、一次num_priors x num_classes的卷积、并需要计算每一个有效特征层对应的先验框。而num_priors指的是该特征层所拥有的先验框数量。</strong></p><p>其中：<br><strong>num_priors x 4的卷积</strong> 用于预测 <strong>该特征层上</strong> <strong>每一个网格点上</strong> 每一个先验框的变化情况。（<strong>为什么说是变化情况呢，这是因为ssd的预测结果需要结合先验框获得预测框，预测结果就是先验框的变化情况。）</strong></p><p><strong>num_priors x num_classes的卷积</strong> 用于预测 <strong>该特征层上 每一个网格点上</strong> 每一个预测框对应的种类。</p><p>每一个有效特征层对应的先验框对应着<strong>该特征层上 每一个网格点上</strong> 预先设定好的多个框。</p><p>所有的特征层对应的预测结果的shape如下：<br><img src="/2020/05/11/基于SSD目标检测网络的树莓派控制系统（二）/prior.png" alt="回归和分类特征提取shape"></p><p><center><b>注：表格中num_classes 为 21(20类+1背景) 所以 卷积后 num_priors x num_classes = 4x21 =84 </b></center><br><strong>代码实现：</strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SSD</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, phase, base, extras, head, num_classes)</span>:</span></span><br><span class="line">        super(SSD, self).__init__()</span><br><span class="line">        self.phase = phase</span><br><span class="line">        self.num_classes = num_classes</span><br><span class="line">        self.cfg = Config</span><br><span class="line">        self.vgg = nn.ModuleList(base)</span><br><span class="line">        self.L2Norm = L2Norm(<span class="number">512</span>, <span class="number">20</span>)</span><br><span class="line">        self.extras = nn.ModuleList(extras)</span><br><span class="line">        self.priorbox = PriorBox(self.cfg)</span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            self.priors = self.priorbox.forward()</span><br><span class="line">        self.loc = nn.ModuleList(head[<span class="number">0</span>])</span><br><span class="line">        self.conf = nn.ModuleList(head[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> phase == <span class="string">'test'</span>:</span><br><span class="line">            self.softmax = nn.Softmax(dim=<span class="number">-1</span>)</span><br><span class="line">            self.detect = Detect(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        sources = list()</span><br><span class="line">        loc = list()</span><br><span class="line">        conf = list()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获得conv4_3的内容 relu层也算 Pooling不进行relu 一共36层 0-22=1-23</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">23</span>):<span class="comment"># 22层</span></span><br><span class="line">            x = self.vgg[k](x)</span><br><span class="line"></span><br><span class="line">        s = self.L2Norm(x)<span class="comment"># L2标准化 原因：深度不够 24层</span></span><br><span class="line">        sources.append(s)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获得fc7的内容</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">23</span>, len(self.vgg)):<span class="comment">#23-34=24-35层</span></span><br><span class="line">            x = self.vgg[k](x)</span><br><span class="line">        sources.append(x) <span class="comment">#FC7_1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获得后面的内容</span></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> enumerate(self.extras):</span><br><span class="line">            x = F.relu(v(x), inplace=<span class="literal">True</span>)<span class="comment"># 这里加了relu所以在网络中没有显示</span></span><br><span class="line">            <span class="keyword">if</span> k % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                sources.append(x)</span><br><span class="line"></span><br><span class="line"> <span class="comment"># [batch_size,channel</span></span><br><span class="line">        <span class="comment"># 添加回归层和分类层</span></span><br><span class="line">        <span class="keyword">for</span> (x, l, c) <span class="keyword">in</span> zip(sources, self.loc, self.conf):</span><br><span class="line">            loc.append(l(x).permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>).contiguous())  <span class="comment"># permute 通道数翻转</span></span><br><span class="line">            conf.append(c(x).permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>).contiguous())</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 进行resize</span></span><br><span class="line">        loc = torch.cat([o.view(o.size(<span class="number">0</span>), <span class="number">-1</span>) <span class="keyword">for</span> o <span class="keyword">in</span> loc], <span class="number">1</span>)</span><br><span class="line">        conf = torch.cat([o.view(o.size(<span class="number">0</span>), <span class="number">-1</span>) <span class="keyword">for</span> o <span class="keyword">in</span> conf], <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> self.phase == <span class="string">"test"</span>:</span><br><span class="line">            output = self.detect.apply(loc.view(loc.size(<span class="number">0</span>), <span class="number">-1</span>, <span class="number">4</span>),</span><br><span class="line">                                        self.softmax(conf.view(conf.size(<span class="number">0</span>), <span class="number">-1</span>, self.num_classes)),</span><br><span class="line">                                        self.priors)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            output = (</span><br><span class="line">                loc.view(loc.size(<span class="number">0</span>), <span class="number">-1</span>, <span class="number">4</span>),</span><br><span class="line">                conf.view(conf.size(<span class="number">0</span>), <span class="number">-1</span>, self.num_classes),</span><br><span class="line">                self.priors</span><br><span class="line">                    )</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">mbox = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ssd</span><span class="params">(phase, num_classes)</span>:</span></span><br><span class="line">    vgg, extra_layers = add_vgg(<span class="number">3</span>), add_extras(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    loc_layers = []</span><br><span class="line">    conf_layers = []</span><br><span class="line">    vgg_source = [<span class="number">21</span>, <span class="number">-2</span>]</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> enumerate(vgg_source):  </span><br><span class="line">        <span class="comment"># k是索引，v是枚举出来得对象(0 21) (1 -2)提取出21层和33层对应（4，6）</span></span><br><span class="line">        loc_layers += [nn.Conv2d(vgg[v].out_channels,</span><br><span class="line">                                 mbox[k] * <span class="number">4</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)]</span><br><span class="line">        conf_layers += [nn.Conv2d(vgg[v].out_channels,</span><br><span class="line">                                  mbox[k] * num_classes, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> enumerate(extra_layers[<span class="number">1</span>::<span class="number">2</span>], <span class="number">2</span>):  <span class="comment"># （2，1）（3，3）（4，5）（5，7）</span></span><br><span class="line">        loc_layers += [nn.Conv2d(v.out_channels, mbox[k]</span><br><span class="line">                                 * <span class="number">4</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)]</span><br><span class="line">        conf_layers += [nn.Conv2d(v.out_channels, mbox[k]</span><br><span class="line">                                  * num_classes, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    SSD_MODEL = SSD(phase, vgg, extra_layers, (loc_layers, conf_layers), num_classes)</span><br><span class="line">    <span class="keyword">return</span> SSD_MODEL</span><br></pre></td></tr></table></figure><h5 id="1-5-预测结果得解码"><a href="#1-5-预测结果得解码" class="headerlink" title="1.5 预测结果得解码"></a>1.5 预测结果得解码</h5><p><img src="/2020/05/11/基于SSD目标检测网络的树莓派控制系统（二）/feature.jpg" alt="feature"></p><p>我们通过对每一个特征层的处理，可以获得三个内容，分别是：</p><p><strong>线路1：</strong>  经过一次卷积后，生成了 <strong>[1, num_class*num_priorbox, layer_height, layer_width]</strong>大小的feature用于softmax分类目标和非目标（其中num_class是目标类别，SSD300中num_class = 21，即20个类别+1个背景)  </p><p><strong>num_priors x num_classes的卷积</strong> 用于预测 <strong>该特征层上 每一个网格点上 每一个预测框</strong>对应的种类。</p><p><strong>线路2 :</strong> 经过一次卷积后， 生成了<strong>[1, 4*num_priorbox, layer_height, layer_width]</strong>大小的feature用于bounding box regression（边界框回归 在训练中 微调边界框大小匹配真实框)(即每个点一组[dxmin，dymin，dxmax，dymax])</p><p><strong>线路3：</strong> 生成了<strong>[1, 2, 4*num_priorbox*layer_height*layer_width]</strong>大小的prior box blob，其中2个channel分别存储prior box的4个点坐标(x1, y1, x2, y2)和对应的4个参数variance </p><p><strong>num_priors x 4的卷积</strong> 用于预测 <strong>该特征层上 每一个网格点上 每一个先验框</strong>的变化情况。</p><p>每一个有效特征层所对应的先验框 是对应着<strong>该特征层上 每一个网格点上 预先设定好的多个框（如：Conv4_3-&gt;5776个）</strong>。</p><p>我们利用 <strong>num_priors x 4 的卷积</strong> 与 <strong>每一个有效特征层对应的先验框</strong> 匹配获得框的预测位置。</p><p>每一个有效特征层对应的先验框就是，如图所示的作用：</p><p>​        每一个有效特征层将整个图片分成与其长宽对应的网格，<strong>如conv4-3的特征层就是将整个图像分成38x38个网格；然后从每个网格中心建立多个先验框，如conv4-3的特征层就是建立了4个先验框；对于conv4-3的特征层来讲，整个图片被分成38x38个网格，每个网格中心对应4个先验框，一共包含了，38x38x4个，5776个先验框。</strong></p><p><img src="/2020/05/11/基于SSD目标检测网络的树莓派控制系统（二）/prior1.png" alt="prior"></p><p>先验框虽然可以代表一定的<strong>框的位置信息与框的大小信息</strong>，但是其是有限的，无法表示任意情况，因此还需要调整，ssd利用<strong>num_priors x 4的卷积</strong>的结果对先验框进行调整。 </p><p> <strong>num_priors x 4中的num_priors表示了这个网格点所包含的先验框数量，其中的4表示了x_offset、y_offset、h和w的调整情况。</strong> </p><p> <strong>x_offset与y_offset代表了真实框中心距离先验框中心的xy轴偏移情况。<br> h和w代表了真实框的宽与高相对于先验框的变化情况。</strong> </p><p> SSD解码过程就是将<strong>每个网格的中心点加上它对应的x_offset和y_offset，加完后的结果就是预测框的中心</strong>，然后再利用 <strong>先验框和h、w结合 计算出预测框的长和宽。这样就能得到整个预测框的位置了。</strong> </p><p><strong>当然得到最终的预测结构后还要进行得分排序与非极大抑制筛选这一部分基本上是所有目标检测通用的部分。</strong> </p><ul><li><strong>取出每一类得分大于<code>Config[&quot;nms_thresh&quot;]</code>的框和得分。</strong></li><li><strong>利用框的位置和得分进行非极大抑制（NMS）生成预测框。</strong></li></ul><p><strong>代码实现：</strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Detect</span><span class="params">(Function)</span>:</span></span><br><span class="line">    <span class="comment"># 回归预测结果，分类预测结果，先验框 静态方法</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, loc_data, conf_data, prior_data)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> Config[<span class="string">'nms_thresh'</span>] &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'nms_threshold must be non negative.'</span>)</span><br><span class="line">        loc_data = loc_data.cpu()</span><br><span class="line">        conf_data = conf_data.cpu()</span><br><span class="line">        <span class="comment"># 图片数量 预测一般一张</span></span><br><span class="line">        num = loc_data.size(<span class="number">0</span>)  <span class="comment"># batch size 一张图片</span></span><br><span class="line">        <span class="comment"># 先验框数量 8732</span></span><br><span class="line">        num_priors = prior_data.size(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 存放输出(1,类别，200)</span></span><br><span class="line">        output = torch.zeros(num, Config[<span class="string">'num_classes'</span>], Config[<span class="string">"top_k"</span>], <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 分类预测结果转换（1，8732，种类）torch.transpose(input, dim0, dim1, out=None) → Tensor 返回输入矩阵input的转置。交换维度dim0和dim1。 输出张量与输入张量共享内存，所以改变其中一个会导致另外一个也被修改。</span></span><br><span class="line">        conf_preds = conf_data.view(num, num_priors,Config[<span class="string">'num_classes'</span>]).transpose(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 对每一张图片进行处理</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">            <span class="comment"># 对先验框解码获得预测框</span></span><br><span class="line">            decoded_boxes = decode(loc_data[i], prior_data, Config[<span class="string">'variance'</span>])</span><br><span class="line">            <span class="comment"># 取出某一图片所有先验框种类</span></span><br><span class="line">            conf_scores = conf_preds[i].clone()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> cl <span class="keyword">in</span> range(<span class="number">1</span>, Config[<span class="string">'num_classes'</span>]):</span><br><span class="line">                <span class="comment"># 对每一类进行非极大抑制</span></span><br><span class="line">                <span class="comment"># gt(a,b) 相当于 a &gt; b conf_thresh阈值0.01 返回（True,False）</span></span><br><span class="line">                c_mask = conf_scores[cl].gt(Config[<span class="string">"conf_thresh"</span>])</span><br><span class="line">                <span class="comment"># 两组合并去除false对应数据数据</span></span><br><span class="line">                scores = conf_scores[cl][c_mask]</span><br><span class="line">                <span class="keyword">if</span> scores.size(<span class="number">0</span>) == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                l_mask = c_mask.unsqueeze(<span class="number">1</span>).expand_as(decoded_boxes)</span><br><span class="line">                boxes = decoded_boxes[l_mask].view(<span class="number">-1</span>, <span class="number">4</span>)</span><br><span class="line">                <span class="comment"># 进行非极大抑制</span></span><br><span class="line">                ids, count = nms(boxes, scores, Config[<span class="string">'nms_thresh'</span>], Config[<span class="string">"top_k"</span>])</span><br><span class="line">                output[i, cl, :count] = \</span><br><span class="line">                    torch.cat((scores[ids[:count]].unsqueeze(<span class="number">1</span>),</span><br><span class="line">                               boxes[ids[:count]]), <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 进行排序</span></span><br><span class="line">        flt = output.contiguous().view(num, <span class="number">-1</span>, <span class="number">5</span>)</span><br><span class="line">        _, idx = flt[:, :, <span class="number">0</span>].sort(<span class="number">1</span>, descending=<span class="literal">True</span>)</span><br><span class="line">        _, rank = idx.sort(<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 取出top_K框返回</span></span><br><span class="line">        flt[(rank &lt; Config[<span class="string">"top_k"</span>]).unsqueeze(<span class="number">-1</span>).expand_as(flt)].fill_(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><h5 id="1-6-在原图上进行绘制"><a href="#1-6-在原图上进行绘制" class="headerlink" title="1.6 在原图上进行绘制"></a>1.6 在原图上进行绘制</h5><p> 我们可以获得预测框在原图上的位置，而且这些预测框都是经过（NMS）筛选的。这些筛选后的框可以直接绘制在图片上，就可以获得结果了。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> deep learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于SSD目标检测网络的树莓派控制系统（一）</title>
      <link href="/2020/05/09/%E5%9F%BA%E4%BA%8ESSD%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%BD%91%E7%BB%9C%E7%9A%84%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/05/09/%E5%9F%BA%E4%BA%8ESSD%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%BD%91%E7%BB%9C%E7%9A%84%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="基于PyQt5的SSD目标检测软件（一）"><a href="#基于PyQt5的SSD目标检测软件（一）" class="headerlink" title="基于PyQt5的SSD目标检测软件（一）"></a>基于PyQt5的SSD目标检测软件（一）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        墨迹了这么久，终于把毕设做好了，这在一年前是我不敢想的事情，作为一个生物工程专业的学生做了一个关于计算机图像识别方面的毕设听起来也怪搞笑的。四年前进入大学的场景还历历在目，四年后戏剧性的在疫情中结束了我的大学生涯，今年注定是不平凡的一年，有太多的历史值得我们去铭记。回想这四年的时光还是参与了不少事情，大学也不算虚度，唯一的遗憾就是没有坚持锻炼身体，四年过去了依旧这么瘦，希望以后最近的锻炼能坚持下去，养成一些好习惯。</p><p>说一说做这个毕设的故事吧，大二的时候相当迷茫，并不明确的专业知识让我产生了编程学习也就是看看网课这么简单的想法，机缘巧合参加了创新工作室，当然也离不开王振海的忽悠，不过当时对编程依旧充满了喜爱，是目的也是动力，虽然没有目标，但是恰好工作室也有一些项目，反正都是知识，就跟着学，就这样跟着学会了3D建模，3D打印，单片机传感器的一些知识，等等，我不是想学编程吗？当老师知道了我得想法，也鼓励我去尝试，所以老师给了一个项目说想用树莓派做一个显微镜，直到这时，我才意识到如果实现这个功能，我所要补充的知识体系不是一点点编程的基础就可以解决的，当然它也确实打开了我学习计算机的大门，在拿到树莓派之前，我甚至不太清楚Linux是什么。就这样走着学着，得益于东风校区同学完成了硬件的建模、3D打印和电机控制，在临近比赛的前两天，我解决了用树莓派控制并图像展示的核心问题，虽然方法很简单笨拙，却实现了项目自动对焦<del>opencv调包</del>的简单需要。那是我第一次出省比赛，第一次走进上海交大的校园，也是后面一切的开始，但是实现目标检测功能的软件在那时已经种下了种子。</p><a id="more"></a><p><img src="/2020/05/09/基于SSD目标检测网络的树莓派控制系统（一）/1.png" alt="第一代"></p><p><img src="/2020/05/09/基于SSD目标检测网络的树莓派控制系统（一）/2.png" alt="第二代"></p><p><center>当然这是建模渲染的图，但是得夸一句机械的同学建模是真的好看</center></p><h2 id="思路说明"><a href="#思路说明" class="headerlink" title="思路说明"></a>思路说明</h2><p>深度学习 → 计算机视觉 → 目标检测</p><p>树莓派（python3） → arduino通讯</p><p>PyQt5 软件外观设计</p><h2 id="使用框架及工具包："><a href="#使用框架及工具包：" class="headerlink" title="使用框架及工具包："></a>使用框架及工具包：</h2><ul><li>python 3.7.3 （64bit 一定要64位，不然无法安装pytorch）</li><li>torch==1.4.0</li><li>PyQt5==5.14.2</li><li>numpy==1.18.1</li><li>distributed==2.1.0</li><li>Pillow==7.1.2</li><li>opencv_python==4.2.0.32</li><li>pyserial==3.4 (arduino通信)</li><li>matplotlib==3.1.3</li><li>labalimg</li></ul><h2 id="项目结构图"><a href="#项目结构图" class="headerlink" title="项目结构图"></a>项目结构图</h2><p><img src="/2020/05/09/基于SSD目标检测网络的树莓派控制系统（一）/tree.png" alt="项目结构"></p><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p>github 链接： <a href="https://github.com/banniford/Microbial-identification" target="_blank" rel="noopener">https://github.com/banniford/Microbial-identification</a> </p><h2 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h2><ul><li><p>使用PyQt5进行了外观初步构建,由arduino控制界面，模型训练界面，图片预测界面构成</p></li><li><p>目前已实现功能主要分为三大部分</p><ul><li><p>摄像头控制部分</p><ul><li>检测并连接摄像头</li></ul></li><li><p>arduino通讯检测及步进电机控制</p><ul><li>opencv拉普拉斯算子计算清晰度</li></ul></li><li><p>模型训练部分</p></li><li><p>SSD目标检测网络</p><ul><li>参数更改</li><li>网络中间层参数数量信息打印<ul><li>数据集校验，生成索引文件</li><li>多线程开始/中止训练</li></ul></li></ul></li><li><p>模型预测部分</p></li><li>选择训练完成模型进行预测标注<ul><li>结果打印</li></ul></li></ul></li><li><p>目前可以进行模型的参数设定，训练以及识别，权重模型和数据集需要下载，详情看文件内Readme</p></li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>SSD目标检测网络详解b站up主 Bubbliiiing 视频链接：<a href="https://www.bilibili.com/video/BV1A7411976Z" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1A7411976Z</a></p><p>up主Blog：<a href="https://blog.csdn.net/weixin_44791964/article/list/1?t=1&amp;orderby=UpdateTime" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44791964/article/list/1?t=1&amp;orderby=UpdateTime</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> deep learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MNIST手写字体识别实例</title>
      <link href="/2020/03/27/MNIST%E6%89%8B%E5%86%99%E5%AD%97%E4%BD%93%E8%AF%86%E5%88%AB%E5%AE%9E%E4%BE%8B/"/>
      <url>/2020/03/27/MNIST%E6%89%8B%E5%86%99%E5%AD%97%E4%BD%93%E8%AF%86%E5%88%AB%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="MNIST手写字体识别实例"><a href="#MNIST手写字体识别实例" class="headerlink" title="MNIST手写字体识别实例"></a>MNIST手写字体识别实例</h1><h2 id="1-步骤概要"><a href="#1-步骤概要" class="headerlink" title="1.步骤概要"></a>1.步骤概要</h2><ul><li><p>读取数据</p></li><li><p>创建网络</p></li><li><p>训练参数得到 [w1,b1,w2,b2,w3,b3]（三层）</p></li><li>准确度测试</li></ul><a id="more"></a><h2 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2.具体实现"></a>2.具体实现</h2><h3 id="2-1-工具包"><a href="#2-1-工具包" class="headerlink" title="2.1 工具包"></a>2.1 工具包</h3><p>对图片进行可视化展示以及onehot编码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画曲线</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_curve</span><span class="params">(data)</span>:</span></span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    plt.plot(range(len(data)),data,color=<span class="string">"blue"</span>)</span><br><span class="line">    plt.legend([<span class="string">"value"</span>],loc = <span class="string">"upper right"</span>)</span><br><span class="line">    plt.xlabel(<span class="string">"step"</span>)</span><br><span class="line">    plt.ylabel(<span class="string">"value"</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 画图片</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_image</span><span class="params">(img,label,name)</span>:</span></span><br><span class="line"></span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        plt.subplot(<span class="number">2</span>,<span class="number">3</span>,i + <span class="number">1</span>)</span><br><span class="line">        plt.tight_layout()</span><br><span class="line">        plt.imshow(img[i][<span class="number">0</span>]*<span class="number">0.3081</span>+<span class="number">0.1307</span>, cmap = <span class="string">"gray"</span> , interpolation = <span class="string">"none"</span>)</span><br><span class="line">        plt.title(<span class="string">"&#123;&#125;:&#123;&#125;"</span>.format(name,label[i].item()))</span><br><span class="line">        plt.xticks([])</span><br><span class="line">        plt.yticks([])</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#one hot编码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">one_hot</span><span class="params">(label,depth=<span class="number">10</span>)</span>:</span></span><br><span class="line">    out = torch.zeros(label.size(<span class="number">0</span>),depth)</span><br><span class="line">    idx = torch.LongTensor(label).view(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line">    out.scatter_(dim=<span class="number">1</span>,index = idx,value=<span class="number">1</span>)<span class="comment">#dim=0按行填充dim=1按列填充</span></span><br><span class="line">    <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><h3 id="2-2导入包"><a href="#2-2导入包" class="headerlink" title="2.2导入包"></a>2.2导入包</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn <span class="comment">#网络模型</span></span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F <span class="comment">#激活函数</span></span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> optim <span class="comment">#优化器</span></span><br><span class="line"><span class="keyword">import</span> torchvision <span class="comment">#载入数据</span></span><br></pre></td></tr></table></figure><h3 id="2-3-下载并读取数据"><a href="#2-3-下载并读取数据" class="headerlink" title="2.3 下载并读取数据"></a>2.3 下载并读取数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#每个批次多少张照片</span></span><br><span class="line">batch_size=<span class="number">512</span></span><br><span class="line"><span class="comment"># 1.读取数据</span></span><br><span class="line">train_loader = torch.utils.data.DataLoader(</span><br><span class="line">    torchvision.datasets.MNIST(<span class="string">"mnist_data/"</span>,train=<span class="literal">True</span>,download=<span class="literal">True</span>,</span><br><span class="line">                               transform=torchvision.transforms.Compose([</span><br><span class="line">                                   torchvision.transforms.ToTensor(),</span><br><span class="line">                                   torchvision.transforms.Normalize(</span><br><span class="line">                                       (<span class="number">0.1301</span>,),(<span class="number">0.3081</span>,))</span><br><span class="line">                                   ]))</span><br><span class="line">,batch_size=batch_size,shuffle = <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test_loader = torch.utils.data.DataLoader(</span><br><span class="line">    torchvision.datasets.MNIST(<span class="string">"mnist_data/"</span>,train=<span class="literal">False</span>,download=<span class="literal">True</span>,</span><br><span class="line">                               transform=torchvision.transforms.Compose([</span><br><span class="line">                                   torchvision.transforms.ToTensor(),</span><br><span class="line">                                   torchvision.transforms.Normalize(</span><br><span class="line">                                       (<span class="number">0.1301</span>,),(<span class="number">0.3081</span>,))</span><br><span class="line">                                   ]))</span><br><span class="line">,batch_size=batch_size,shuffle = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>对训练数据进行可视化展示，查看图片</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x,y=next(iter(train_loader))</span><br><span class="line">print(x.shape,y.shape,x.min(),x.max())</span><br><span class="line">plot_image(x,y,<span class="string">"image"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">torch.Size([512, 1, 28, 28]) torch.Size([512]) tensor(-0.4223) tensor(2.8234)</span><br></pre></td></tr></table></figure><p><img src="/2020/03/27/MNIST手写字体识别实例/train.png" alt></p><h3 id="2-4-创建网络模型"><a href="#2-4-创建网络模型" class="headerlink" title="2.4 创建网络模型"></a>2.4 创建网络模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Net,self).__init__()</span><br><span class="line">        <span class="comment"># wx+b</span></span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">28</span>*<span class="number">28</span>,<span class="number">256</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">256</span>,<span class="number">64</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">64</span>,<span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        <span class="comment"># x:[batch_size,1,28,28]</span></span><br><span class="line">        <span class="comment"># h1 = wx+b 使用relu激活函数</span></span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        <span class="comment"># h2 = relu(W2h1+b2)使用relu激活函数</span></span><br><span class="line">        x = F.relu(self.fc2(x))</span><br><span class="line">        <span class="comment"># 可以用softmax/means 这里没有使用h3=w3h2+b3</span></span><br><span class="line">        x = self.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>调用模型进行训练迭代</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">net=Net()</span><br><span class="line"><span class="comment">#[w1,b1,w2,b2,w3,b3]</span></span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=<span class="number">0.01</span> , momentum = <span class="number">0.9</span>)</span><br><span class="line"></span><br><span class="line">train_loss=[]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> batch_idx,(x,y) <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">        <span class="comment"># x:[bztch_size(512),1,28,28],y:[512]</span></span><br><span class="line">        <span class="comment"># print(x.shape,y.shape)</span></span><br><span class="line">        <span class="comment"># break</span></span><br><span class="line">        <span class="comment"># net只能接收[batch_size,feature][512,28*28]</span></span><br><span class="line">        <span class="comment">#所以需要[512,1,28,28]=&gt;[512,784]</span></span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>),<span class="number">28</span>*<span class="number">28</span>)</span><br><span class="line">        <span class="comment"># =&gt;[batch_size,10]</span></span><br><span class="line">        out = net(x)</span><br><span class="line">        <span class="comment"># [batch_size,10]接近</span></span><br><span class="line">        y_onehot = one_hot(y)</span><br><span class="line">        <span class="comment"># loss = mse(out,y_onehot)</span></span><br><span class="line">        loss = F.mse_loss(out,y_onehot)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#梯度清零，否则会累加</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        <span class="comment">#w' = w- lr*grad 梯度更新</span></span><br><span class="line">        optimizer.step()</span><br><span class="line">        </span><br><span class="line">        train_loss.append(loss.item())</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 每10张打印损失值</span></span><br><span class="line">        <span class="comment">#if batch_idx% 10 == 0 :</span></span><br><span class="line">            <span class="comment">#print(epoch,batch_idx,loss.item())</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#画出损失曲线</span></span><br><span class="line">plot_curve(train_loss)</span><br><span class="line"><span class="comment"># 3.得到optimal [w1,b1,w2,b2,w3,b3]</span></span><br></pre></td></tr></table></figure><p><img src="/2020/03/27/MNIST手写字体识别实例/lost.png" alt></p><h3 id="2-5-准确度测试"><a href="#2-5-准确度测试" class="headerlink" title="2.5 准确度测试"></a>2.5 准确度测试</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#4.准确度测试</span></span><br><span class="line"></span><br><span class="line">total_correct = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> test_loader:</span><br><span class="line">    x =  x.view(x.size(<span class="number">0</span>),<span class="number">28</span>*<span class="number">28</span>)</span><br><span class="line">    out = net(x)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># out:[512,10]=&gt;pred:list[512] dim对应第1维10个中得最大索引位置</span></span><br><span class="line">    pred = out.argmax(dim=<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#tensor 比较 相加 转化float item()将tensor转化为数字</span></span><br><span class="line">    correct = pred.eq(y).sum().float().item()</span><br><span class="line">    total_correct+=correct</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">total_num = len(test_loader.dataset)</span><br><span class="line">acc=total_correct / total_num</span><br><span class="line">print(<span class="string">"test acc:"</span> ,acc)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">test acc: 0.8814</span><br></pre></td></tr></table></figure><h3 id="2-6训练集与测试集数据展示"><a href="#2-6训练集与测试集数据展示" class="headerlink" title="2.6训练集与测试集数据展示"></a>2.6训练集与测试集数据展示</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#训练集</span></span><br><span class="line">x,y=next(iter(train_loader))</span><br><span class="line">print(x.shape,y.shape,x.min(),x.max())</span><br><span class="line">plot_image(x,y,<span class="string">"image"</span>)</span><br><span class="line"><span class="comment">#测试集</span></span><br><span class="line">x,y = next(iter(test_loader))</span><br><span class="line">out = net(x.view(x.size(<span class="number">0</span>),<span class="number">28</span>*<span class="number">28</span>))</span><br><span class="line">pred = out.argmax(dim=<span class="number">1</span>)</span><br><span class="line">plot_image(x,pred,<span class="string">"test"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">torch.Size([512, 1, 28, 28]) torch.Size([512]) tensor(-0.4223) tensor(2.8234)</span><br></pre></td></tr></table></figure><p><img src="/2020/03/27/MNIST手写字体识别实例/train.png" alt></p><p><img src="/2020/03/27/MNIST手写字体识别实例/test.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> deep learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据增强</title>
      <link href="/2020/03/25/%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%BC%BA/"/>
      <url>/2020/03/25/%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%BC%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="图像增广"><a href="#图像增广" class="headerlink" title="图像增广"></a>图像增广</h1><p>大规模数据集是成功应用深度神经网络的前提。图像增广（image augmentation）技术通过对训练图像做一系列随机改变，来产生相似但又不同的训练样本，从而扩大训练数据集的规模。图像增广的另一种解释是，随机改变训练样本可以降低模型对某些属性的依赖，从而提高模型的泛化能力。例如，我们可以对图像进行不同方式的裁剪，使感兴趣的物体出现在不同位置，从而减轻模型对物体出现位置的依赖性。我们也可以调整亮度、色彩等因素来降低模型对色彩的敏感度。可以说，在当年AlexNet的成功中，图像增广技术功不可没。</p><a id="more"></a><h2 id="常用的图像增广方法"><a href="#常用的图像增广方法" class="headerlink" title="常用的图像增广方法"></a>常用的图像增广方法</h2><h3 id="翻转和裁剪"><a href="#翻转和裁剪" class="headerlink" title="翻转和裁剪"></a>翻转和裁剪</h3><p>左右翻转图像通常不改变物体的类别。它是最早也是最广泛使用的一种图像增广方法。上下翻转不如左右翻转通用。但是至少对于样例图像，上下翻转不会造成识别障碍。随机裁剪出一块面积为原面积$10\% \sim 100\%$的区域，且该区域的宽和高之比随机取自$0.5 \sim 2$，然后再将该区域的宽和高分别缩放到200像素。</p><p><img src="/2020/03/25/数据增强/1.svg" alt="左右翻转"></p><p><img src="/2020/03/25/数据增强/2.svg" alt="上下翻转"></p><p><img src="/2020/03/25/数据增强/2_5.svg" alt></p><hr><h3 id="变化颜色"><a href="#变化颜色" class="headerlink" title="变化颜色"></a>变化颜色</h3><p>​       另一类增广方法是变化颜色。我们可以从4个方面改变图像的颜色：亮度（brightness）、对比度（contrast）、饱和度（saturation）和色调（hue）。在下面的例子里，我们将图像的亮度随机变化为原图亮度的$50\%$($1-0.5$)$\sim 150\%$($1+0.5$)。</p><p><img src="/2020/03/25/数据增强/3.svg" alt="亮度变化"></p><p>​        我们也可以随机变化图像的色调。</p><p><img src="/2020/03/25/数据增强/4.svg" alt></p><p>​        我们也可以随机变化图像的对比度。</p><p><img src="/2020/03/25/数据增强/5.svg" alt></p><p>​        我们也可以同时设置如何随机变化图像的亮度（brightness）、对比度（contrast）、饱和度（saturation）和色调（hue）。</p><p><img src="/2020/03/25/数据增强/6.svg" alt></p><hr><h3 id="叠加多个图像增广方法"><a href="#叠加多个图像增广方法" class="headerlink" title="叠加多个图像增广方法"></a>叠加多个图像增广方法</h3><p>​        实际应用中我们会将多个图像增广方法叠加使用。我们可以通过Compose实例将上面定义的多个图像增广方法叠加起来，再应用到每张图像之上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">augs = torchvision.transforms.Compose([</span><br><span class="line">torchvision.transforms.RandomHorizontalFlip(), color_aug, shape_aug])</span><br><span class="line"></span><br><span class="line">apply(img, augs)</span><br></pre></td></tr></table></figure><p><img src="/2020/03/25/数据增强/7.svg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> deep learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Task06-pytorch实现简易神经网络</title>
      <link href="/2020/03/23/Task06-pytorch%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/2020/03/23/Task06-pytorch%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<p>PyTorch是美国互联网巨头Facebook在深度学习框架Torch的基础上使用Python重写的一个全新的深度学习框架，它更像NumPy的替代产物，不仅继承了NumPy的众多优点，还支持GPUs计算，在计算效率上要比NumPy有更明显的优势；不仅如此，PyTorch还有许多高级功能，比如拥有丰富的API，可以快速完成深度神经网络模型的搭建和训练。所以 PyTorch一经发布，便受到了众多开发人员和科研人员的追捧和喜爱，成为AI从业者的重要工具之一。</p><h3 id="知识储备——深度学习中的常见概念"><a href="#知识储备——深度学习中的常见概念" class="headerlink" title="知识储备——深度学习中的常见概念"></a>知识储备——深度学习中的常见概念</h3><h4 id="张量Tensor"><a href="#张量Tensor" class="headerlink" title="张量Tensor"></a>张量Tensor</h4><p>　　Tensorflow中数据的核心单元就是Tensor。张量包含了一个数据集合，这个数据集合就是原始值变形而来的，它可以是一个任何维度的数据。tensor的rank就是其维度。</p><p>　　Rank本意是矩阵的秩，不过Tensor Rank和Matrix Rank的意义不太一样，这里就还叫Rank。Tensor Rank的意义看起来更像是维度，比如Rank =1就是向量，Rank=2 就是矩阵了，Rank = 0 就是一个值。</p><a id="more"></a><h2 id="1-搭建一个简易神经网络"><a href="#1-搭建一个简易神经网络" class="headerlink" title="1 搭建一个简易神经网络"></a>1 搭建一个简易神经网络</h2><h3 id="1-1-导入包"><a href="#1-1-导入包" class="headerlink" title="1.1 导入包"></a>1.1 导入包</h3><p>代码的开始处是相关包的导入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"> </span><br><span class="line">batch_n = <span class="number">100</span></span><br><span class="line">hidden_layer = <span class="number">100</span></span><br><span class="line">input_data = <span class="number">1000</span></span><br><span class="line">output_data = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>首先通过import torch 导入必要的包，然后定义4个整型变量，其中：batch_n是在一个批次中输入数据的数量，值是100，这意味着在一个批次中输入100个数据，同时，每个数据包含的数据特征有input_data个，因为input_data的值是1000，所以每个数据的特征就是1000个，hidden_layer用于定义经过隐藏层后保留的数据特征的个数，这里有100个，因为的模型只考虑一层隐藏层，所以在代码中仅仅定义了一个隐藏层的参数；output_data是输出的数据，值是10， 可以将输出的数据看作一个分类结果值得数量，个数10表示 最后要得到10个分类结果值。</p><p>　　一个批次的数据从输入到输出的完整过程是：先输入100个具有1000个特征的数据，经过隐藏层后变成100个具有100个特征的数据，再经过输出层后输出100个具有10个分类结果值的数据，在得到输出结果之后计算损失并进行后向传播，这样一次模型的训练就完成了，然后训练这个流程就可以完成指定次数的训练，并达到优化模型参数的目的。</p><h3 id="1-2-初始化权重"><a href="#1-2-初始化权重" class="headerlink" title="1.2 初始化权重"></a>1.2 初始化权重</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = torch.randn(batch_n,input_data)</span><br><span class="line">y = torch.randn(batch_n,output_data)</span><br><span class="line"> </span><br><span class="line">w1 = torch.randn(input_data,hidden_layer)</span><br><span class="line">w2 = torch.randn(hidden_layer,output_data)</span><br></pre></td></tr></table></figure><p>　在以上的代码中定义的从输入层到隐藏层，从隐藏层到输出层对应的权重参数，同在之前说到的过程中使用的参数维度是一致的，由于 现在并没有好的权重参数的初始化方法，尽管这并不是一个好主意，可以看到，在代码中定义的输入层维度为（100,1000），输出层维度为（100,10），同时，从输入层到隐藏层的权重参数维度为（1000,100），从隐藏层到输出层的权重参数维度为（100,10），这里可能会好奇权重参数的维度是如何定义下来的，其实，只要把整个过程看作矩阵连续的乘法运算，九自然能够明白了，在代码中 的真实值y也是通过随机的方式生成的，所以一开始在使用损失函数计算损失值时得到的结果会较大。</p><h3 id="1-3-定义训练次数和学习效率"><a href="#1-3-定义训练次数和学习效率" class="headerlink" title="1.3 定义训练次数和学习效率"></a>1.3 定义训练次数和学习效率</h3><p>　　在定义好输入，输出和权重参数值之后，就可以开始训练模型和优化权重参数了，在此之前，还需要明确训练的总次数和学习效率，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">epoch_n = <span class="number">20</span></span><br><span class="line">learning_rate = <span class="number">1e-6</span></span><br></pre></td></tr></table></figure><p>　由于接下来会使用梯度下降的方法来优化神经网络的参数，所以必须定义后向传播的次数和梯度下降使用的学习效率。在以上代码中使用了epoch_n定义训练的次数，epoch_n的值为20，所以 需要通过循环的方式让程序进行20次训练，来完成对初始化权重参数的优化和调整。在优化的过程中使用的学习效率learning_rate的值为1e-6，表示0.000001，接下来对模型进行正式训练并对参数进行优化。</p><h3 id="1-3-梯度下降优化神经网络的参数"><a href="#1-3-梯度下降优化神经网络的参数" class="headerlink" title="1.3 梯度下降优化神经网络的参数"></a>1.3 梯度下降优化神经网络的参数</h3><p> 　　下面代码通过最外层的一个大循环来保证 的模型可以进行20次训练，循环内的是神经网络模型具体的前向传播和后向传播代码。参数的优化和更新使用梯度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(epoch_n):</span><br><span class="line">    h1 = x.mm(w1)  <span class="comment"># 100*1000</span></span><br><span class="line">    h1 = h1.clamp(min=<span class="number">0</span>)</span><br><span class="line">    y_pred = h1.mm(w2)  <span class="comment"># 100*10</span></span><br><span class="line">    <span class="comment"># print(y_pred)</span></span><br><span class="line"> </span><br><span class="line">    loss = (y_pred - y).pow(<span class="number">2</span>).sum()<span class="comment"># 采用误差的平方来衡量损失</span></span><br><span class="line">    print(<span class="string">"Epoch:&#123;&#125; , Loss:&#123;:.4f&#125;"</span>.format(epoch, loss))</span><br><span class="line"> </span><br><span class="line">    gray_y_pred = <span class="number">2</span> * (y_pred - y)<span class="comment">#误差的平方偏导后*2</span></span><br><span class="line">    gray_w2 = h1.t().mm(gray_y_pred)</span><br><span class="line"> </span><br><span class="line">    grad_h = gray_y_pred.clone()</span><br><span class="line">    grad_h = grad_h.mm(w2.t())</span><br><span class="line">    grad_h.clamp_(min=<span class="number">0</span>)</span><br><span class="line">    grad_w1 = x.t().mm(grad_h)</span><br><span class="line"> </span><br><span class="line">    w1 -= learning_rate * grad_w1</span><br><span class="line">    w2 -= learning_rate * gray_w2</span><br></pre></td></tr></table></figure><p> 　　以上代码通过最外层的一个大循环来保证 的模型可以进行20层训练，循环内的是神经网络模型具体的前向传播和后向传播代码，参数的优化和更新使用梯度下降来完成。在这个神经网络的前向传播中，通过两个连续的矩阵乘法计算出预测结果，在计算的过程中还对矩阵乘积的结果使用clamp方法进行裁剪，将小于零的值全部重新赋值于0，这就像加上了一个ReLU激活函数的功能。</p><p>　　前向传播得到的预测结果通过 y_pred来表示，在得到了预测值后就可以使用预测值和真实值来计算误差值了。 用loss来表示误差值，对误差值的计算使用了<strong>均方误差函数</strong>。之后的代码部分就是通过实现后向传播来对权重参数进行优化了，为了计算方便， 的代码实现使用的是每个节点的链式求导结果，在通过计算之后，就能够得到每个权重参数对应的梯度分别是grad_w1和grad_w2。在得到参数的梯度值之后，按照之前定义好的学习速率对w1和w2的权重参数进行更新，在代码中每次训练时， 都会对loss的值进行打印输出，以方便看到整个优化过程的效果，所以最后会有20个loss值被打印显示。</p><p>采用误差的平方来衡量损失，因此损失函数为： </p><script type="math/tex; mode=display"> loss =(a-y)</script><script type="math/tex; mode=display">Loss=loss^{2}=(a-y)^{2}</script><p> 根据链式法则:</p><script type="math/tex; mode=display"> z_1 =x*w_1</script><script type="math/tex; mode=display">z_2=z_1*w_2</script><script type="math/tex; mode=display">{dL(a-y)}{dw_2}= \frac {dL}{dz_2}* \frac{dz_2}{dw_2}=2*(a-y)*z_1</script><script type="math/tex; mode=display">\frac{dL(a-y)}{dw_1} = \frac{dL}{dz_2}* \frac{dz_2}{dw_2}* \frac{dw_2}{dw_1}=2*(a-y)*w_2*x</script><hr><h1 id="2-自动梯度"><a href="#2-自动梯度" class="headerlink" title="2 自动梯度"></a>2 自动梯度</h1><p>　　 在上面基于PyTorch深度学习框架搭建了一个简易神经网络模型，并通过在代码中使用前向传播和后向传播实现了对这个模型的训练和对权重参数的额优化，不过该模型在结构上很简单，而且神经网络的代码也不复杂。  在实践中搭建的网络模型都是层次更深的神经网络模型，即深度神经网络模型，结构会有所变化，代码也会更复杂。对于深度的神经网络模型的前向传播使用简单的代码就能实现，但是很难实现涉及该模型中后向传播梯度计算部分的代码，其中最苦难的就是对模型计算逻辑的梳理。</p><p>　　在PyTorch中提供了一种非常方便的方法，可以帮助  实现对模型中后向传播梯度的自动计算，避免了“重复造轮子”，这就是接下来要学习的torch.autograd包，通过torch.autograd包，可以使模型参数自动计算在优化过程中需要用到的梯度值，在很大程度上帮助降低了实现后向传播代码的复杂度。</p><h2 id="torch-autograd和Variable"><a href="#torch-autograd和Variable" class="headerlink" title="torch.autograd和Variable"></a>torch.autograd和Variable</h2><p>　　torch.autograd包的主要功能是完成神经网络后向传播中的链式求导，手动实现链式求导的代码会给  造成很大的困扰，而torch.autograd包中丰富的类减少了这些不必要的麻烦。</p><p>实现自动梯度功能的过程大概分为以下几步：</p><ul><li><p>1 通过输入的Tensor数据类型的变量在神经网络的前向传播过程中生成一张计算图</p></li><li><p>2 根据这个计算图和输出结果准确计算出每个参数需要更新的梯度</p></li><li><p>3 通过完成后向传播完成对参数梯度的更新</p><p>　　在实践中完成自动梯度需要用到torch.autograd包中的Variable类对  定义的Tensor数据类型变量进行封装，在封装后，计算图中的各个节点就是一个variable 对象，这样才能应用自动梯度的功能。autograd package是PyTorch中所有神经网络的核心。先了解一些基本知识，然后开始训练第一个神经网络。autograd package提供了Tensors上所有运算的自动求导功能。它是一个按运行定义（define-by-run）的框架，这意味着反向传播是依据代码运行情况而定义的，并且每一个单次迭代都可能不相同。</p></li></ul><p>　　autograd.Variable 是这个package的中心类。它打包了一个Tensor，并且支持几乎所有运算。一旦你完成了你的计算，可以调用.backward()，所有梯度就可以自动计算。<br>　　你可以使用.data属性来访问原始tensor。相对于变量的梯度值可以被积累到.grad中。<br>　　这里还有一个类对于自动梯度的执行是很重要的：Function（函数）<br>　　变量和函数是相互关联的，并且建立一个非循环图。每一个变量有一个.grad_fn属性，它可以引用一个创建了变量的函数（除了那些用户创建的变量——他们的grad_fn是空的）。<br>　　如果想要计算导数，可以调用Variable上的.backward()。如果变量是标量（只有一个元素），你不需要为backward()确定任何参数。但是，如果它有多个元素，你需要确定grad_output参数（这是一个具有匹配形状的tensor）。</p><p>　　如果已经按照如上的方式完成了相关操作，则在选中了计算图中的某个节点时，这个节点必定是一个Variable对象，用X表示  选中的节点，那么X.data代表Tensor数据类型 的变量，X.grad也是一个Variable对象，不过他代表的是X的梯度，在想访问梯度值的时候需要X.grad.data</p><p>　　下面通过一个自动剃度的实例来看看如何使用torch.autograd.Variable类和torch.autograd包，  同样搭建一个二层结构的神经网络模型，这有利于  之前搭建的简易神经网络模型的训练和优化过程进行对比，重新实现。</p><h2 id="2-1-导入包"><a href="#2-1-导入包" class="headerlink" title="2.1 导入包"></a>2.1 导入包</h2><p>　　代码的开始处是相关包的导入，但是在代码中增加一行，from torch.autograd import Variable，之前定义的不变：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 批量输入的数据量</span></span><br><span class="line">batch_n = <span class="number">100</span></span><br><span class="line"><span class="comment"># 通过隐藏层后输出的特征数</span></span><br><span class="line">hidden_layer = <span class="number">100</span></span><br><span class="line"><span class="comment"># 输入数据的特征个数</span></span><br><span class="line">input_data = <span class="number">1000</span></span><br><span class="line"><span class="comment"># 最后输出的分类结果数</span></span><br><span class="line">output_data = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>其中：batch_n是在一个批次中输入数据的数量，值是100，这意味着  在一个批次中输入100个数据，同时，每个数据包含的数据特征有input_data个，因为input_data的值是1000，所以每个数据的特征就是1000个，hidden_layer用于定义经过隐藏层后保留的数据特征的个数，这里有100个，因为  的模型只考虑一层隐藏层，所以在代码中仅仅定义了一个隐藏层的参数；output_data是输出的数据，值是10，  可以将输出的数据看作一个分类结果值得数量，个数10表示  最后要得到10个分类结果值。</p><h2 id="2-2-初始化权重"><a href="#2-2-初始化权重" class="headerlink" title="2.2 初始化权重"></a>2.2 初始化权重</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = Variable(torch.randn(batch_n , input_data) , requires_grad = <span class="literal">False</span>)</span><br><span class="line">y = Variable(torch.randn(batch_n , output_data) , requires_grad = <span class="literal">False</span>)</span><br><span class="line"> </span><br><span class="line">w1 = Variable(torch.randn(input_data,hidden_layer),requires_grad = <span class="literal">True</span>)</span><br><span class="line">w2 = Variable(torch.randn(hidden_layer,output_data),requires_grad = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>　“Variable(torch.randn(batch_n, input_data), requires_grad = False)”这段代码就是之前讲到的用 Variable类对 Tensor数据类型变量进行封装的操作。在以上代码中还使用了一个requires_grad参数，这个参数的赋值类型是布尔型，如果requires_grad的值是False，那么表示该变量在进行自动梯度计算的过程中不会保留梯度值。  将输入的数据x和输出的数据y的requires_grad参数均设置为False，这是因为这两个变量并不是  的模型需要优化的参数，而两个权重w1和w2的requires_grad参数的值为True</p><h2 id="2-3-定义训练次数和学习效率"><a href="#2-3-定义训练次数和学习效率" class="headerlink" title="2.3 定义训练次数和学习效率"></a>2.3 定义训练次数和学习效率</h2><p>　　在定义好输入，输出和权重参数值之后，就可以开始训练模型和优化权重参数了，在此之前，  还需要明确训练的总次数和学习效率，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">epoch_n = <span class="number">20</span></span><br><span class="line">learning_rate = <span class="number">1e-6</span></span><br></pre></td></tr></table></figure><p>　　和之前一样，在以上代码中使用了epoch_n定义训练的次数，epoch_n的值为20，所以  需要通过循环的方式让程序进行20次训练，来完成对初始化权重参数的优化和调整。在优化的过程中使用的学习效率learning_rate的值为1e-6，表示0.000001，接下来对模型进行正式训练并对参数进行优化。</p><h2 id="2-4-新的模型训练和参数优化"><a href="#2-4-新的模型训练和参数优化" class="headerlink" title="2.4 新的模型训练和参数优化"></a>2.4 新的模型训练和参数优化</h2><p> 　　下面代码通过最外层的一个大循环来保证  的模型可以进行20次训练，循环内的是神经网络模型具体的前向传播和后向传播代码。参数的优化和更新使用梯度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(epoch_n):</span><br><span class="line"> </span><br><span class="line">    y_pred = x.mm(w1).clamp(min= <span class="number">0</span> ).mm(w2)</span><br><span class="line">    loss = (y_pred - y).pow(<span class="number">2</span>).sum()</span><br><span class="line">    print(<span class="string">"Epoch:&#123;&#125; , Loss:&#123;:.4f&#125;"</span>.format(epoch, loss.data))</span><br><span class="line"> </span><br><span class="line">    loss.backward()</span><br><span class="line">    w1.data -= learning_rate * w1.grad.data</span><br><span class="line">    w2.data -= learning_rate * w2.grad.data</span><br><span class="line"> </span><br><span class="line">    w1.grad.data.zero_()</span><br><span class="line">    w2.grad.data.zero_()</span><br></pre></td></tr></table></figure><p> 　　和之前的代码相比，当前的代码更简洁了，之前代码中的后向传播计算部分变成了新代码中的 loss.backward()，这个函数的功能在于让模型根据计算图自动计算每个节点的梯度值并根据需求进行保留，有了这一步，  的权重参数 w1.data和 w2.data就可以直接使用在自动梯度过程中求得的梯度值w1.data.grad和w2.data.grad，并结合学习速率来对现有的参数进行更新、优化了。在代码的最后还要将本次计算得到的各个参数节点的梯度值通过grad.data.zero_()全部置零，如果不置零，则计算的梯度值会被一直累加，这样就会影响到后续的计算。同样，在整个模型的训练和优化过程中，每个循环都加入了打印loss值的操作，所以最后会得到20个loss值的打印输出。</p><h2 id="2-5-自定义传播函数"><a href="#2-5-自定义传播函数" class="headerlink" title="2.5 自定义传播函数"></a>2.5 自定义传播函数</h2><p> 　　其实除了可以采用自动梯度方法，  还可以通过构建一个继承了torch.nn.Module的新类，来完成对前向传播函数和后向传播函数的重写。在这个新类中，  使用forward作为前向传播函数的关键字，使用backward作为后向传播函数的关键字。下面介绍如何使用自定义传播函数的方法，来调整之前具备自动梯度功能的简易神经网络模型。整个代码的开始部分如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 批量输入的数据量</span></span><br><span class="line">batch_n = <span class="number">100</span></span><br><span class="line"><span class="comment"># 通过隐藏层后输出的特征数</span></span><br><span class="line">hidden_layer = <span class="number">100</span></span><br><span class="line"><span class="comment"># 输入数据的特征个数</span></span><br><span class="line">input_data = <span class="number">1000</span></span><br><span class="line"><span class="comment"># 最后输出的分类结果数</span></span><br><span class="line">output_data = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>　　和之前的代码一样，在代码的开始部分同样是导入必要的包、类，并定义需要用到的4 个变量。下面看看新的代码部分是如何定义  的前向传播 forward 函数和后向传播backward函数的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Model(torch.nn.Module):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(Model,self).__init__()</span><br><span class="line">     </span><br><span class="line">    def forward(self,input,w1,w2):</span><br><span class="line">        x = torch.mm(input,w1)</span><br><span class="line">        x = torch.clamp(x,min=0)</span><br><span class="line">        x = torch.mm(x,w2)</span><br><span class="line">        return x</span><br><span class="line">     </span><br><span class="line">    def backward(self):</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p>以上代码展示了一个比较常用的Python类的构造方式：首先通过class Model(torch.nn.Module)完成了类继承的操作，之后分别是类的初始化，以及forward函数和backward函数。forward函数实现了模型的前向传播中的矩阵运算，backward实现了模型的后向传播中的自动梯度计算，后向传播如果没有特别的需求，则在一般情况下不用进行调整。在定义好类之后，  就可以对其进行调用了，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = Model()</span><br></pre></td></tr></table></figure><p>这一系列操作相当于完成了对简易神经网络的搭建，然后就只剩下对模型进行训练和对参数进行优化的部分了，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 批量输入的数据量</span></span><br><span class="line">batch_n = <span class="number">100</span></span><br><span class="line"><span class="comment"># 通过隐藏层后输出的特征数</span></span><br><span class="line">hidden_layer = <span class="number">100</span></span><br><span class="line"><span class="comment"># 输入数据的特征个数</span></span><br><span class="line">input_data = <span class="number">1000</span></span><br><span class="line"><span class="comment"># 最后输出的分类结果数</span></span><br><span class="line">output_data = <span class="number">10</span></span><br><span class="line"> </span><br><span class="line">x = Variable(torch.randn(batch_n , input_data) , requires_grad = <span class="literal">False</span>)</span><br><span class="line">y = Variable(torch.randn(batch_n , output_data) , requires_grad = <span class="literal">False</span>)</span><br><span class="line"> </span><br><span class="line">w1 = Variable(torch.randn(input_data,hidden_layer),requires_grad = <span class="literal">True</span>)</span><br><span class="line">w2 = Variable(torch.randn(hidden_layer,output_data),requires_grad = <span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 训练次数设置为20</span></span><br><span class="line">epoch_n = <span class="number">20</span></span><br><span class="line"><span class="comment"># 将学习效率设置为0.000001</span></span><br><span class="line">learning_rate = <span class="number">1e-6</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(epoch_n):</span><br><span class="line"> </span><br><span class="line">    y_pred = x.mm(w1).clamp(min= <span class="number">0</span> ).mm(w2)</span><br><span class="line">    loss = (y_pred - y).pow(<span class="number">2</span>).sum()</span><br><span class="line">    print(<span class="string">"Epoch:&#123;&#125; , Loss:&#123;:.4f&#125;"</span>.format(epoch, loss.data))</span><br><span class="line"> </span><br><span class="line">    loss.backward()</span><br><span class="line">    w1.data -= learning_rate * w1.grad.data</span><br><span class="line">    w2.data -= learning_rate * w2.grad.data</span><br><span class="line"> </span><br><span class="line">    w1.grad.data.zero_()</span><br><span class="line">    w2.grad.data.zero_()</span><br></pre></td></tr></table></figure><p>　 这里，变量的赋值、训练次数和学习速率的定义，以及模型训练和参数优化使用的代码，和在 6.2.1节中使用的代码没有太大的差异，不同的是，  的模型通过“y_pred =model(x, w1, w2)”来完成对模型预测值的输出，并且整个训练部分的代码被简化了。在20次训练后，20个loss值的打印输出如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 批量输入的数据量</span></span><br><span class="line">batch_n = <span class="number">100</span></span><br><span class="line"><span class="comment"># 通过隐藏层后输出的特征数</span></span><br><span class="line">hidden_layer = <span class="number">100</span></span><br><span class="line"><span class="comment"># 输入数据的特征个数</span></span><br><span class="line">input_data = <span class="number">1000</span></span><br><span class="line"><span class="comment"># 最后输出的分类结果数</span></span><br><span class="line">output_data = <span class="number">10</span></span><br><span class="line"> </span><br><span class="line">x = Variable(torch.randn(batch_n , input_data) , requires_grad = <span class="literal">False</span>)</span><br><span class="line">y = Variable(torch.randn(batch_n , output_data) , requires_grad = <span class="literal">False</span>)</span><br><span class="line"> </span><br><span class="line">w1 = Variable(torch.randn(input_data,hidden_layer),requires_grad = <span class="literal">True</span>)</span><br><span class="line">w2 = Variable(torch.randn(hidden_layer,output_data),requires_grad = <span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 训练次数设置为20</span></span><br><span class="line">epoch_n = <span class="number">20</span></span><br><span class="line"><span class="comment"># 将学习效率设置为0.000001</span></span><br><span class="line">learning_rate = <span class="number">1e-6</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(epoch_n):</span><br><span class="line"> </span><br><span class="line">    y_pred = x.mm(w1).clamp(min= <span class="number">0</span> ).mm(w2)</span><br><span class="line">    loss = (y_pred - y).pow(<span class="number">2</span>).sum()</span><br><span class="line">    print(<span class="string">"Epoch:&#123;&#125; , Loss:&#123;:.4f&#125;"</span>.format(epoch, loss.data))</span><br><span class="line"> </span><br><span class="line">    loss.backward()</span><br><span class="line">    w1.data -= learning_rate * w1.grad.data</span><br><span class="line">    w2.data -= learning_rate * w2.grad.data</span><br><span class="line"> </span><br><span class="line">    w1.grad.data.zero_()</span><br><span class="line">    w2.grad.data.zero_()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Epoch:0 , Loss:42383984.0000</span><br><span class="line">Epoch:1 , Loss:63978384.0000</span><br><span class="line">Epoch:2 , Loss:211757952.0000</span><br><span class="line">Epoch:3 , Loss:577945792.0000</span><br><span class="line">Epoch:4 , Loss:296412704.0000</span><br><span class="line">Epoch:5 , Loss:7378756.5000</span><br><span class="line">Epoch:6 , Loss:4554581.0000</span><br><span class="line">Epoch:7 , Loss:3130111.5000</span><br><span class="line">Epoch:8 , Loss:2335843.0000</span><br><span class="line">Epoch:9 , Loss:1857806.3750</span><br><span class="line">Epoch:10 , Loss:1549259.2500</span><br><span class="line">Epoch:11 , Loss:1336432.5000</span><br><span class="line">Epoch:12 , Loss:1180022.3750</span><br><span class="line">Epoch:13 , Loss:1058830.1250</span><br><span class="line">Epoch:14 , Loss:960660.6875</span><br><span class="line">Epoch:15 , Loss:878386.6250</span><br><span class="line">Epoch:16 , Loss:807673.3125</span><br><span class="line">Epoch:17 , Loss:745840.7500</span><br><span class="line">Epoch:18 , Loss:691052.0000</span><br><span class="line">Epoch:19 , Loss:642167.3125</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> deep learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Task05:多种卷积网络模型</title>
      <link href="/2020/03/21/Task05-%E5%A4%9A%E7%A7%8D%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/03/21/Task05-%E5%A4%9A%E7%A7%8D%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="深度卷积神经网络（AlexNet）"><a href="#深度卷积神经网络（AlexNet）" class="headerlink" title="深度卷积神经网络（AlexNet）"></a>深度卷积神经网络（AlexNet）</h1><p> LeNet:  在大的真实数据集上的表现并不尽如⼈意。    </p><p>1.神经网络计算复杂。<br>2.还没有⼤量深⼊研究参数初始化和⾮凸优化算法等诸多领域。  </p><p>机器学习的特征提取:手工定义的特征提取函数<br>神经网络的特征提取：通过学习得到数据的多级表征，并逐级表⽰越来越抽象的概念或模式。  </p><p>神经网络发展的限制:数据、硬件</p><h3 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h3><p>首次证明了学习到的特征可以超越⼿⼯设计的特征，从而⼀举打破计算机视觉研究的前状。<br><strong>特征：</strong></p><ol><li>8层变换，其中有5层卷积（1/3/5/6/7）和2层全连接隐藏层（9/10），以及1个全连接输出层（11）。</li><li>将sigmoid激活函数改成了更加简单的ReLU激活函数。</li><li>用Dropout来控制全连接层的模型复杂度。</li><li>引入数据增强，如翻转、裁剪和颜色变化，从而进一步扩大数据集来缓解过拟合。</li></ol><p><img src="/2020/03/21/Task05-多种卷积网络模型/1.png" alt="Image Name"></p><a id="more"></a><hr><h1 id="使用重复元素的网络（VGG）"><a href="#使用重复元素的网络（VGG）" class="headerlink" title="使用重复元素的网络（VGG）"></a>使用重复元素的网络（VGG）</h1><p><strong>VGG：</strong>通过重复使⽤简单的基础块来构建深度模型。 </p><p>Block:数个相同的填充为1、窗口形状为$3\times 3$的卷积层,接上一个步幅为2、窗口形状为$2\times 2$的最大池化层。  </p><p>卷积层保持输入的高和宽不变，而池化层则对其减半。</p><p><img src="/2020/03/21/Task05-多种卷积网络模型/2.png" alt="Image Name"></p><hr><h1 id="网络中的网络（NiN）"><a href="#网络中的网络（NiN）" class="headerlink" title="网络中的网络（NiN）"></a>网络中的网络（NiN）</h1><p><strong>LeNet、AlexNet</strong>和<strong>VGG：</strong>先以由卷积层构成的模块充分抽取 空间特征，再以由全连接层构成的模块来输出分类结果。 </p><p>NiN：串联多个由卷积层和“全连接”层构成的小⽹络来构建⼀个深层⽹络。 </p><p>⽤了输出通道数等于标签类别数的NiN块，然后使⽤全局平均池化层对每个通道中所有元素求平均并直接⽤于分类。  </p><p><img src="/2020/03/21/Task05-多种卷积网络模型/3.png" alt="Image Name"></p><p>1×1卷积核作用   </p><p><strong>1.</strong>放缩通道数：通过控制卷积核的数量达到通道数的放缩。  </p><p><strong>2.</strong>增加非线性。1×1卷积核的卷积过程相当于全连接层的计算过程，并且还加入了非线性激活函数，从而可以增加网络的非线性。  </p><p><strong>3.</strong>计算参数少   </p><p><strong>NiN网络特性：</strong></p><p>NiN重复使⽤由卷积层和代替全连接层的1×1卷积层构成的NiN块来构建深层⽹络。 </p><p>NiN去除了容易造成过拟合的全连接输出层，而是将其替换成输出通道数等于标签类别数 的NiN块和全局平均池化层。   </p><p>NiN的以上设计思想影响了后⾯⼀系列卷积神经网络的设计。  </p><hr><h1 id="GoogLeNet"><a href="#GoogLeNet" class="headerlink" title="GoogLeNet"></a>GoogLeNet</h1><ol><li>由Inception基础块组成。  </li><li>Inception块相当于⼀个有4条线路的⼦⽹络。它通过不同窗口形状的卷积层和最⼤池化层来并⾏抽取信息，并使⽤1×1卷积层减少通道数从而降低模型复杂度。   </li><li>可以⾃定义的超参数是每个层的输出通道数，我们以此来控制模型复杂度。 </li></ol><p><img src="/2020/03/21/Task05-多种卷积网络模型/4.png" alt="Image Name"></p><p></p><h4><center>完整模型结构 </center> </h4><br><img src="/2020/03/21/Task05-多种卷积网络模型/5.png" alt="Image Name"><p></p>]]></content>
      
      
      
        <tags>
            
            <tag> deep learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Task04:卷积神经网络</title>
      <link href="/2020/03/18/Task04-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/2020/03/18/Task04-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h2><h3 id="二维互相关运算"><a href="#二维互相关运算" class="headerlink" title="二维互相关运算"></a>二维互相关运算</h3><p>二维互相关（cross-correlation）运算的输入是一个二维输入数组和一个二维核（kernel）数组，输出也是一个二维数组，其中核数组通常称为卷积核或过滤器（filter）。卷积核的尺寸通常小于输入数组，卷积核在输入数组上滑动，在每个位置上，卷积核与该位置处的输入子数组按元素相乘并求和，得到输出数组中相应位置的元素。图1展示了一个互相关运算的例子，阴影部分分别是输入的第一个计算区域、核数组以及对应的输出。</p><p><img src="/2020/03/18/Task04-卷积神经网络/1.png" alt="Image Name"></p><center>图1 二维互相关运算</center><h3 id="互相关运算与卷积运算"><a href="#互相关运算与卷积运算" class="headerlink" title="互相关运算与卷积运算"></a>互相关运算与卷积运算</h3><p>卷积层得名于卷积运算，但卷积层中用到的并非卷积运算而是互相关运算。我们将核数组上下翻转、左右翻转，再与输入数组做互相关运算，这一过程就是卷积运算。由于卷积层的核数组是可学习的，所以使用互相关运算与使用卷积运算并无本质区别。</p><a id="more"></a><h3 id="特征图与感受野"><a href="#特征图与感受野" class="headerlink" title="特征图与感受野"></a>特征图与感受野</h3><p>二维卷积层输出的二维数组可以看作是输入在空间维度（宽和高）上某一级的表征，也叫特征图（feature map）。影响元素$x$的前向计算的所有可能输入区域（可能大于输入的实际尺寸）叫做$x$的感受野（receptive field）。</p><p>以图1为例，输入中阴影部分的四个元素是输出中阴影部分元素的感受野。我们将图中形状为$2 \times 2$的输出记为$Y$，将$Y$与另一个形状为$2 \times 2$的核数组做互相关运算，输出单个元素$z$。那么，$z$在$Y$上的感受野包括$Y$的全部四个元素，在输入上的感受野包括其中全部9个元素。可见，我们可以通过更深的卷积神经网络使特征图中单个元素的感受野变得更加广阔，从而捕捉输入上更大尺寸的特征。</p><h3 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h3><p>填充（padding）是指在输入高和宽的两侧填充元素（通常是0元素），图2里我们在原输入高和宽的两侧分别添加了值为0的元素。</p><p><img src="/2020/03/18/Task04-卷积神经网络/1-5.png" alt="Image Name"></p><center>图2 在输入的高和宽两侧分别填充了0元素的二维互相关计算</center><p>如果原输入的高和宽是$n_h$和$n_w$，卷积核的高和宽是$k_h$和$k_w$，在高的两侧一共填充$p_h$行，在宽的两侧一共填充$p_w$列，则输出形状为：</p><script type="math/tex; mode=display">(n_h+p_h-k_h+1)\times(n_w+p_w-k_w+1)</script><p>我们在卷积神经网络中使用奇数高宽的核，比如$3 \times 3$，$5 \times 5$的卷积核，对于高度（或宽度）为大小为$2 k + 1$的核，令步幅为1，在高（或宽）两侧选择大小为$k$的填充，便可保持输入与输出尺寸相同。</p><h3 id="步幅"><a href="#步幅" class="headerlink" title="步幅"></a>步幅</h3><p>在互相关运算中，卷积核在输入数组上滑动，每次滑动的行数与列数即是步幅（stride）。此前我们使用的步幅都是1，图3展示了在高上步幅为3、在宽上步幅为2的二维互相关运算。</p><p><img src="/2020/03/18/Task04-卷积神经网络/2.png" alt="Image Name"></p><center>图3 高和宽上步幅分别为3和2的二维互相关运算</center><p>一般来说，当高上步幅为$s_h$，宽上步幅为$s_w$时，输出形状为：</p><script type="math/tex; mode=display">\lfloor(n_h+p_h-k_h+s_h)/s_h\rfloor \times \lfloor(n_w+p_w-k_w+s_w)/s_w\rfloor</script><p>如果$p_h=k_h-1$，$p_w=k_w-1$，那么输出形状将简化为$\lfloor(n_h+s_h-1)/s_h\rfloor \times \lfloor(n_w+s_w-1)/s_w\rfloor$。更进一步，如果输入的高和宽能分别被高和宽上的步幅整除，那么输出形状将是$(n_h / s_h) \times (n_w/s_w)$。</p><p>当$p_h = p_w = p$时，我们称填充为$p$；当$s_h = s_w = s$时，我们称步幅为$s$。</p><hr><h2 id="多输入通道和多输出通道"><a href="#多输入通道和多输出通道" class="headerlink" title="多输入通道和多输出通道"></a>多输入通道和多输出通道</h2><p>之前的输入和输出都是二维数组，但真实数据的维度经常更高。例如，彩色图像在高和宽2个维度外还有RGB（红、绿、蓝）3个颜色通道。假设彩色图像的高和宽分别是$h$和$w$（像素），那么它可以表示为一个$3 \times h \times w$的多维数组，我们将大小为3的这一维称为通道（channel）维。</p><h3 id="多输入通道"><a href="#多输入通道" class="headerlink" title="多输入通道"></a>多输入通道</h3><p>卷积层的输入可以包含多个通道，图4展示了一个含2个输入通道的二维互相关计算的例子。</p><p><img src="/2020/03/18/Task04-卷积神经网络/3.png" alt="Image Name"></p><center>图4 含2个输入通道的互相关计算</center><p>假设输入数据的通道数为$c_i$，卷积核形状为$k_h\times k_w$，我们为每个输入通道各分配一个形状为$k_h\times k_w$的核数组，将$c_i$个互相关运算的二维输出按通道相加，得到一个二维数组作为输出。我们把$c_i$个核数组在通道维上连结，即得到一个形状为$c_i\times k_h\times k_w$的卷积核。</p><h3 id="多输出通道"><a href="#多输出通道" class="headerlink" title="多输出通道"></a>多输出通道</h3><p>卷积层的输出也可以包含多个通道，设卷积核输入通道数和输出通道数分别为$c_i$和$c_o$，高和宽分别为$k_h$和$k_w$。如果希望得到含多个通道的输出，我们可以为每个输出通道分别创建形状为$c_i\times k_h\times k_w$的核数组，将它们在输出通道维上连结，卷积核的形状即$c_o\times c_i\times k_h\times k_w$。</p><p>对于输出通道的卷积核，我们提供这样一种理解，一个$c_i \times k_h \times k_w$的核数组可以提取某种局部特征，但是输入可能具有相当丰富的特征，我们需要有多个这样的$c_i \times k_h \times k_w$的核数组，不同的核数组提取的是不同的特征。</p><h3 id="1x1卷积层"><a href="#1x1卷积层" class="headerlink" title="1x1卷积层"></a>1x1卷积层</h3><p>最后讨论形状为$1 \times 1$的卷积核，我们通常称这样的卷积运算为$1 \times 1$卷积，称包含这种卷积核的卷积层为$1 \times 1$卷积层。图5展示了使用输入通道数为3、输出通道数为2的$1\times 1$卷积核的互相关计算。</p><p><img src="/2020/03/18/Task04-卷积神经网络/4.png" alt="Image Name"></p><center>图5 1x1卷积核的互相关计算。输入和输出具有相同的高和宽</center><p>$1 \times 1$卷积核可在不改变高宽的情况下，调整通道数。$1 \times 1$卷积核不识别高和宽维度上相邻元素构成的模式，其主要计算发生在通道维上。假设我们将通道维当作特征维，将高和宽维度上的元素当成数据样本，那么$1\times 1$卷积层的作用与全连接层等价。</p><h2 id="卷积层与全连接层的对比"><a href="#卷积层与全连接层的对比" class="headerlink" title="卷积层与全连接层的对比"></a>卷积层与全连接层的对比</h2><p>二维卷积层经常用于处理图像，与此前的全连接层相比，它主要有两个优势：</p><p>一是全连接层把图像展平成一个向量，在输入图像上相邻的元素可能因为展平操作不再相邻，网络难以捕捉局部信息。而卷积层的设计，天然地具有提取局部信息的能力。</p><p>二是卷积层的参数量更少。不考虑偏置的情况下，一个形状为$(c_i, c_o, h, w)$的卷积核的参数量是$c_i \times c_o \times h \times w$，与输入图像的宽高无关。假如一个卷积层的输入和输出形状分别是$(c_1, h_1, w_1)$和$(c_2, h_2, w_2)$，如果要用全连接层进行连接，参数数量就是$c_1 \times c_2 \times h_1 \times w_1 \times h_2 \times w_2$。使用卷积层可以以较少的参数数量来处理更大的图像。</p><hr><h2 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h2><h3 id="二维池化层"><a href="#二维池化层" class="headerlink" title="二维池化层"></a>二维池化层</h3><p>池化层主要用于缓解卷积层对位置的过度敏感性。同卷积层一样，池化层每次对输入数据的一个固定形状窗口（又称池化窗口）中的元素计算输出，池化层直接计算池化窗口内元素的最大值或者平均值，该运算也分别叫做最大池化或平均池化。图6展示了池化窗口形状为$2\times 2$的最大池化。</p><p><img src="/2020/03/18/Task04-卷积神经网络/6.png" alt="Image Name"></p><center>图6 池化窗口形状为 2 x 2 的最大池化</center><p>二维平均池化的工作原理与二维最大池化类似，但将最大运算符替换成平均运算符。池化窗口形状为$p \times q$的池化层称为$p \times q$池化层，其中的池化运算叫作$p \times q$池化。</p><p>池化层也可以在输入的高和宽两侧填充并调整窗口的移动步幅来改变输出形状。池化层填充和步幅与卷积层填充和步幅的工作机制一样。</p><p>在处理多通道输入数据时，池化层对每个输入通道分别池化，但不会像卷积层那样将各通道的结果按通道相加。这意味着池化层的输出通道数与输入通道数相等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> deep learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Task03：过拟合、欠拟合及其解决方案；梯度消失、梯度爆炸</title>
      <link href="/2020/02/18/Task03%EF%BC%9A%E8%BF%87%E6%8B%9F%E5%90%88%E3%80%81%E6%AC%A0%E6%8B%9F%E5%90%88%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9B%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E3%80%81%E6%A2%AF%E5%BA%A6%E7%88%86%E7%82%B8/"/>
      <url>/2020/02/18/Task03%EF%BC%9A%E8%BF%87%E6%8B%9F%E5%90%88%E3%80%81%E6%AC%A0%E6%8B%9F%E5%90%88%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9B%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E3%80%81%E6%A2%AF%E5%BA%A6%E7%88%86%E7%82%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="过拟合、欠拟合及其解决方案"><a href="#过拟合、欠拟合及其解决方案" class="headerlink" title="过拟合、欠拟合及其解决方案"></a>过拟合、欠拟合及其解决方案</h2><ol><li>过拟合、欠拟合的概念</li><li>权重衰减</li><li>丢弃法</li></ol><h1 id="模型选择、过拟合和欠拟合"><a href="#模型选择、过拟合和欠拟合" class="headerlink" title="模型选择、过拟合和欠拟合"></a>模型选择、过拟合和欠拟合</h1><h2 id="训练误差和泛化误差"><a href="#训练误差和泛化误差" class="headerlink" title="训练误差和泛化误差"></a>训练误差和泛化误差</h2><p>在解释上述现象之前，我们需要区分训练误差（training error）和泛化误差（generalization error）。通俗来讲，前者指模型在训练数据集上表现出的误差，后者指模型在任意一个测试数据样本上表现出的误差的期望，并常常通过测试数据集上的误差来近似。计算训练误差和泛化误差可以使用之前介绍过的损失函数，例如线性回归用到的平方损失函数和softmax回归用到的交叉熵损失函数。</p><p>机器学习模型应关注降低泛化误差。</p><a id="more"></a><h2 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h2><h3 id="验证数据集"><a href="#验证数据集" class="headerlink" title="验证数据集"></a>验证数据集</h3><p>从严格意义上讲，测试集只能在所有超参数和模型参数选定后使用一次。不可以使用测试数据选择模型，如调参。由于无法从训练误差估计泛化误差，因此也不应只依赖训练数据选择模型。鉴于此，我们可以预留一部分在训练数据集和测试数据集以外的数据来进行模型选择。这部分数据被称为验证数据集，简称验证集（validation set）。例如，我们可以从给定的训练集中随机选取一小部分作为验证集，而将剩余部分作为真正的训练集。</p><h3 id="K折交叉验证"><a href="#K折交叉验证" class="headerlink" title="K折交叉验证"></a>K折交叉验证</h3><p>由于验证数据集不参与模型训练，当训练数据不够用时，预留大量的验证数据显得太奢侈。一种改善的方法是K折交叉验证（K-fold cross-validation）。在K折交叉验证中，我们把原始训练数据集分割成K个不重合的子数据集，然后我们做K次模型训练和验证。每一次，我们使用一个子数据集验证模型，并使用其他K-1个子数据集来训练模型。在这K次训练和验证中，每次用来验证模型的子数据集都不同。最后，我们对这K次训练误差和验证误差分别求平均。</p><h2 id="过拟合和欠拟合"><a href="#过拟合和欠拟合" class="headerlink" title="过拟合和欠拟合"></a>过拟合和欠拟合</h2><p>接下来，我们将探究模型训练中经常出现的两类典型问题：</p><ul><li>一类是模型无法得到较低的训练误差，我们将这一现象称作欠拟合（underfitting）；</li><li>另一类是模型的训练误差远小于它在测试数据集上的误差，我们称该现象为过拟合（overfitting）。<br>在实践中，我们要尽可能同时应对欠拟合和过拟合。虽然有很多因素可能导致这两种拟合问题，在这里我们重点讨论两个因素：模型复杂度和训练数据集大小。</li></ul><h3 id="模型复杂度"><a href="#模型复杂度" class="headerlink" title="模型复杂度"></a>模型复杂度</h3><p>为了解释模型复杂度，我们以多项式函数拟合为例。给定一个由标量数据特征$x$和对应的标量标签$y$组成的训练数据集，多项式函数拟合的目标是找一个$K$阶多项式函数</p><script type="math/tex; mode=display"> \hat{y} = b + \sum_{k=1}^K x^k w_k</script><p>来近似 $y$。在上式中，$w_k$是模型的权重参数，$b$是偏差参数。与线性回归相同，多项式函数拟合也使用平方损失函数。特别地，一阶多项式函数拟合又叫线性函数拟合。</p><p>给定训练数据集，模型复杂度和误差之间的关系：</p><p><img src="/2020/02/18/Task03：过拟合、欠拟合及其解决方案；梯度消失、梯度爆炸/TIM截图20200218223234.png" alt></p><h3 id="训练数据集大小"><a href="#训练数据集大小" class="headerlink" title="训练数据集大小"></a>训练数据集大小</h3><p>影响欠拟合和过拟合的另一个重要因素是训练数据集的大小。一般来说，如果训练数据集中样本数过少，特别是比模型参数数量（按元素计）更少时，过拟合更容易发生。此外，泛化误差不会随训练数据集里样本数量增加而增大。因此，在计算资源允许的范围之内，我们通常希望训练数据集大一些，特别是在模型复杂度较高时，例如层数较多的深度学习模型。</p><hr><h3 id="三阶多项式函数拟合（正常）"><a href="#三阶多项式函数拟合（正常）" class="headerlink" title="三阶多项式函数拟合（正常）"></a>三阶多项式函数拟合（正常）</h3><p><img src="/2020/02/18/Task03：过拟合、欠拟合及其解决方案；梯度消失、梯度爆炸/TIM截图20200218223535.png" alt></p><hr><h3 id="线性函数拟合（欠拟合）"><a href="#线性函数拟合（欠拟合）" class="headerlink" title="线性函数拟合（欠拟合）"></a>线性函数拟合（欠拟合）</h3><p><img src="/2020/02/18/Task03：过拟合、欠拟合及其解决方案；梯度消失、梯度爆炸/TIM截图20200218223711.png" alt></p><hr><h3 id="训练样本不足（过拟合）"><a href="#训练样本不足（过拟合）" class="headerlink" title="训练样本不足（过拟合）"></a>训练样本不足（过拟合）</h3><p><img src="/2020/02/18/Task03：过拟合、欠拟合及其解决方案；梯度消失、梯度爆炸/TIM截图20200218223809.png" alt></p><hr><h1 id="权重衰减"><a href="#权重衰减" class="headerlink" title="权重衰减"></a>权重衰减</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>权重衰减等价于 $L_2$ 范数正则化（regularization）。正则化通过为模型损失函数添加惩罚项使学出的模型参数值较小，是应对过拟合的常用手段。</p><h2 id="L2-范数正则化（regularization）"><a href="#L2-范数正则化（regularization）" class="headerlink" title="L2 范数正则化（regularization）"></a>L2 范数正则化（regularization）</h2><p>$L_2$范数正则化在模型原损失函数基础上添加$L_2$范数惩罚项，从而得到训练所需要最小化的函数。$L_2$范数惩罚项指的是模型权重参数每个元素的平方和与一个正的常数的乘积。以线性回归中的线性回归损失函数为例</p><script type="math/tex; mode=display"> \ell(w_1, w_2, b) = \frac{1}{n} \sum_{i=1}^n \frac{1}{2}\left(x_1^{(i)} w_1 + x_2^{(i)} w_2 + b - y^{(i)}\right)^2</script><p>其中$w_1, w_2$是权重参数，$b$是偏差参数，样本$i$的输入为$x_1^{(i)}, x_2^{(i)}$，标签为$y^{(i)}$，样本数为$n$。将权重参数用向量$\boldsymbol{w} = [w_1, w_2]$表示，带有$L_2$范数惩罚项的新损失函数为</p><script type="math/tex; mode=display">\ell(w_1, w_2, b) + \frac{\lambda}{2n} |{w}|^2,</script><p>其中超参数$\lambda &gt; 0$。当权重参数均为0时，惩罚项最小。当$\lambda$较大时，惩罚项在损失函数中的比重较大，这通常会使学到的权重参数的元素较接近0。当$\lambda$设为0时，惩罚项完全不起作用。上式中$L_2$范数平方$|\boldsymbol{w}|^2$展开后得到$w_1^2 + w_2^2$。<br>有了$L_2$范数惩罚项后，在小批量随机梯度下降中，我们将线性回归一节中权重$w_1$和$w_2$的迭代方式更改为</p><script type="math/tex; mode=display"> \begin{aligned} w_1 &\leftarrow \left(1- \frac{\eta\lambda}{|\mathcal{B}|} \right)w_1 - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}}x_1^{(i)} \left(x_1^{(i)} w_1 + x_2^{(i)} w_2 + b - y^{(i)}\right),\\ w_2 &\leftarrow \left(1- \frac{\eta\lambda}{|\mathcal{B}|} \right)w_2 - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}}x_2^{(i)} \left(x_1^{(i)} w_1 + x_2^{(i)} w_2 + b - y^{(i)}\right). \end{aligned}</script><p>可见，$L_2$范数正则化令权重$w_1$和$w_2$先自乘小于1的数，再减去不含惩罚项的梯度。因此，$L_2$范数正则化又叫权重衰减。权重衰减通过惩罚绝对值较大的模型参数为需要学习的模型增加了限制，这可能对过拟合有效。</p><hr><h1 id="丢弃法"><a href="#丢弃法" class="headerlink" title="丢弃法"></a>丢弃法</h1><p>多层感知机中神经网络图描述了一个单隐藏层的多层感知机。其中输入个数为4，隐藏单元个数为5，且隐藏单元$h_i$（$i=1, \ldots, 5$）的计算表达式为</p><script type="math/tex; mode=display"> h_i = \phi\left(x_1 w_{1i} + x_2 w_{2i} + x_3 w_{3i} + x_4 w_{4i} + b_i\right)</script><p>这里$\phi$是激活函数，$x<em>1, \ldots, x_4$是输入，隐藏单元$i$的权重参数为$w</em>{1i}, \ldots, w_{4i}$，偏差参数为$b_i$。当对该隐藏层使用丢弃法时，该层的隐藏单元将有一定概率被丢弃掉。设丢弃概率为$p$，那么有$p$的概率$h_i$会被清零，有$1-p$的概率$h_i$会除以$1-p$做拉伸。丢弃概率是丢弃法的超参数。具体来说，设随机变量$\xi_i$为0和1的概率分别为$p$和$1-p$。使用丢弃法时我们计算新的隐藏单元$h_i’$</p><script type="math/tex; mode=display"> h_i' = \frac{\xi_i}{1-p} h_i</script><p>由于$E(\xi_i) = 1-p$，因此</p><script type="math/tex; mode=display"> E(h_i') = \frac{E(\xi_i)}{1-p}h_i = h_i</script><p>即丢弃法不改变其输入的期望值。让我们对之前多层感知机的神经网络中的隐藏层使用丢弃法，一种可能的结果如图所示，其中$h_2$和$h_5$被清零。这时输出值的计算不再依赖$h_2$和$h_5$，在反向传播时，与这两个隐藏单元相关的权重的梯度均为0。由于在训练中隐藏层神经元的丢弃是随机的，即$h_1, \ldots, h_5$都有可能被清零，输出层的计算无法过度依赖$h_1, \ldots, h_5$中的任一个，从而在训练模型时起到正则化的作用，并可以用来应对过拟合。在测试模型时，我们为了拿到更加确定性的结果，一般不使用丢弃法</p><p><img src="/2020/02/18/Task03：过拟合、欠拟合及其解决方案；梯度消失、梯度爆炸/TIM截图20200218223954.png" alt></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p><strong>欠拟合现象</strong>：模型无法达到一个较低的误差</p></li><li><p><strong>过拟合现象</strong>：训练误差较低但是泛化误差依然较高，二者相差较大</p></li></ul><hr><h1 id="梯度消失、梯度爆炸"><a href="#梯度消失、梯度爆炸" class="headerlink" title="梯度消失、梯度爆炸"></a>梯度消失、梯度爆炸</h1><ol><li>梯度消失和梯度爆炸</li><li>考虑到环境因素的其他问题</li></ol><hr><h1 id="梯度消失和梯度爆炸"><a href="#梯度消失和梯度爆炸" class="headerlink" title="梯度消失和梯度爆炸"></a>梯度消失和梯度爆炸</h1><p>深度模型有关数值稳定性的典型问题是消失（vanishing）和爆炸（explosion）。</p><p><strong>当神经网络的层数较多时，模型的数值稳定性容易变差。</strong></p><p>假设一个层数为$L$的多层感知机的第$l$层${H}^{(l)}$的权重参数为${W}^{(l)}$，输出层${H}^{(L)}$的权重参数为${W}^{(L)}$。为了便于讨论，不考虑偏差参数，且设所有隐藏层的激活函数为恒等映射（identity mapping）$\phi(x) = x$。给定输入${X}$，多层感知机的第$l$层的输出${H}^{(l)} = {X} {W}^{(1)} {W}^{(2)} \ldots {W}^{(l)}$。此时，如果层数$l$较大，${H}^{(l)}$的计算可能会出现衰减或爆炸。举个例子，假设输入和所有层的权重参数都是标量，如权重参数为0.2和5，多层感知机的第30层输出为输入${X}$分别与$0.2^{30} \approx 1 \times 10^{-21}$（消失）和$5^{30} \approx 9 \times 10^{20}$（爆炸）的乘积。当层数较多时，梯度的计算也容易出现消失或爆炸。</p><hr><h1 id="随机初始化模型参数"><a href="#随机初始化模型参数" class="headerlink" title="随机初始化模型参数"></a>随机初始化模型参数</h1><p>在神经网络中，通常需要随机初始化模型参数。下面我们来解释这样做的原因。</p><p>回顾多层感知机一节描述的多层感知机。为了方便解释，假设输出层只保留一个输出单元$o_1$（删去$o_2$和$o_3$以及指向它们的箭头），且隐藏层使用相同的激活函数。如果将每个隐藏单元的参数都初始化为相等的值，那么在正向传播时每个隐藏单元将根据相同的输入计算出相同的值，并传递至输出层。在反向传播中，每个隐藏单元的参数梯度值相等。因此，这些参数在使用基于梯度的优化算法迭代后值依然相等。之后的迭代也是如此。在这种情况下，无论隐藏单元有多少，隐藏层本质上只有1个隐藏单元在发挥作用。因此，正如在前面的实验中所做的那样，我们通常将神经网络的模型参数，特别是权重参数，进行随机初始化。</p><p><img src="/2020/02/18/Task03：过拟合、欠拟合及其解决方案；梯度消失、梯度爆炸/TIM截图20200219225417.png" alt></p><h3 id="PyTorch的默认随机初始化"><a href="#PyTorch的默认随机初始化" class="headerlink" title="PyTorch的默认随机初始化"></a>PyTorch的默认随机初始化</h3><p>随机初始化模型参数的方法有很多。在线性回归的简洁实现中，我们使用<code>torch.nn.init.normal_()</code>使模型<code>net</code>的权重参数采用正态分布的随机初始化方式。不过，PyTorch中<code>nn.Module</code>的模块参数都采取了较为合理的初始化策略（不同类型的layer具体采样的哪一种初始化方法的可参考<a href="https://github.com/pytorch/pytorch/tree/master/torch/nn/modules" target="_blank" rel="noopener">源代码</a>），因此一般不用我们考虑。</p><h3 id="Xavier随机初始化"><a href="#Xavier随机初始化" class="headerlink" title="Xavier随机初始化"></a>Xavier随机初始化</h3><p>还有一种比较常用的随机初始化方法叫作Xavier随机初始化。<br>假设某全连接层的输入个数为$a$，输出个数为$b$，Xavier随机初始化将使该层中权重参数的每个元素都随机采样于均匀分布</p><script type="math/tex; mode=display">U\left(-\sqrt{\frac{6}{a+b}}, \sqrt{\frac{6}{a+b}}\right).</script><p>它的设计主要考虑到，模型参数初始化后，每层输出的方差不该受该层输入个数影响，且每层梯度的方差也不该受该层输出个数影响。</p><h1 id="考虑环境因素"><a href="#考虑环境因素" class="headerlink" title="考虑环境因素"></a>考虑环境因素</h1><h2 id="协变量偏移"><a href="#协变量偏移" class="headerlink" title="协变量偏移"></a>协变量偏移</h2><p>这里我们假设，虽然输入的分布可能随时间而改变，但是标记函数，即条件分布P（y∣x）不会改变。虽然这个问题容易理解，但在实践中也容易忽视。</p><p>想想区分猫和狗的一个例子。我们的训练数据使用的是猫和狗的真实的照片，但是在测试时，我们被要求对猫和狗的卡通图片进行分类。</p><div class="table-container"><table><thead><tr><th style="text-align:center">cat</th><th style="text-align:center">cat</th><th style="text-align:center">dog</th><th style="text-align:center">dog</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/2020/02/18/Task03：过拟合、欠拟合及其解决方案；梯度消失、梯度爆炸/200" alt></td><td style="text-align:center"><img src="/2020/02/18/Task03：过拟合、欠拟合及其解决方案；梯度消失、梯度爆炸/201" alt></td><td style="text-align:center"><img src="/2020/02/18/Task03：过拟合、欠拟合及其解决方案；梯度消失、梯度爆炸/202" alt></td><td style="text-align:center"><img src="/2020/02/18/Task03：过拟合、欠拟合及其解决方案；梯度消失、梯度爆炸/203" alt></td></tr></tbody></table></div><p>测试数据：</p><p><img src="/2020/02/18/Task03：过拟合、欠拟合及其解决方案；梯度消失、梯度爆炸/TIM截图20200219225716.png" alt></p><p>显然，这不太可能奏效。训练集由照片组成，而测试集只包含卡通。在一个看起来与测试集有着本质不同的数据集上进行训练，而不考虑如何适应新的情况，这是不是一个好主意。不幸的是，这是一个非常常见的陷阱。</p><p>统计学家称这种协变量变化是因为问题的根源在于特征分布的变化（即协变量的变化）。数学上，我们可以说P（x）改变了，但P（y∣x）保持不变。尽管它的有用性并不局限于此，当我们认为x导致y时，协变量移位通常是正确的假设。</p><h2 id="标签偏移"><a href="#标签偏移" class="headerlink" title="标签偏移"></a>标签偏移</h2><p>当我们认为导致偏移的是标签P（y）上的边缘分布的变化，但类条件分布是不变的P（x∣y）时，就会出现相反的问题。当我们认为y导致x时，标签偏移是一个合理的假设。例如，通常我们希望根据其表现来预测诊断结果。在这种情况下，我们认为诊断引起的表现，即疾病引起的症状。有时标签偏移和协变量移位假设可以同时成立。例如，当真正的标签函数是确定的和不变的，那么协变量偏移将始终保持，包括如果标签偏移也保持。有趣的是，当我们期望标签偏移和协变量偏移保持时，使用来自标签偏移假设的方法通常是有利的。这是因为这些方法倾向于操作看起来像标签的对象，这（在深度学习中）与处理看起来像输入的对象（在深度学习中）相比相对容易一些。</p><p>病因（要预测的诊断结果）导致 症状（观察到的结果）。  </p><p>训练数据集，数据很少只包含流感p(y)的样本。  </p><p>而测试数据集有流感p(y)和流感q(y)，其中不变的是流感症状p(x|y)。</p><h2 id="概念偏移"><a href="#概念偏移" class="headerlink" title="概念偏移"></a>概念偏移</h2><p>另一个相关的问题出现在概念转换中，即标签本身的定义发生变化的情况。这听起来很奇怪，毕竟猫就是猫。的确，猫的定义可能不会改变，但我们能不能对软饮料也这么说呢？事实证明，如果我们周游美国，按地理位置转移数据来源，我们会发现，即使是如图所示的这个简单术语的定义也会发生相当大的概念转变。</p><p><img src="/2020/02/18/Task03：过拟合、欠拟合及其解决方案；梯度消失、梯度爆炸/640" alt></p><center>美国软饮料名称的概念转变</center><p>如果我们要建立一个机器翻译系统，分布P（y∣x）可能因我们的位置而异。这个问题很难发现。另一个可取之处是P（y∣x）通常只是逐渐变化。</p>]]></content>
      
      
      
        <tags>
            
            <tag> deep learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Task02-文本预处理；语言模型；循环神经网络</title>
      <link href="/2020/02/18/Task02-%E6%96%87%E6%9C%AC%E9%A2%84%E5%A4%84%E7%90%86%EF%BC%9B%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%EF%BC%9B%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/2020/02/18/Task02-%E6%96%87%E6%9C%AC%E9%A2%84%E5%A4%84%E7%90%86%EF%BC%9B%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%EF%BC%9B%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="文本预处理"><a href="#文本预处理" class="headerlink" title="文本预处理"></a>文本预处理</h1><p>文本是一类序列数据，一篇文章可以看作是字符或单词的序列，本节将介绍文本数据的常见预处理步骤，预处理通常包括四个步骤：</p><ol><li>读入文本</li><li>分词</li><li>建立字典，将每个词映射到一个唯一的索引（index）</li><li>将文本从词的序列转换为索引的序列，方便输入模型</li></ol><h2 id="读入文本"><a href="#读入文本" class="headerlink" title="读入文本"></a>读入文本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_time_machine</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'/home/kesci/input/timemachine7163/timemachine.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        lines = [re.sub(<span class="string">'[^a-z]+'</span>, <span class="string">' '</span>, line.strip().lower()) <span class="keyword">for</span> line <span class="keyword">in</span> f]</span><br><span class="line">    <span class="keyword">return</span> lines</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lines = read_time_machine()</span><br><span class="line">print(<span class="string">'# sentences %d'</span> % len(lines))</span><br></pre></td></tr></table></figure><hr><p><strong>output</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sentences 3221</span><br></pre></td></tr></table></figure><a id="more"></a><hr><h2 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h2><p>我们对每个句子进行分词，也就是将一个句子划分成若干个词（token），转换为一个词的序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tokenize</span><span class="params">(sentences, token=<span class="string">'word'</span>)</span>:</span></span><br><span class="line">    <span class="string">"""Split sentences into word or char tokens"""</span></span><br><span class="line">    <span class="keyword">if</span> token == <span class="string">'word'</span>:</span><br><span class="line">        <span class="keyword">return</span> [sentence.split(<span class="string">' '</span>) <span class="keyword">for</span> sentence <span class="keyword">in</span> sentences]</span><br><span class="line">    <span class="keyword">elif</span> token == <span class="string">'char'</span>:</span><br><span class="line">        <span class="keyword">return</span> [list(sentence) <span class="keyword">for</span> sentence <span class="keyword">in</span> sentences]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'ERROR: unkown token type '</span>+token)</span><br><span class="line"></span><br><span class="line">tokens = tokenize(lines)</span><br><span class="line">tokens[<span class="number">0</span>:<span class="number">2</span>]</span><br></pre></td></tr></table></figure><hr><p><strong>output</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[&apos;the&apos;, &apos;time&apos;, &apos;machine&apos;, &apos;by&apos;, &apos;h&apos;, &apos;g&apos;, &apos;wells&apos;, &apos;&apos;], [&apos;&apos;]]</span><br></pre></td></tr></table></figure><hr><h2 id="建立字典"><a href="#建立字典" class="headerlink" title="建立字典"></a>建立字典</h2><p>为了方便模型处理，我们需要将字符串转换为数字。因此我们需要先构建一个字典（vocabulary），将每个词映射到一个唯一的索引编号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vocab</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, tokens, min_freq=<span class="number">0</span>, use_special_tokens=False)</span>:</span></span><br><span class="line">        counter = count_corpus(tokens)  <span class="comment"># : </span></span><br><span class="line">        self.token_freqs = list(counter.items())</span><br><span class="line">        self.idx_to_token = []</span><br><span class="line">        <span class="keyword">if</span> use_special_tokens:</span><br><span class="line">            <span class="comment"># padding, begin of sentence, end of sentence, unknown</span></span><br><span class="line">            self.pad, self.bos, self.eos, self.unk = (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">            self.idx_to_token += [<span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.unk = <span class="number">0</span></span><br><span class="line">            self.idx_to_token += [<span class="string">''</span>]</span><br><span class="line">        self.idx_to_token += [token <span class="keyword">for</span> token, freq <span class="keyword">in</span> self.token_freqs</span><br><span class="line">                        <span class="keyword">if</span> freq &gt;= min_freq <span class="keyword">and</span> token <span class="keyword">not</span> <span class="keyword">in</span> self.idx_to_token]</span><br><span class="line">        self.token_to_idx = dict()</span><br><span class="line">        <span class="keyword">for</span> idx, token <span class="keyword">in</span> enumerate(self.idx_to_token):</span><br><span class="line">            self.token_to_idx[token] = idx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.idx_to_token)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, tokens)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(tokens, (list, tuple)):</span><br><span class="line">            <span class="keyword">return</span> self.token_to_idx.get(tokens, self.unk)</span><br><span class="line">        <span class="keyword">return</span> [self.__getitem__(token) <span class="keyword">for</span> token <span class="keyword">in</span> tokens]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_tokens</span><span class="params">(self, indices)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(indices, (list, tuple)):</span><br><span class="line">            <span class="keyword">return</span> self.idx_to_token[indices]</span><br><span class="line">        <span class="keyword">return</span> [self.idx_to_token[index] <span class="keyword">for</span> index <span class="keyword">in</span> indices]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_corpus</span><span class="params">(sentences)</span>:</span></span><br><span class="line">    tokens = [tk <span class="keyword">for</span> st <span class="keyword">in</span> sentences <span class="keyword">for</span> tk <span class="keyword">in</span> st]</span><br><span class="line">    <span class="keyword">return</span> collections.Counter(tokens)  <span class="comment"># 返回一个字典，记录每个词的出现次数</span></span><br></pre></td></tr></table></figure><h3 id="一个dome，尝试用Time-Machine作为语料构建字典"><a href="#一个dome，尝试用Time-Machine作为语料构建字典" class="headerlink" title="一个dome，尝试用Time Machine作为语料构建字典"></a>一个dome，尝试用Time Machine作为语料构建字典</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vocab = Vocab(tokens)</span><br><span class="line">print(list(vocab.token_to_idx.items())[<span class="number">0</span>:<span class="number">10</span>])</span><br></pre></td></tr></table></figure><hr><p><strong>output</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(&apos;&apos;, 0), (&apos;the&apos;, 1), (&apos;time&apos;, 2), (&apos;machine&apos;, 3), (&apos;by&apos;, 4), (&apos;h&apos;, 5), (&apos;g&apos;, 6), (&apos;wells&apos;, 7), (&apos;i&apos;, 8), (&apos;traveller&apos;, 9)]</span><br></pre></td></tr></table></figure><hr><h2 id="将词转为索引"><a href="#将词转为索引" class="headerlink" title="将词转为索引"></a>将词转为索引</h2><p>使用字典，我们可以将原文本中的句子从单词序列转换为索引序列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>, <span class="number">10</span>):</span><br><span class="line">    print(<span class="string">'words:'</span>, tokens[i])</span><br><span class="line">    print(<span class="string">'indices:'</span>, vocab[tokens[i]])</span><br></pre></td></tr></table></figure><hr><p><strong>output</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">words: [&apos;the&apos;, &apos;time&apos;, &apos;traveller&apos;, &apos;for&apos;, &apos;so&apos;, &apos;it&apos;, &apos;will&apos;, &apos;be&apos;, &apos;convenient&apos;, &apos;to&apos;, &apos;speak&apos;, &apos;of&apos;, &apos;him&apos;, &apos;&apos;]</span><br><span class="line">indices: [1, 2, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 0]</span><br><span class="line">words: [&apos;was&apos;, &apos;expounding&apos;, &apos;a&apos;, &apos;recondite&apos;, &apos;matter&apos;, &apos;to&apos;, &apos;us&apos;, &apos;his&apos;, &apos;grey&apos;, &apos;eyes&apos;, &apos;shone&apos;, &apos;and&apos;]</span><br><span class="line">indices: [20, 21, 22, 23, 24, 16, 25, 26, 27, 28, 29, 30]</span><br></pre></td></tr></table></figure><hr><h2 id="用现有工具进行分词"><a href="#用现有工具进行分词" class="headerlink" title="用现有工具进行分词"></a>用现有工具进行分词</h2><p>我们前面介绍的分词方式非常简单，它至少有以下几个缺点:</p><ol><li>标点符号通常可以提供语义信息，但是我们的方法直接将其丢弃了</li><li>类似“shouldn’t”, “doesn’t”这样的词会被错误地处理</li><li>类似”Mr.”, “Dr.”这样的词会被错误地处理</li></ol><p>我们可以通过引入更复杂的规则来解决这些问题，但是事实上，有一些现有的工具可以很好地进行分词，我们在这里简单介绍其中的两个：<a href="https://spacy.io/" target="_blank" rel="noopener">spaCy</a>和<a href="https://www.nltk.org/" target="_blank" rel="noopener">NLTK</a>。</p><p>下面是一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">"Mr. Chen doesn't agree with my suggestion."</span></span><br></pre></td></tr></table></figure><h3 id="使用spaCy："><a href="#使用spaCy：" class="headerlink" title="使用spaCy："></a>使用spaCy：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line">nlp = spacy.load(<span class="string">'en_core_web_sm'</span>)</span><br><span class="line">doc = nlp(text)</span><br><span class="line">print([token.text <span class="keyword">for</span> token <span class="keyword">in</span> doc])</span><br></pre></td></tr></table></figure><hr><p><strong>output</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;Mr.&apos;, &apos;Chen&apos;, &apos;does&apos;, &quot;n&apos;t&quot;, &apos;agree&apos;, &apos;with&apos;, &apos;my&apos;, &apos;suggestion&apos;, &apos;.&apos;]</span><br></pre></td></tr></table></figure><hr><h3 id="使用NLTK"><a href="#使用NLTK" class="headerlink" title="使用NLTK:"></a>使用NLTK:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from nltk.tokenize import word_tokenize</span><br><span class="line">from nltk import data</span><br><span class="line">data.path.append(&apos;/home/kesci/input/nltk_data3784/nltk_data&apos;)</span><br><span class="line">print(word_tokenize(text))</span><br></pre></td></tr></table></figure><hr><p><strong>output</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;Mr.&apos;, &apos;Chen&apos;, &apos;does&apos;, &quot;n&apos;t&quot;, &apos;agree&apos;, &apos;with&apos;, &apos;my&apos;, &apos;suggestion&apos;, &apos;.&apos;]</span><br></pre></td></tr></table></figure><hr><h1 id="语言模型"><a href="#语言模型" class="headerlink" title="语言模型"></a>语言模型</h1><p>一段自然语言文本可以看作是一个离散时间序列，给定一个长度为$T$的词的序列$w_1, w_2, \ldots, w_T$，语言模型的目标就是评估该序列是否合理，即计算该序列的概率：</p><script type="math/tex; mode=display">P(w_1, w_2, \ldots, w_T).</script><hr><h2 id="语言模型-1"><a href="#语言模型-1" class="headerlink" title="语言模型"></a>语言模型</h2><p>假设序列$w_1, w_2, \ldots, w_T$中的每个词是依次生成的，我们有<br><img src="/2020/02/18/Task02-文本预处理；语言模型；循环神经网络/TIM截图20200218202122.png" alt></p><p>例如，一段含有4个词的文本序列的概率</p><script type="math/tex; mode=display">P(w_1, w_2, w_3, w_4) =  P(w_1) P(w_2 \mid w_1) P(w_3 \mid w_1, w_2) P(w_4 \mid w_1, w_2, w_3).</script><p>语言模型的参数就是词的概率以及给定前几个词情况下的条件概率。设训练数据集为一个大型文本语料库，如维基百科的所有条目，词的概率可以通过该词在训练数据集中的相对词频来计算，例如，$w_1$的概率可以计算为：</p><script type="math/tex; mode=display">\hat P(w_1) = \frac{n(w_1)}{n}</script><p>其中$n(w_1)$为语料库中以$w_1$作为第一个词的文本的数量，$n$为语料库中文本的总数量。类似的给定$w_1$情况下，$w_2$的条件概率可以计算为：</p><script type="math/tex; mode=display">\hat P(w_2 \mid w_1) = \frac{n(w_1, w_2)}{n(w_1)}</script><p>其中$n(w_1, w_2)$为语料库中以$w_1$作为第一个词，$w_2$作为第二个词的文本的数量。</p><hr><h2 id="n元语法"><a href="#n元语法" class="headerlink" title="n元语法"></a>n元语法</h2><p>序列长度增加，计算和存储多个词共同出现的概率的复杂度会呈指数级增加。$n$元语法通过马尔可夫假设简化模型，马尔科夫假设是指一个词的出现只与前面$n$个词相关，即$n$阶马尔可夫链（Markov chain of order $n$），如果$n=1$，那么有$P(w_3 \mid w_1, w_2) = P(w_3 \mid w_2)$。基于$n-1$阶马尔可夫链，我们可以将语言模型改写为：</p><script type="math/tex; mode=display">P(w_1, w_2, \ldots, w_T) = \prod_{t=1}^T P(w_t \mid w_{t-(n-1)}, \ldots, w_{t-1}) .</script><p>以上也叫$n$元语法（$n$-grams），它是基于$n - 1$阶马尔可夫链的概率语言模型。例如，当$n=2$时，含有4个词的文本序列的概率就可以改写为：</p><p><img src="/2020/02/18/Task02-文本预处理；语言模型；循环神经网络/TIM截图20200218202250.png" alt></p><p>当$n$分别为1、2和3时，我们将其分别称作一元语法（unigram）、二元语法（bigram）和三元语法（trigram）。例如，长度为4的序列$w_1, w_2, w_3, w_4$在一元语法、二元语法和三元语法中的概率分别为</p><script type="math/tex; mode=display">\begin{aligned}P(w_1, w_2, w_3, w_4) &=  P(w_1) P(w_2) P(w_3) P(w_4) ,\\P(w_1, w_2, w_3, w_4) &=  P(w_1) P(w_2 \mid w_1) P(w_3 \mid w_2) P(w_4 \mid w_3) ,\\P(w_1, w_2, w_3, w_4) &=  P(w_1) P(w_2 \mid w_1) P(w_3 \mid w_1, w_2) P(w_4 \mid w_2, w_3) .\end{aligned}</script><p>当$n$较小时，$n$元语法往往并不准确。例如，在一元语法中，由三个词组成的句子“你走先”和“你先走”的概率是一样的。然而，当$n$较大时，$n$元语法需要计算并存储大量的词频和多词相邻频率。</p><ul><li>$n$元语法的缺陷<ul><li>参数空间过大</li><li>数据稀疏</li></ul></li></ul><hr><h2 id="时序数据的采样"><a href="#时序数据的采样" class="headerlink" title="时序数据的采样"></a>时序数据的采样</h2><p>在训练中我们需要每次随机读取小批量样本和标签。时序数据的一个样本通常包含连续的字符。假设时间步数为5，样本序列为5个字符，即“想”“要”“有”“直”“升”。该样本的标签序列为这些字符分别在训练集中的下一个字符，即“要”“有”“直”“升”“机”，即$X$=“想要有直升”，$Y$=“要有直升机”。</p><p>现在我们考虑序列“想要有直升机，想要和你飞到宇宙去”，如果时间步数为5，有以下可能的样本和标签：</p><ul><li>$X$：“想要有直升”，$Y$：“要有直升机”</li><li>$X$：“要有直升机”，$Y$：“有直升机，”</li><li>$X$：“有直升机，”，$Y$：“直升机，想”</li><li>…</li><li>$X$：“要和你飞到”，$Y$：“和你飞到宇”</li><li>$X$：“和你飞到宇”，$Y$：“你飞到宇宙”</li><li>$X$：“你飞到宇宙”，$Y$：“飞到宇宙去”</li></ul><p>可以看到，如果序列的长度为$T$，时间步数为$n$，那么一共有$T-n$个合法的样本，但是这些样本有大量的重合，我们通常采用更加高效的采样方式。我们有两种方式对时序数据进行采样，分别是随机采样和相邻采样。</p><h3 id="随机采样"><a href="#随机采样" class="headerlink" title="随机采样"></a>随机采样</h3><p>在随机采样中，每个样本是原始序列上任意截取的一段序列，相邻的两个随机小批量在原始序列上的位置不一定相毗邻。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_iter_random</span><span class="params">(corpus_indices, batch_size, num_steps, device=None)</span>:</span></span><br><span class="line">    <span class="comment"># 减1是因为对于长度为n的序列，X最多只有包含其中的前n - 1个字符</span></span><br><span class="line">    num_examples = (len(corpus_indices) - <span class="number">1</span>) // num_steps  <span class="comment"># 下取整，得到不重叠情况下的样本个数</span></span><br><span class="line">    example_indices = [i * num_steps <span class="keyword">for</span> i <span class="keyword">in</span> range(num_examples)]  <span class="comment"># 每个样本的第一个字符在corpus_indices中的下标</span></span><br><span class="line">    random.shuffle(example_indices)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_data</span><span class="params">(i)</span>:</span></span><br><span class="line">        <span class="comment"># 返回从i开始的长为num_steps的序列</span></span><br><span class="line">        <span class="keyword">return</span> corpus_indices[i: i + num_steps]</span><br><span class="line">    <span class="keyword">if</span> device <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        device = torch.device(<span class="string">'cuda'</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">'cpu'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, num_examples, batch_size):</span><br><span class="line">        <span class="comment"># 每次选出batch_size个随机样本</span></span><br><span class="line">        batch_indices = example_indices[i: i + batch_size]  <span class="comment"># 当前batch的各个样本的首字符的下标</span></span><br><span class="line">        X = [_data(j) <span class="keyword">for</span> j <span class="keyword">in</span> batch_indices]</span><br><span class="line">        Y = [_data(j + <span class="number">1</span>) <span class="keyword">for</span> j <span class="keyword">in</span> batch_indices]</span><br><span class="line">        <span class="keyword">yield</span> torch.tensor(X, device=device), torch.tensor(Y, device=device)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_seq = list(range(<span class="number">30</span>))</span><br><span class="line"><span class="keyword">for</span> X, Y <span class="keyword">in</span> data_iter_random(my_seq, batch_size=<span class="number">2</span>, num_steps=<span class="number">6</span>):</span><br><span class="line">    print(<span class="string">'X: '</span>, X, <span class="string">'\nY:'</span>, Y, <span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure><hr><p><strong>output</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">X:  tensor([[ 6,  7,  8,  9, 10, 11],</span><br><span class="line">        [12, 13, 14, 15, 16, 17]]) </span><br><span class="line">Y: tensor([[ 7,  8,  9, 10, 11, 12],</span><br><span class="line">        [13, 14, 15, 16, 17, 18]]) </span><br><span class="line"></span><br><span class="line">X:  tensor([[ 0,  1,  2,  3,  4,  5],</span><br><span class="line">        [18, 19, 20, 21, 22, 23]]) </span><br><span class="line">Y: tensor([[ 1,  2,  3,  4,  5,  6],</span><br><span class="line">        [19, 20, 21, 22, 23, 24]])</span><br></pre></td></tr></table></figure><hr><h3 id="相邻采样"><a href="#相邻采样" class="headerlink" title="相邻采样"></a>相邻采样</h3><p>在相邻采样中，相邻的两个随机小批量在原始序列上的位置相毗邻。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_iter_consecutive</span><span class="params">(corpus_indices, batch_size, num_steps, device=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> device <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        device = torch.device(<span class="string">'cuda'</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">'cpu'</span>)</span><br><span class="line">    corpus_len = len(corpus_indices) // batch_size * batch_size  <span class="comment"># 保留下来的序列的长度</span></span><br><span class="line">    corpus_indices = corpus_indices[: corpus_len]  <span class="comment"># 仅保留前corpus_len个字符</span></span><br><span class="line">    indices = torch.tensor(corpus_indices, device=device)</span><br><span class="line">    indices = indices.view(batch_size, <span class="number">-1</span>)  <span class="comment"># resize成(batch_size, )</span></span><br><span class="line">    batch_num = (indices.shape[<span class="number">1</span>] - <span class="number">1</span>) // num_steps</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(batch_num):</span><br><span class="line">        i = i * num_steps</span><br><span class="line">        X = indices[:, i: i + num_steps]</span><br><span class="line">        Y = indices[:, i + <span class="number">1</span>: i + num_steps + <span class="number">1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> X, Y <span class="keyword">in</span> data_iter_consecutive(my_seq, batch_size=<span class="number">2</span>, num_steps=<span class="number">6</span>):</span><br><span class="line">    print(<span class="string">'X: '</span>, X, <span class="string">'\nY:'</span>, Y, <span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure><hr><p><strong>output</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">X:  tensor([[ 0,  1,  2,  3,  4,  5],</span><br><span class="line">        [15, 16, 17, 18, 19, 20]]) </span><br><span class="line">Y: tensor([[ 1,  2,  3,  4,  5,  6],</span><br><span class="line">        [16, 17, 18, 19, 20, 21]]) </span><br><span class="line"></span><br><span class="line">X:  tensor([[ 6,  7,  8,  9, 10, 11],</span><br><span class="line">        [21, 22, 23, 24, 25, 26]]) </span><br><span class="line">Y: tensor([[ 7,  8,  9, 10, 11, 12],</span><br><span class="line">        [22, 23, 24, 25, 26, 27]])</span><br></pre></td></tr></table></figure><hr><h1 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h1><p>本节介绍循环神经网络，下图展示了如何基于循环神经网络实现语言模型。我们的目的是基于当前的输入与过去的输入序列，预测序列的下一个字符。循环神经网络引入一个隐藏变量$H$，用$H<em>{t}$表示$H$在时间步$t$的值。$H</em>{t}$的计算基于$X<em>{t}$和$H</em>{t-1}$，可以认为$H<em>{t}$记录了到当前字符为止的序列信息，利用$H</em>{t}$对序列的下一个字符进行预测。<br><img src="/2020/02/18/Task02-文本预处理；语言模型；循环神经网络/1.png" alt></p><h2 id="循环神经网络的构造"><a href="#循环神经网络的构造" class="headerlink" title="循环神经网络的构造"></a>循环神经网络的构造</h2><p>我们先看循环神经网络的具体构造。假设${X}_t \in \mathbb{R}^{n \times d}$是时间步$t$的小批量输入，${H}_t  \in \mathbb{R}^{n \times h}$是该时间步的隐藏变量，则：</p><script type="math/tex; mode=display">{H}_t = \phi({X}_t {W}_{xh} + {H}_{t-1} {W}_{hh}  + {b}_h).</script><p>其中，${W}<em>{xh}\in \mathbb{R}^{d \times h}$，${W}</em>{hh} \in \mathbb{R}^{h \times h}$，${b}<em>{h} \in \mathbb{R}^{1 \times h}$，$\phi$函数是非线性激活函数。由于引入了${H}</em>{t-1} {W}<em>{hh}$，$H</em>{t}$能够捕捉截至当前时间步的序列的历史信息，就像是神经网络当前时间步的状态或记忆一样。由于$H<em>{t}$的计算基于$H</em>{t-1}$，上式的计算是循环的，使用循环计算的网络即循环神经网络（recurrent neural network）。</p><p>在时间步$t$，输出层的输出为：</p><script type="math/tex; mode=display">{O}_t = {H}_t {W}_{hq} + {b}_q.</script><p>其中${W}_{hq} \in \mathbb{R}^{h \times q}$，${b}_q \in \mathbb{R}^{1 \times q}$。</p><hr><h3 id="裁剪梯度"><a href="#裁剪梯度" class="headerlink" title="裁剪梯度"></a>裁剪梯度</h3><p>循环神经网络中较容易出现梯度衰减或梯度爆炸，这会导致网络几乎无法训练。裁剪梯度（clip gradient）是一种应对梯度爆炸的方法。假设我们把所有模型参数的梯度拼接成一个向量 ${g}$，并设裁剪的阈值是$\theta$。裁剪后的梯度</p><script type="math/tex; mode=display">\min\left(\frac{\theta}{\|{g}\|}, 1\right){g}</script><p>的$L_2$范数不超过$\theta$。</p><hr><h3 id="困惑度"><a href="#困惑度" class="headerlink" title="困惑度"></a>困惑度</h3><p>我们通常使用困惑度（perplexity）来评价语言模型的好坏。困惑度是对交叉熵损失函数做指数运算后得到的值。特别地，</p><ul><li>最佳情况下，模型总是把标签类别的概率预测为1，此时困惑度为1；</li><li>最坏情况下，模型总是把标签类别的概率预测为0，此时困惑度为正无穷；</li><li>基线情况下，模型总是预测所有类别的概率都相同，此时困惑度为类别个数。</li></ul><p>显然，任何一个有效模型的困惑度必须小于类别个数。</p><hr><h2 id="GRU"><a href="#GRU" class="headerlink" title="GRU"></a>GRU</h2><p>  RNN存在的问题：梯度较容易出现衰减或爆炸（BPTT）<br>  ⻔控循环神经⽹络：捕捉时间序列中时间步距离较⼤的依赖关系<br>  <strong>RNN</strong>: </p><p><img src="/2020/02/18/Task02-文本预处理；语言模型；循环神经网络/TIM截图20200218220823.png" alt></p><p><img src="/2020/02/18/Task02-文本预处理；语言模型；循环神经网络/TIM截图20200218222241.png" alt></p><p>  <strong>GRU</strong>:</p><p><img src="/2020/02/18/Task02-文本预处理；语言模型；循环神经网络/TIM截图20200218220908.png" alt></p><p><img src="/2020/02/18/Task02-文本预处理；语言模型；循环神经网络/TIM截图20200218222612.png" alt></p><h4 id="•-重置⻔有助于捕捉时间序列⾥短期的依赖关系；"><a href="#•-重置⻔有助于捕捉时间序列⾥短期的依赖关系；" class="headerlink" title="•  重置⻔有助于捕捉时间序列⾥短期的依赖关系；"></a>•  重置⻔有助于捕捉时间序列⾥短期的依赖关系；</h4><h4 id="•-更新⻔有助于捕捉时间序列⾥⻓期的依赖关系。"><a href="#•-更新⻔有助于捕捉时间序列⾥⻓期的依赖关系。" class="headerlink" title="•  更新⻔有助于捕捉时间序列⾥⻓期的依赖关系。"></a>•  更新⻔有助于捕捉时间序列⾥⻓期的依赖关系。</h4><h2 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h2><h4 id="长短期记忆（long-short-term-memory）"><a href="#长短期记忆（long-short-term-memory）" class="headerlink" title="长短期记忆（long short-term memory）:"></a>长短期记忆（long short-term memory）:</h4><p><strong>遗忘门</strong>:控制上一时间步的记忆细胞 ；<br><strong>输入门</strong>:控制当前时间步的输入 ；<br><strong>输出门</strong>:控制从记忆细胞到隐藏状态 ；<br><strong>记忆细胞</strong>:⼀种特殊的隐藏状态的信息的流动  ；</p><p><img src="/2020/02/18/Task02-文本预处理；语言模型；循环神经网络/TIM截图20200218221043.png" alt></p><p><img src="/2020/02/18/Task02-文本预处理；语言模型；循环神经网络/TIM截图20200218222645.png" alt></p><h2 id="深度循环神经网络"><a href="#深度循环神经网络" class="headerlink" title="深度循环神经网络"></a>深度循环神经网络</h2><p><img src="/2020/02/18/Task02-文本预处理；语言模型；循环神经网络/TIM截图20200218221221.png" alt></p><p><img src="/2020/02/18/Task02-文本预处理；语言模型；循环神经网络/TIM截图20200218222716.png" alt></p><h2 id="双向循环神经网络"><a href="#双向循环神经网络" class="headerlink" title="双向循环神经网络"></a>双向循环神经网络</h2><p><img src="/2020/02/18/Task02-文本预处理；语言模型；循环神经网络/TIM截图20200218221307.png" alt></p><p><img src="/2020/02/18/Task02-文本预处理；语言模型；循环神经网络/TIM截图20200218222745.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> deep learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Task01:线性回归；Softmax与分类模型、多层感知机</title>
      <link href="/2020/02/14/Task01-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%EF%BC%9BSoftmax%E4%B8%8E%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E3%80%81%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
      <url>/2020/02/14/Task01-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%EF%BC%9BSoftmax%E4%B8%8E%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E3%80%81%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="线性回归的基本要素"><a href="#线性回归的基本要素" class="headerlink" title="线性回归的基本要素"></a>线性回归的基本要素</h2><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>为了简单起见，这里我们假设价格只取决于房屋状况的两个因素，即面积（平方米）和房龄（年）。接下来我们希望探索价格与这两个因素的具体关系。线性回归假设输出与各个输入之间是线性关系:</p><script type="math/tex; mode=display">\mathrm{price} = w_{\mathrm{area}} \cdot \mathrm{area} + w_{\mathrm{age}} \cdot \mathrm{age} + b</script><a id="more"></a><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p>我们通常收集一系列的真实数据，例如多栋房屋的真实售出价格和它们对应的面积和房龄。我们希望在这个数据上面寻找模型参数来使模型的预测价格与真实价格的误差最小。在机器学习术语里，该数据集被称为训练数据集（training data set）或训练集（training set），一栋房屋被称为一个样本（sample），其真实售出价格叫作标签（label），用来预测标签的两个因素叫作特征（feature）。特征用来表征样本的特点。</p><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>在模型训练中，我们需要衡量价格预测值与真实值之间的误差。通常我们会选取一个非负数作为误差，且数值越小表示误差越小。一个常用的选择是平方函数。 它在评估索引为 $i$ 的样本误差的表达式为</p><script type="math/tex; mode=display">l^{(i)}(\mathbf{w}, b) = \frac{1}{2} \left(\hat{y}^{(i)} - y^{(i)}\right)^2,</script><script type="math/tex; mode=display">L(\mathbf{w}, b) =\frac{1}{n}\sum_{i=1}^n l^{(i)}(\mathbf{w}, b) =\frac{1}{n} \sum_{i=1}^n \frac{1}{2}\left(\mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)}\right)^2.</script><h3 id="优化函数-随机梯度下降"><a href="#优化函数-随机梯度下降" class="headerlink" title="优化函数 - 随机梯度下降"></a>优化函数 - 随机梯度下降</h3><p>当模型和损失函数形式较为简单时，上面的误差最小化问题的解可以直接用公式表达出来。这类解叫作解析解（analytical solution）。本节使用的线性回归和平方误差刚好属于这个范畴。然而，大多数深度学习模型并没有解析解，只能通过优化算法有限次迭代模型参数来尽可能降低损失函数的值。这类解叫作数值解（numerical solution）。</p><p>在求数值解的优化算法中，小批量随机梯度下降（mini-batch stochastic gradient descent）在深度学习中被广泛使用。它的算法很简单：先选取一组模型参数的初始值，如随机选取；接下来对参数进行多次迭代，使每次迭代都可能降低损失函数的值。在每次迭代中，先随机均匀采样一个由固定数目训练数据样本所组成的小批量（mini-batch）$\mathcal{B}$，然后求小批量中数据样本的平均损失有关模型参数的导数（梯度），最后用此结果与预先设定的一个正数的乘积作为模型参数在本次迭代的减小量。  </p><script type="math/tex; mode=display">(\mathbf{w},b) \leftarrow (\mathbf{w},b) - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \partial_{(\mathbf{w},b)} l^{(i)}(\mathbf{w},b)</script><p>学习率: $\eta$代表在每次优化中，能够学习的步长的大小<br>批量大小: $\mathcal{B}$是小批量计算中的批量大小batch size </p><p>总结一下，优化函数的有以下两个步骤：</p><ul><li><p>(i)初始化模型参数，一般来说使用随机初始化；</p></li><li><p>(ii)我们在数据上迭代多次，通过在负梯度方向移动参数来更新每个参数。</p></li></ul><hr><h2 id="softmax的基本概念"><a href="#softmax的基本概念" class="headerlink" title="softmax的基本概念"></a>softmax的基本概念</h2><ul><li><p>分类问题<br>一个简单的图像分类问题，输入图像的高和宽均为2像素，色彩为灰度。<br>图像中的4像素分别记为$x_1, x_2, x_3, x_4$。<br>假设真实标签为狗、猫或者鸡，这些标签对应的离散值为$y_1, y_2, y_3$。<br>我们通常使用离散的数值来表示类别，例如$y_1=1, y_2=2, y_3=3$。</p></li><li><p>权重矢量 </p><script type="math/tex; mode=display">\begin{aligned} o_1 &= x_1 w_{11} + x_2 w_{21} + x_3 w_{31} + x_4 w_{41} + b_1 \end{aligned}</script></li></ul><script type="math/tex; mode=display"> \begin{aligned} o_2 &= x_1 w_{12} + x_2 w_{22} + x_3 w_{32} + x_4 w_{42} + b_2 \end{aligned}</script><script type="math/tex; mode=display"> \begin{aligned} o_3 &= x_1 w_{13} + x_2 w_{23} + x_3 w_{33} + x_4 w_{43} + b_3 \end{aligned}</script><ul><li><p>神经网络图<br>用神经网络图描绘了上面的计算。softmax回归同线性回归一样，也是一个单层神经网络。由于每个输出$o_1, o_2, o_3$的计算都要依赖于所有的输入$x_1, x_2, x_3, x_4$，softmax回归的输出层也是一个全连接层。</p><p><img src="/2020/02/14/Task01-线性回归；Softmax与分类模型、多层感知机/TIM截图20200215001225.png"></p></li></ul><p>既然分类问题需要得到离散的预测输出，一个简单的办法是将输出值$o_i$当作预测类别是$i$的置信度，并将值最大的输出所对应的类作为预测输出，即输出 <strong>arg max</strong>$o_i$。例如，如果$o_1,o_2,o_3$分别为<strong>0.1,10,0.1</strong>，由于$o_2$最大，那么预测类别为2，其代表猫。</p><ul><li>输出问题<br>直接使用输出层的输出有两个问题：<ol><li>一方面，由于输出层的输出值的范围不确定，我们难以直观上判断这些值的意义。例如，刚才举的例子中的输出值10表示“很置信”图像类别为猫，因为该输出值是其他两类的输出值的100倍。但如果$o_1=o_3=10^3$，那么输出值10却又表示图像类别为猫的概率很低。</li><li>另一方面，由于真实标签是离散值，这些离散值与不确定范围的输出值之间的误差难以衡量。</li></ol></li></ul><p>softmax运算符（softmax operator）解决了以上两个问题。它通过下式将输出值变换成值为正且和为1的概率分布：</p><p><img src="/2020/02/14/Task01-线性回归；Softmax与分类模型、多层感知机/TIM图片20200215000442.png"></p><p>其中</p><script type="math/tex; mode=display">\hat{y}1 = \frac{ \exp(o_1)}{\sum_{i=1}^3 \exp(o_i)},\quad \hat{y}2 = \frac{ \exp(o_2)}{\sum_{i=1}^3 \exp(o_i)},\quad \hat{y}3 = \frac{ \exp(o_3)}{\sum_{i=1}^3 \exp(o_i)}.</script><p>因此softmax运算不改变预测类别输出。</p><ul><li>计算效率<ul><li>单样本矢量计算表达式<br>为了提高计算效率，我们可以将单样本分类通过矢量计算来表达。在上面的图像分类问题中，假设softmax回归的权重和偏差参数分别为</li></ul></li></ul><p><img src="/2020/02/14/Task01-线性回归；Softmax与分类模型、多层感知机/TIM截图20200215000631.png"></p><p>设高和宽分别为2个像素的图像样本$i$的特征为</p><script type="math/tex; mode=display">x^{(i)} = [x_1^{(i)}  x_2^{(i)}   x_3^{(i)}  x_4^{(i)}]</script><p>输出层的输出为</p><script type="math/tex; mode=display">o^{(i)} = [o_1^{(i)}  o_2^{(i)}  o_3^{(i)}]</script><p>预测为狗、猫或鸡的概率分布为</p><script type="math/tex; mode=display">{\hat{y}}^{(i)} = [\hat{y}_1^{(i)}  \hat{y}_2^{(i)}  \hat{y}_3^{(i)}]</script><p>softmax回归对样本$i$分类的矢量计算表达式为</p><p><img src="/2020/02/14/Task01-线性回归；Softmax与分类模型、多层感知机/TIM截图20200215001053.png"></p><ul><li>小批量矢量计算表达式<br>  为了进一步提升计算效率，我们通常对小批量数据做矢量计算。广义上讲，给定一个小批量样本，其批量大小为$n$，输入个数（特征数）为$d$，输出个数（类别数）为$q$。设批量特征为$X \in \mathbb{R}^{n \times d}$。假设softmax回归的权重和偏差参数分别为$W \in \mathbb{R}^{d \times q}$和$b \in \mathbb{R}^{1 \times q}$。softmax回归的矢量计算表达式为<br><img src="/2020/02/14/Task01-线性回归；Softmax与分类模型、多层感知机/TIM截图20200215001526.png"></li></ul><p>其中的加法运算使用了广播机制，$O, \hat{Y} \in \mathbb{R}^{n \times q}$且这两个矩阵的第$i$行分别为样本$i$的输出$o^{(i)}$和概率分布$\hat{y}^{(i)}$。</p><h2 id="交叉熵损失函数"><a href="#交叉熵损失函数" class="headerlink" title="交叉熵损失函数"></a>交叉熵损失函数</h2><p>对于样本$i$，我们构造向量$y^{(i)}\in \mathbb{R}^{q}$ ，使其第$y^{(i)}$（样本$i$类别的离散数值）个元素为1，其余为0。这样我们的训练目标可以设为使预测概率分布$\hat y^{(i)}$尽可能接近真实的标签概率分布$y^{(i)}$。</p><ul><li>平方损失估计 </li></ul><script type="math/tex; mode=display">{aligned}Loss = |\hat y^{(i)}-y^{(i)}|^2/2</script><p>然而，想要预测分类结果正确，我们其实并不需要预测概率完全等于标签概率。例如，在图像分类的例子里，如果$y^{(i)}=3$，那么我们只需要$\hat{y}^{(i)}_3$比其他两个预测值$\hat{y}^{(i)}_1$和$\hat{y}^{(i)}_2$大就行了。即使$\hat{y}^{(i)}_3$值为0.6，不管其他两个预测值为多少，类别预测均正确。而平方损失则过于严格，例如$\hat y^{(i)}_1=\hat y^{(i)}_2=0.2$比$\hat y^{(i)}_1=0, \hat y^{(i)}_2=0.4$的损失要小很多，虽然两者都有同样正确的分类预测结果。</p><p>改善上述问题的一个方法是使用更适合衡量两个概率分布差异的测量函数。其中，交叉熵（cross entropy）是一个常用的衡量方法：</p><script type="math/tex; mode=display">H\left( y^{(i)},  {\hat y}^{(i)}\right ) = -\sum_{j=1}^q y_j^{(i)} \log \hat y_j^{(i)},</script><p>其中带下标的$y<em>j^{(i)}$是向量$y^{(i)}$中非0即1的元素，需要注意将它与样本$i$类别的离散数值，即不带下标的$y^{(i)}$区分。在上式中，我们知道向量${y}^{(i)}$中只有第$y^{(i)}$个元素$y^{(i)}{y^{(i)}}$为1，其余全为0，于是${H}(y^{(i)}, {\hat y}^{(i)}) = -\log \hat y</em>{y^{(i)}}^{(i)}$。也就是说，交叉熵只关心对正确类别的预测概率，因为只要其值足够大，就可以确保分类结果正确。当然，遇到一个样本有多个标签时，例如图像里含有不止一个物体时，我们并不能做这一步简化。但即便对于这种情况，交叉熵同样只关心对图像中出现的物体类别的预测概率。</p><p>假设训练数据集的样本数为$n$，交叉熵损失函数定义为 </p><script type="math/tex; mode=display">\ell(\Theta) = \frac{1}{n} \sum_{i=1}^n H\left( y^{(i)},  {\hat y}^{(i)}\right ),</script><p>其中${\Theta}$代表模型参数。同样地，如果每个样本只有一个标签，那么交叉熵损失可以简写成$\ell( {\Theta}) = -(1/n) \sum<em>{i=1}^n \log \hat y</em>{y^{(i)}}^{(i)}$。从另一个角度来看，我们知道最小化$\ell({\Theta})$等价于最大化$\exp(-n\ell({\Theta}))=\prod<em>{i=1}^n \hat y</em>{y^{(i)}}^{(i)}$，即最小化交叉熵损失函数等价于最大化训练数据集所有标签类别的联合预测概率。</p><h2 id="多层感知机的基本知识"><a href="#多层感知机的基本知识" class="headerlink" title="多层感知机的基本知识"></a>多层感知机的基本知识</h2><p>深度学习主要关注多层模型。在这里，我们将以多层感知机（multilayer perceptron，MLP）为例，介绍多层神经网络的概念。</p><h3 id="隐藏层"><a href="#隐藏层" class="headerlink" title="隐藏层"></a>隐藏层</h3><p>下图展示了一个多层感知机的神经网络图，它含有一个隐藏层，该层中有5个隐藏单元。</p><p><img src="/2020/02/14/Task01-线性回归；Softmax与分类模型、多层感知机/TIM截图20200215001339.png"></p><h3 id="表达公式"><a href="#表达公式" class="headerlink" title="表达公式"></a>表达公式</h3><p>具体来说，给定一个小批量样本${X} \in \mathbb{R}^{n \times d}$，其批量大小为$n$，输入个数为$d$。假设多层感知机只有一个隐藏层，其中隐藏单元个数为$h$。记隐藏层的输出（也称为隐藏层变量或隐藏变量）为${H}$，有${H} \in \mathbb{R}^{n \times h}$。因为隐藏层和输出层均是全连接层，可以设隐藏层的权重参数和偏差参数分别为${W}_h \in \mathbb{R}^{d \times h}$和 ${b}_h \in \mathbb{R}^{1 \times h}$，输出层的权重和偏差参数分别为${W}_o \in \mathbb{R}^{h \times q}$和${b}_o \in \mathbb{R}^{1 \times q}$。</p><p>我们先来看一种含单隐藏层的多层感知机的设计。其输出${O} \in \mathbb{R}^{n \times q}$的计算为</p><p>${H}= {X} {W}_h + {b}_h,$</p><p>${O} = {H} {W}_o + {b}_o,$</p><p>也就是将隐藏层的输出直接作为输出层的输入。如果将以上两个式子联立起来，可以得到</p><script type="math/tex; mode=display">{O} = ({X} {W}_h + {b}_h){W}_o + {b}_o = {X} {W}_h{W}_o +{b}_h{W}_o +{b}_o.</script><p>从联立后的式子可以看出，虽然神经网络引入了隐藏层，却依然等价于一个单层神经网络：其中输出层权重参数为${W}_h{W}_o$，偏差参数为${b}_h {W}_o + {b}_o$。不难发现，即便再添加更多的隐藏层，以上设计依然只能与仅含输出层的单层神经网络等价。</p><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>上述问题的根源在于全连接层只是对数据做仿射变换（affine transformation），而多个仿射变换的叠加仍然是一个仿射变换。解决问题的一个方法是引入非线性变换，例如对隐藏变量使用按元素运算的非线性函数进行变换，然后再作为下一个全连接层的输入。这个非线性函数被称为激活函数（activation function）。</p><p>下面我们介绍几个常用的激活函数：</p><p><img src="/2020/02/14/Task01-线性回归；Softmax与分类模型、多层感知机/IMG_20200214_234252.jpg"></p><h3 id="关于激活函数的选择"><a href="#关于激活函数的选择" class="headerlink" title="关于激活函数的选择"></a>关于激活函数的选择</h3><p>ReLu函数是一个通用的激活函数，目前在大多数情况下使用。但是，ReLU函数只能在隐藏层中使用。</p><p>用于分类器时，sigmoid函数及其组合通常效果更好。由于梯度消失问题，有时要避免使用sigmoid和tanh函数。 </p><p>在神经网络层数较多的时候，最好使用ReLu函数，ReLu函数比较简单计算量少，而sigmoid和tanh函数计算量大很多。</p><p>在选择激活函数的时候可以先选用ReLu函数如果效果不理想可以尝试其他激活函数。</p><h3 id="多层感知机"><a href="#多层感知机" class="headerlink" title="多层感知机"></a>多层感知机</h3><p>多层感知机就是含有至少一个隐藏层的由全连接层组成的神经网络，且每个隐藏层的输出通过激活函数进行变换。多层感知机的层数和各隐藏层中隐藏单元个数都是超参数。以单隐藏层为例并沿用本节之前定义的符号，多层感知机按以下方式计算输出：</p><script type="math/tex; mode=display">\begin{aligned} {H} &= \phi({X}{W}_h + {b}_h),\\ {O} &= {H}{W}_o + {b}_o, \end{aligned}</script><p>其中$\phi$表示激活函数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> deep learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>武汉加油！</title>
      <link href="/2020/02/10/%E6%AD%A6%E6%B1%89%E5%8A%A0%E6%B2%B9/"/>
      <url>/2020/02/10/%E6%AD%A6%E6%B1%89%E5%8A%A0%E6%B2%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="武汉加油！"><a href="#武汉加油！" class="headerlink" title="武汉加油！"></a><center>武汉加油！</center></h1><p><img src="/2020/02/10/武汉加油/whjy.jpg" style="width:650px;height:400px;"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>贝叶斯误差</title>
      <link href="/2019/12/30/%E8%B4%9D%E5%8F%B6%E6%96%AF%E8%AF%AF%E5%B7%AE/"/>
      <url>/2019/12/30/%E8%B4%9D%E5%8F%B6%E6%96%AF%E8%AF%AF%E5%B7%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="贝叶斯误差"><a href="#贝叶斯误差" class="headerlink" title="贝叶斯误差"></a>贝叶斯误差</h2><p>转载知乎:(<a href="https://www.zhihu.com/question/263546637" target="_blank" rel="noopener">https://www.zhihu.com/question/263546637</a>) </p><h4 id="Wiki定义-贝叶斯误差（bayes-error-rate-是指在现有特征集上，任意可以基于特征输入进行随机输出的分类器所能达到最小误差。也可以叫做最小误差。"><a href="#Wiki定义-贝叶斯误差（bayes-error-rate-是指在现有特征集上，任意可以基于特征输入进行随机输出的分类器所能达到最小误差。也可以叫做最小误差。" class="headerlink" title="Wiki定义:贝叶斯误差（bayes error rate)是指在现有特征集上，任意可以基于特征输入进行随机输出的分类器所能达到最小误差。也可以叫做最小误差。"></a><strong><a href="https://en.wikipedia.org/wiki/Bayes_error_rate" target="_blank" rel="noopener">Wiki定义</a></strong>:贝叶斯误差（bayes error rate)是指在现有特征集上，任意可以基于特征输入进行随机输出的分类器所能达到最小误差。也可以叫做最小误差。</h4><p>疑问：“书上说是从预先知道的分布预测而出现的c误差，既然已经预先知道分布了，那么为什么还有误差呢？” </p><p>回答：<strong>分布是真实的，但预测的输出只能是一个值，所以会有误差</strong>。例如，假设真实世界中90%长头发的人为女性，10%为男性（这是已知的真实分布）；此时已知一个人头发长，预测该同学性别。由于只能预测男/女。<strong>此时即使你知道真实分布，预测为女，也会有10%的误差。这就是贝叶斯误差。</strong></p><a id="more"></a><p> ======================================================================================</p><p> 下面详细说一下我的理解，贝叶斯误差的定义有两个关键点： </p><ul><li><p>给定特征集后的最小误差：即可以认为我们的训练集无限大且已经按真实分布穷举了所有可能的特征组合后，任何分类器所能达到的误差下限。产生贝叶斯误差的本质原因是特征集不足以推理出准确预测值，否则贝叶斯误差为0. </p></li><li><p>概率特性：“最小误差”是限定在概率随机性条件下的 （如果是开了实例级别的“天眼”的最小误差，显然无论任何情形下最小误差都是0，这个概念将没有任何意义。贝叶斯误差只能开概率级别的“天眼”）。即： </p><ul><li><p>如果场景是给定特征输入，输出值是唯一的，则贝叶斯误差为0。例如特征是人的净高和鞋底厚度，回归目标是人的头顶距离地面高度。那贝叶斯误差为0. 在训练集准确的情况下，线性回归也可以达到相同误差。 </p></li><li><p>反之，如果输出值是有一定随机性的，贝叶斯误差是此时选概率最大输出作为输出值所能达到的误差。比如，特征为头发长短，目标值为男、女分类label。假设在长发下，真实世界中女性概率90%，10%男性。反之女性10%，男性90%。那么贝叶斯概率误差即为认定长发为女，短发为男的误差。显然其贝叶斯误差为10%。</p></li></ul></li></ul><p>贝叶斯误差的作用：</p><p>​       直观上可以这么理解，贝叶斯误差是在给定特征集的情况下，假设数据无限（且准确），依靠统计所能得到的最小误差。它是我们通过增加数据集/优化数据集分布/提升模型学习能力/防止过拟合等等措施后所能达到的误差下限。如果当前算法已经能达到接近贝叶斯误差的误差，则在不动特征的前提下（比如DNN输入特征为原始文本/像素时，输入特征就动不了）我们已经没有继续优化的意义了。</p><p>​       然而，事实上，贝叶斯误差无法求得（因为求得的前提是你知道真实分布，你知道真实分布还做什么机器学习呀）。目前就我知道的，业界并不会真正使用该指标，该指标更多的还是出现在学术探讨中。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2层及多层神经网络的构建</title>
      <link href="/2019/12/20/2%E5%B1%82%E5%8F%8A%E5%A4%9A%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%9E%84%E5%BB%BA/"/>
      <url>/2019/12/20/2%E5%B1%82%E5%8F%8A%E5%A4%9A%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="1-2层神经网络"><a href="#1-2层神经网络" class="headerlink" title="1-2层神经网络"></a>1-2层神经网络</h2><p><img src="/2019/12/20/2层及多层神经网络的构建/2layerNN_kiank.png" style="width:650px;height:400px;"></p><p>该模型可以概括为： <strong>INPUT -&gt; LINEAR -&gt; RELU -&gt; LINEAR -&gt; SIGMOID -&gt; OUTPUT</strong>. </p><ul><li>输入是 <strong>(64,64,3)</strong> 图像，将其展平为大小为   <strong>(12288,1)</strong>  的向量。</li><li>相应的向量：$[x<em>0,x_1,…,x</em>{12287}]^T$  然后乘以大小为   $(n^{[1]}, 12288)$  的权重矩阵  $W^{[1]}$ 。</li><li><p>然后，您添加一个偏差项并获取其偏倚以获得以下向量： $[a<em>0^{[1]}, a_1^{[1]},…, a</em>{n^{[1]}-1}^{[1]}]^T$ .</p><ul><li><p>然后重复相同的过程。</p></li><li><p>您将所得向量乘以  $W^{[2]}$  ，然后加上截距（偏差）。</p></li><li><p>最后，取最后一个激活函数为Sigmoid函数，如果大于0.5，则将其分类为猫。</p></li></ul></li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤:"></a><strong>步骤:</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_parameters</span><span class="params">(n_x, n_h, n_y)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> parameters </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_activation_forward</span><span class="params">(A_prev, W, b, activation)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> A, cache</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_cost</span><span class="params">(AL, Y)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> cost</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_activation_backward</span><span class="params">(dA, cache, activation)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> dA_prev, dW, db</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_parameters</span><span class="params">(parameters, grads, learning_rate)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> parameters</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="L层深度神经网络"><a href="#L层深度神经网络" class="headerlink" title="L层深度神经网络"></a>L层深度神经网络</h2><p><img src="/2019/12/20/2层及多层神经网络的构建/LlayerNN_kiank.png" style="width:650px;height:400px;"></p><p>该模型可以概括为：<strong>[LINEAR -&gt; RELU] $\times$ (L-1) -&gt; LINEAR -&gt; SIGMOID</strong></p><ul><li><p>输入是 <strong>(64,64,3)</strong> 图像，将其展平为大小为  <strong>(12288,1)</strong> 的向量。</p></li><li><p>相应的向量： $[x<em>0,x_1,…,x</em>{12287}]^T$然后乘以权重矩阵$W^{[1]}$，然后添加截距$b^{[1]}$,结果称为线性单位。</p></li><li><p>接下来，取激活函数的<strong>ReLU</strong>，根据模型体系结构的不同，这个过程可以对每个$(W^{[l]},b^{[l]})$重复多次。</p></li><li><p>最后，取最后一个激活函数为Sigmoid函数。如果它大于0.5，你就把它归为猫。</p></li></ul><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤:"></a><strong>步骤:</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_parameters_deep</span><span class="params">(layers_dims)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> parameters </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">L_model_forward</span><span class="params">(X, parameters)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> AL, caches</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_cost</span><span class="params">(AL, Y)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> cost</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">L_model_backward</span><span class="params">(AL, Y, caches)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> grads</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_parameters</span><span class="params">(parameters, grads, learning_rate)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> parameters</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> deep learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据规范化</title>
      <link href="/2019/12/15/%E6%95%B0%E6%8D%AE%E8%A7%84%E8%8C%83%E5%8C%96/"/>
      <url>/2019/12/15/%E6%95%B0%E6%8D%AE%E8%A7%84%E8%8C%83%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="数据规范化、标准化、归一化"><a href="#数据规范化、标准化、归一化" class="headerlink" title="数据规范化、标准化、归一化"></a>数据规范化、标准化、归一化</h2><p><a href="https://blog.csdn.net/u014381464/article/details/81101551" target="_blank" rel="noopener">转载：原文链接</a></p><ul><li><p>在数据分析之前，我们都需要让数据满足一定的规律，达到规范性的要求，便于进行挖掘。</p></li><li><p>如果不进行变换的话，要不就是维数过多增加了计算成本，要不就是数据过于集中，很难找到数据之间的特征。</p></li><li><p>在数据变换中，重点是如何将数值进行规范化，有三种常用的规范方法，分别是Min-Max规范化、Z-Score规范化、小数定标规范化。</p></li><li><p>针对数据库：规范化把关系满足的规范要求分为几级，满足要求最低的是第一范式（1NF），再来是第二范式、第三范式、BC范式和4NF、5NF等等，范数的等级越高，满足的约束集条件越严格。</p></li><li><p>针对数据：</p><p>1.数据的规范化包括归一化标准化正则化，是一个统称（也有人把标准化作为统称）。</p><p>2.数据规范化是数据挖掘中的数据变换的一种方式，数据变换将数据变换或统一成适合于数据挖掘的形式，将被挖掘对象的属性数据按比例缩放，使其落入一个小的特定区间内，如[-1, 1]或[0, 1]。</p><p>3.对属性值进行规范化常用于涉及神经网络和距离度量的分类算法和聚类算法当中。比如使用神经网络后向传播算法进行分类挖掘时，对训练元组中度量每个属性的输入值进行规范化有利于<strong>加快学习阶段的速度</strong>。对于基于距离度量相异度的方法，数据归一化能够让所有的<strong>属性具有相同的权值</strong>。</p></li></ul><a id="more"></a><h3 id="1-归一化（normalization）："><a href="#1-归一化（normalization）：" class="headerlink" title="1.归一化（normalization）："></a>1.归一化（normalization）：</h3><p>  把数值放缩到0到1的小区间中（归到数字信号处理范畴之内），一般方法是最小最大规范的方：Min-max规范化</p><p>  将原始数据投射到指定的空间[min,max]。可用公式表示为：</p><ul><li><p>新数值 = （原数值-极小值）/ (极大值 - 极小值) 。</p></li><li><p>$x^*=\frac {x-min} {max-min}$</p><p>SciKit-Learn中的MinMaxScaler可以完成这个功能。</p><p>上面min-max normalization是线性归一化，还有非线性归一化，通过一些数学函数，将原始值进行映射。该方法包括log、指数、反正切等。需要根据数据分布的情况，决定非线性函数的曲线。</p><p>log函数： $x=\frac {lg(x)} {lg(max)}$；反正切函数：$x=\frac {atan(x)*2} {pi}$</p><p><strong>应用：</strong></p><p>1.无量纲化<br>例如房子数量和收入，从业务层知道这两者的重要性一样，所以把它们全部归一化，这是从业务层面上作的处理。</p><p>2.避免数值问题<br>不同的数据在不同列数据的数量级相差过大的话，计算起来大数的变化会掩盖掉小数的变化。</p><p>3.一些模型求解的需要<br>例如梯度下降法，如果不归一化，当学习率较大时，求解过程会呈之字形下降。学习率较小，则会产生直角形路线，不管怎么样，都不会是好路线（路线解释看西面归一化和标准化的对比）。解释神经网络梯度下降的文章。</p><p>4.时间序列<br>进行log分析时，会将原本绝对化的时间序列归一化到某个基准时刻，形成相对时间序列，方便排查。</p><p>5.收敛速度<br>加快求解过程中参数的收敛速度。</p><p>特点：</p></li><li><p>对不同特征维度进行伸缩变换</p></li><li>改变原始数据的分布，使得各个特征维度对目标函数的影响权重归于一致（使得扁平分布的数据伸缩变换成类圆形）</li><li>对目标函数的影响体现在数值上</li><li><p>把有量纲表达式变为无量纲表达式</p><p> 归一化可以消除量纲对最终结果的影响，使不同变量具有可比性。比如两个人体重差10KG，身高差0.02M，在衡量两个人的差别时体重的差距会把身高的差距完全掩盖，归一化之后就不会有这样的问题。</p></li></ul><p><strong>好处：</strong></p><ol><li>提高迭代求解的收敛速度</li><li>提高迭代求解的精度</li></ol><p><strong>缺点：</strong></p><ol><li>最大值与最小值非常容易受异常点影响</li><li>鲁棒性较差，只适合传统精确小数据场景</li></ol><h3 id="2-标准化（standardization）"><a href="#2-标准化（standardization）" class="headerlink" title="2.标准化（standardization）"></a><strong>2.标准化（standardization）</strong></h3><p>  将原始数据转换为正态分布的形式，使结果易于比较。可用公式表示为：</p><ul><li>新数值 = （原数值 - 均值）/ 标准差 </li></ul><ul><li>$x^*$=(x-μ)/ρ</li></ul><p>在SciKit-Learn中的preprocessing.scale()可以直接将给定数据进行<strong>Z-Score规范化。</strong></p><p>数据标准化是将数据按比例缩放，使其落入到一个小的区间内，标准化后的数据可正可负，但是一般绝对值不会   太大，一般是z-score标准化方法：减去期望后除以标准差。</p><p><strong>特点：</strong></p><p>对不同特征维度的伸缩变换的目的是使其不同度量之间的特征具有可比性，同时不改变原始数据的分布。</p><p><strong>好处：</strong></p><ul><li><p>不改变原始数据的分布，保持各个特征维度对目标函数的影响权重</p></li><li><p>对目标函数的影响体现在几何分布上</p></li><li><p>在已有样本足够多的情况下比较稳定，适合现代嘈杂大数据场景</p></li></ul><h3 id="3-小数定标规范化："><a href="#3-小数定标规范化：" class="headerlink" title="3.小数定标规范化："></a><strong>3.小数定标规范化：</strong></h3><p>  通过移动小数点的位置来进行规范化。小数点移动的位数取决于该属性数据取值的最大绝对值。</p><p>  例如：属性A的取值范围是-800到70，那么就可以将数据的小数点整体向左移三位即[-0.8,0.07]</p><p>  利用numpy对数据进行小数定标规范化的方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.ceil(np.log10(np.max(abs(x))))</span><br><span class="line">scaled_x =x/(<span class="number">10</span>**a)</span><br></pre></td></tr></table></figure><h2 id="np-linalg-norm-求范数"><a href="#np-linalg-norm-求范数" class="headerlink" title="np.linalg.norm(求范数)"></a>np.linalg.norm(求范数)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x_norm=np.linalg.norm(x, ord=<span class="literal">None</span>, axis=<span class="literal">None</span>, keepdims=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h3 id="1-x-表示矩阵（也可以是一维）"><a href="#1-x-表示矩阵（也可以是一维）" class="headerlink" title="1. x: 表示矩阵（也可以是一维）"></a>1. <strong>x: 表示矩阵（也可以是一维）</strong></h3><h3 id="2-ord：范数类型"><a href="#2-ord：范数类型" class="headerlink" title="2. ord：范数类型"></a>2. <strong>ord：范数类型</strong></h3><p><strong>向量的范数</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">说明</th><th style="text-align:center">计算方法</th></tr></thead><tbody><tr><td style="text-align:center">默认</td><td style="text-align:center">二范数：L2</td><td style="text-align:center">$\sqrt {x^2_1+x^2_2+…+x^2_n}$</td></tr><tr><td style="text-align:center">ord=2</td><td style="text-align:center">二范数：L2</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">ord=1</td><td style="text-align:center">一范数：L1</td><td style="text-align:center">｜$x_1$｜+｜$x_2$｜+…+｜$x_n$｜</td></tr><tr><td style="text-align:center">ord=np.inf</td><td style="text-align:center">无穷范数：L<sub>∞</sub></td><td style="text-align:center">max(｜$x_1$｜)</td></tr></tbody></table></div><p><strong>矩阵的范数</strong>：</p><p>ord=1：列和的最大值</p><p>ord=2：|λE-ATA|=0，求特征值，然后求最大特征值得算术平方根(matlab在线版，计算ans=ATA，[x,y]=eig(ans)，sqrt(y)，x是特征向量，y是特征值)</p><p>ord=∞：行和的最大值</p><p>ord=None：默认情况下，是求整体的矩阵元素平方和，再开根号。（没仔细看，以为默认情况下就是矩阵的二范数，修正一下，默认情况下是求整个矩阵元素平方和再开根号）</p><h3 id="3-axis：处理类型"><a href="#3-axis：处理类型" class="headerlink" title="3. axis：处理类型"></a>3. <strong>axis：处理类型</strong></h3><p>  axis=1表示按行向量处理，求多个行向量的范数</p><p>  axis=0表示按列向量处理，求多个列向量的范数</p><p>  axis=None表示矩阵范数。</p><h3 id="4-keepding：是否保持矩阵的二维特性"><a href="#4-keepding：是否保持矩阵的二维特性" class="headerlink" title="4. keepding：是否保持矩阵的二维特性"></a>4. <strong>keepding：是否保持矩阵的二维特性</strong></h3><p>  True表示保持矩阵的二维特性，False相反</p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. <strong>总结</strong></h3><ul><li><p>矩阵的三种范数求法（应该是4种了，在默认情况下，又多出了一种情况）</p></li><li><p>向量的三种范数求法</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>人工智能初探</title>
      <link href="/2019/12/14/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%88%9D%E6%8E%A2/"/>
      <url>/2019/12/14/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="准备淌一淌人工智能的浑水！"><a href="#准备淌一淌人工智能的浑水！" class="headerlink" title="准备淌一淌人工智能的浑水！"></a>准备淌一淌人工智能的浑水！</h1><h3 id="准备路线：深度学习→图像分析"><a href="#准备路线：深度学习→图像分析" class="headerlink" title="准备路线：深度学习→图像分析"></a>准备路线：深度学习→图像分析</h3><p>人工智能(Artificial Intelligence)是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。人工智能是计算机科学的一个分支，它企图了解智能的实质，并生产出一种新的能以人类智能相似的方式作出反应的智能机器，该领域的研究包括机器人、语言识别、图像识别、自然语言处理和专家系统等。“人工智能是一门极富挑战性的科学，从事这项工作的人必须懂得计算机知识，心理学和哲学。人工智能是包括十分广泛的科学，它由不同的领域组成，如机器学习，计算机视觉等等，人工智能的发展历史是和计算机科学与技术的发展史联系在一起的。除了计算机科学以外, 人工智能还涉及信息论、控制论、自动化、仿生学、生物学、心理学、数理逻辑、语言学、医学和哲学等多门学科。人工智能学科研究的主要内容包括：知识表示、自动推理和搜索方法、机器学习和知识获取、知识处理系统、自然语言理解、计算机视觉、智能机器人、自动程序设计等方面。</p><a id="more"></a><h3 id="人工智能的5个研究发展阶段"><a href="#人工智能的5个研究发展阶段" class="headerlink" title="人工智能的5个研究发展阶段"></a>人工智能的5个研究发展阶段</h3><p><strong>第一阶段</strong>：50年代人工智能的兴起和冷落</p><p>人工智能概念首次提出后，相继出现了一批显著的成果，如机器定理证明、跳棋程序、通用问题s求解程序、LISP表处理语言等。但由于消解法推理能力的有限，以及机器翻译等的失败，使人工智能走入了低谷。这一阶段的特点是：重视问题求解的方法，忽视知识重要性。</p><p><strong>第二阶段</strong>：60年代末到70年代，专家系统出现，使人工智能研究出现新高潮，DENDRAL化学质谱分析系统、MYCIN疾病诊断和治疗系统、PROSPECTIOR探矿系统、Hearsay-II语音理解系统等专家系统的研究和开发，将人工智能引向了实用化。并且，1969年成立了国际人工智能联合会议。</p><p><strong>第三阶段</strong>：80年代，随着第五代计算机的研制，人工智能得到了很大发展。日本1982年开始了”第五代计算机研制计划”，即”知识信息处理计算机系统KIPS”，其目的是使逻辑推理达到数值运算那么快。虽然此计划最终失败，但它的开展形成了一股研究人工智能的热潮。</p><p><strong>第四阶段</strong>：80年代末，神经网络飞速发展 1987年，美国召开第一次神经网络国际会议，宣告了这一新学科的诞生。此后，各国在神经网络方面的投资逐渐增加，神经网络迅速发展起来。</p><p>第五阶段：90年代，人工智能出现新的研究高潮 由于网络技术特别是国际互连网的技术发展，人工智能开始由单个智能主体研究转向基于网络环境下的分布式人工智能研究。不仅研究基于同一目标的分布式问题求解，而且研究多个智能主体的多目标问题求解，将人工智能更面向实用。另外，由于Hopfield多层神经网络模型的提出，使人工神经网络研究与应用出现了欣欣向荣的景象。人工智能已深入到社会生活的各个领域。</p><p>目前人工智能应用人工智能是在计算机科学、控制论、信息论、心理学、语言学等多种学科相互渗透的基础发展起来的一门新兴边缘学科，主要研究用用机器（主要是计算机）来模仿和实现人类的智能行为，经过几十年的发展，人工智能应用在不少领域得到发展，在我们的日常生活和学习当中也有许多地方得到应用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宝塔二级域名javaweb项目ssl配置踩坑</title>
      <link href="/2019/11/29/%E5%AE%9D%E5%A1%94%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8Djavaweb%E9%A1%B9%E7%9B%AEssl%E9%85%8D%E7%BD%AE%E8%B8%A9%E5%9D%91/"/>
      <url>/2019/11/29/%E5%AE%9D%E5%A1%94%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8Djavaweb%E9%A1%B9%E7%9B%AEssl%E9%85%8D%E7%BD%AE%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h2 id="1、环境"><a href="#1、环境" class="headerlink" title="1、环境"></a>1、环境</h2><ul><li>宝塔界面</li><li>nginx</li><li>tomcat</li><li>javaweb项目</li><li>ssl个人单域名证书（免费）</li></ul><h2 id="2、注意事项"><a href="#2、注意事项" class="headerlink" title="2、注意事项"></a>2、注意事项</h2><ul><li>域名是否正确的解析 </li><li>防火墙是否打开（宝塔和阿里云服务器防火墙都要打开 80和443端口）</li><li>网站是否301或302跳转，如果跳转了也要关闭</li><li><strong>单域名证书会有指定域名，二级域名必须重新申请</strong></li><li>二级域名一定要解析A记录到服务器ip</li><li>域名备案只用备案顶级域名，二级域名不用备案</li><li>如果有多个二级域名和一个主域名，当主域名开启强制ssl后，没有开启ssl的二级域名会被解析到主域名或其他二级域名需要注意</li></ul><a id="more"></a><h2 id="3、步骤"><a href="#3、步骤" class="headerlink" title="3、步骤"></a>3、步骤</h2><p>1)删除原装openjdk，安装JDK1.8</p><p>2)在宝塔软件页面找到tomcat，按需求版本安装</p><p>3)打开tomcat目录在webapps文件夹下上传并解压war包（可以改名为ROOT，默认为ROOT目录是tomcat识别目录）</p><p>4)tomcat配置文件中20行的<code>appBase=&quot;&quot;</code>一定为空，11行中添加参数<code>scheme=&quot;https&quot;</code>  如果端口号在这里更改，后面站点配置文件<code>proxy_pass &quot;域名:端口号&quot;;</code>中一定要对应</p><p>5)新建站点选择war解压后目录，域名填阿里云域名设置A记录解析的二级域名，站点设置ssl页面输入从阿里云下载的.key和.pem文件内容点击启用</p><p>6)在站点设置配置文件中检查<code>proxy_pass &quot;域名:端口号&quot;;</code>内容要与4中tomcat端口对应</p><p>7)在站点设置tomcat页面点击启动tomcat</p><p>8)使用https测试效果，也可以在ssl页面设置强制ssl</p>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式Servlet容器（七）</title>
      <link href="/2019/11/25/%E5%B5%8C%E5%85%A5%E5%BC%8FServlet%E5%AE%B9%E5%99%A8%EF%BC%88%E4%B8%83%EF%BC%89/"/>
      <url>/2019/11/25/%E5%B5%8C%E5%85%A5%E5%BC%8FServlet%E5%AE%B9%E5%99%A8%EF%BC%88%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="嵌入式Servlet容器"><a href="#嵌入式Servlet容器" class="headerlink" title="嵌入式Servlet容器"></a>嵌入式Servlet容器</h1><h3 id="一、如何定制和修改Servlet容器的相关配置；"><a href="#一、如何定制和修改Servlet容器的相关配置；" class="headerlink" title="一、如何定制和修改Servlet容器的相关配置；"></a>一、如何定制和修改Servlet容器的相关配置；</h3><ul><li>修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）；</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8081</span></span><br><span class="line"><span class="meta">server.context-path</span>=<span class="string">/crud</span></span><br><span class="line"></span><br><span class="line"><span class="meta">server.tomcat.uri-encoding</span>=<span class="string">UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="attr">//通用的Servlet容器设置</span></span><br><span class="line"><span class="attr">server.xxx</span></span><br><span class="line"><span class="attr">//Tomcat的设置</span></span><br><span class="line"><span class="attr">server.tomcat.xxx</span></span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>编写一个<strong>EmbeddedServletContainerCustomizer</strong>：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>  <span class="comment">//一定要将这个定制器加入到容器中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EmbeddedServletContainerCustomizer <span class="title">embeddedServletContainerCustomizer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedServletContainerCustomizer() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定制嵌入式的Servlet容器相关的规则</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableEmbeddedServletContainer container)</span> </span>&#123;</span><br><span class="line">            container.setPort(<span class="number">8083</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、如何定制和修改Servlet容器的相关配置；"><a href="#二、如何定制和修改Servlet容器的相关配置；" class="headerlink" title="二、如何定制和修改Servlet容器的相关配置；"></a>二、如何定制和修改Servlet容器的相关配置；</h3><ul><li>修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）；</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8081</span></span><br><span class="line"><span class="meta">server.context-path</span>=<span class="string">/crud</span></span><br><span class="line"></span><br><span class="line"><span class="meta">server.tomcat.uri-encoding</span>=<span class="string">UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="attr">//通用的Servlet容器设置</span></span><br><span class="line"><span class="attr">server.xxx</span></span><br><span class="line"><span class="attr">//Tomcat的设置</span></span><br><span class="line"><span class="attr">server.tomcat.xxx</span></span><br></pre></td></tr></table></figure><ul><li>编写一个<strong>EmbeddedServletContainerCustomizer</strong>：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>  <span class="comment">//一定要将这个定制器加入到容器中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EmbeddedServletContainerCustomizer <span class="title">embeddedServletContainerCustomizer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedServletContainerCustomizer() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定制嵌入式的Servlet容器相关的规则</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableEmbeddedServletContainer container)</span> </span>&#123;</span><br><span class="line">            container.setPort(<span class="number">8083</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、注册Servlet三大组件【Servlet、Filter、Listener】"><a href="#三、注册Servlet三大组件【Servlet、Filter、Listener】" class="headerlink" title="三、注册Servlet三大组件【Servlet、Filter、Listener】"></a>三、注册Servlet三大组件【Servlet、Filter、Listener】</h3><ul><li><p>由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。</p></li><li><p>注册三大组件用以下方式</p></li><li><p>ServletRegistrationBean</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册三大组件</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">myServlet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ServletRegistrationBean registrationBean = <span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> MyServlet(),<span class="string">"/myServlet"</span>);</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>FilterRegistrationBean</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">myFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FilterRegistrationBean registrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">    registrationBean.setFilter(<span class="keyword">new</span> MyFilter());</span><br><span class="line">    registrationBean.setUrlPatterns(Arrays.asList(<span class="string">"/hello"</span>,<span class="string">"/myServlet"</span>));</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ServletListenerRegistrationBean</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletListenerRegistrationBean <span class="title">myListener</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = <span class="keyword">new</span> ServletListenerRegistrationBean&lt;&gt;(<span class="keyword">new</span> MyListener());</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet；</p></li><li><p>DispatcherServletAutoConfiguration中：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)</span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">dispatcherServletRegistration</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      DispatcherServlet dispatcherServlet)</span> </span>&#123;</span><br><span class="line">   ServletRegistrationBean registration = <span class="keyword">new</span> ServletRegistrationBean(</span><br><span class="line">         dispatcherServlet, <span class="keyword">this</span>.serverProperties.getServletMapping());</span><br><span class="line">    <span class="comment">//默认拦截： /  所有请求；包静态资源，但是不拦截jsp请求；   /*会拦截jsp</span></span><br><span class="line">    <span class="comment">//可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径</span></span><br><span class="line">    </span><br><span class="line">   registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);</span><br><span class="line">   registration.setLoadOnStartup(</span><br><span class="line">         <span class="keyword">this</span>.webMvcProperties.getServlet().getLoadOnStartup());</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.multipartConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">      registration.setMultipartConfig(<span class="keyword">this</span>.multipartConfig);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、替换为其他嵌入式Servlet容器"><a href="#四、替换为其他嵌入式Servlet容器" class="headerlink" title="四、替换为其他嵌入式Servlet容器"></a>四、替换为其他嵌入式Servlet容器</h3><p>默认支持：</p><p>Tomcat（默认使用）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；</span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Jetty(常做长连接——聊天类)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入web模块 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入其他的Servlet容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Undertow（不支持JSP，高并发）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入web模块 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入其他的Servlet容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-undertow<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="五、嵌入式Servlet容器自动配置原理；"><a href="#五、嵌入式Servlet容器自动配置原理；" class="headerlink" title="五、嵌入式Servlet容器自动配置原理；"></a>五、嵌入式Servlet容器自动配置原理；</h3><ul><li>EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigureOrder</span>(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span></span><br><span class="line"><span class="meta">@Import</span>(BeanPostProcessorsRegistrar.class)</span><br><span class="line"><span class="comment">//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件</span></span><br><span class="line"><span class="comment">//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：</span></span><br><span class="line"><span class="comment">//后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedServletContainerAutoConfiguration</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; Servlet.class, Tomcat.class &#125;)<span class="comment">//判断当前是否引入了Tomcat依赖；</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)<span class="comment">//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedTomcat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TomcatEmbeddedServletContainerFactory <span class="title">tomcatEmbeddedServletContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> TomcatEmbeddedServletContainerFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Nested configuration if Jetty is being used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; Servlet.class, Server.class, Loader.class,</span><br><span class="line">WebAppContext.class &#125;)</span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedJetty</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JettyEmbeddedServletContainerFactory <span class="title">jettyEmbeddedServletContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JettyEmbeddedServletContainerFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Nested configuration if Undertow is being used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; Servlet.class, Undertow.class, SslClientAuthMode.class &#125;)</span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedUndertow</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UndertowEmbeddedServletContainerFactory <span class="title">undertowEmbeddedServletContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> UndertowEmbeddedServletContainerFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmbeddedServletContainerFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取嵌入式的Servlet容器</span></span><br><span class="line">   <span class="function">EmbeddedServletContainer <span class="title">getEmbeddedServletContainer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">         ServletContextInitializer... initializers)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）、EmbeddedServletContainer：（嵌入式的Servlet容器）</p><p>3）、以<strong>TomcatEmbeddedServletContainerFactory</strong>为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EmbeddedServletContainer <span class="title">getEmbeddedServletContainer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      ServletContextInitializer... initializers)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个Tomcat</span></span><br><span class="line">   Tomcat tomcat = <span class="keyword">new</span> Tomcat();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//配置Tomcat的基本环节</span></span><br><span class="line">   File baseDir = (<span class="keyword">this</span>.baseDirectory != <span class="keyword">null</span> ? <span class="keyword">this</span>.baseDirectory</span><br><span class="line">         : createTempDir(<span class="string">"tomcat"</span>));</span><br><span class="line">   tomcat.setBaseDir(baseDir.getAbsolutePath());</span><br><span class="line">   Connector connector = <span class="keyword">new</span> Connector(<span class="keyword">this</span>.protocol);</span><br><span class="line">   tomcat.getService().addConnector(connector);</span><br><span class="line">   customizeConnector(connector);</span><br><span class="line">   tomcat.setConnector(connector);</span><br><span class="line">   tomcat.getHost().setAutoDeploy(<span class="keyword">false</span>);</span><br><span class="line">   configureEngine(tomcat.getEngine());</span><br><span class="line">   <span class="keyword">for</span> (Connector additionalConnector : <span class="keyword">this</span>.additionalTomcatConnectors) &#123;</span><br><span class="line">      tomcat.getService().addConnector(additionalConnector);</span><br><span class="line">   &#125;</span><br><span class="line">   prepareContext(tomcat.getHost(), initializers);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器</span></span><br><span class="line">   <span class="keyword">return</span> getTomcatEmbeddedServletContainer(tomcat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）、我们对嵌入式容器的配置修改是怎么生效？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerProperties、EmbeddedServletContainerCustomizer</span><br></pre></td></tr></table></figure><p><strong>EmbeddedServletContainerCustomizer</strong>：定制器帮我们修改了Servlet容器的配置？</p><ul><li>怎么修改的原理:</li></ul><p>5）、容器中导入了<strong>EmbeddedServletContainerCustomizerBeanPostProcessor</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化之前</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">//如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件</span></span><br><span class="line">   <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ConfigurableEmbeddedServletContainer) &#123;</span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">      postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postProcessBeforeInitialization</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ConfigurableEmbeddedServletContainer bean)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值；</span></span><br><span class="line">    <span class="keyword">for</span> (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123;</span><br><span class="line">        customizer.customize(bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Collection&lt;EmbeddedServletContainerCustomizer&gt; <span class="title">getCustomizers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.customizers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Look up does not include the parent context</span></span><br><span class="line">        <span class="keyword">this</span>.customizers = <span class="keyword">new</span> ArrayList&lt;EmbeddedServletContainerCustomizer&gt;(</span><br><span class="line">            <span class="keyword">this</span>.beanFactory</span><br><span class="line">            <span class="comment">//从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer</span></span><br><span class="line">            <span class="comment">//定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件</span></span><br><span class="line">            .getBeansOfType(EmbeddedServletContainerCustomizer.class,</span><br><span class="line">                            <span class="keyword">false</span>, <span class="keyword">false</span>)</span><br><span class="line">            .values());</span><br><span class="line">        Collections.sort(<span class="keyword">this</span>.customizers, AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">        <span class="keyword">this</span>.customizers = Collections.unmodifiableList(<span class="keyword">this</span>.customizers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.customizers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ServerProperties也是定制器</span><br></pre></td></tr></table></figure><p>步骤：</p><p>1）、SpringBoot根据导入的依赖情况，给容器中添加相应的     EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】</p><p>2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor；</p><ul><li>只要是嵌入式的Servlet容器工厂，后置处理器就工作；</li></ul><p>3）、后置处理器，从容器中获取所有的<strong>EmbeddedServletContainerCustomizer</strong>，调用定制器的定制方法</p><h3 id="六、嵌入式Servlet容器启动原理；"><a href="#六、嵌入式Servlet容器启动原理；" class="headerlink" title="六、嵌入式Servlet容器启动原理；"></a>六、嵌入式Servlet容器启动原理；</h3><ul><li>什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat；</li></ul><p><strong>获取嵌入式的Servlet容器工厂：</strong></p><p>1）、SpringBoot应用启动运行run方法</p><p>2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建<strong>AnnotationConfigEmbeddedWebApplicationContext</strong>，否则：<strong>AnnotationConfigApplicationContext</strong></p><p>3）、refresh(context);<strong>刷新刚才创建好的ioc容器；</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">      <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                  <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）、  onRefresh(); web的ioc容器重写了onRefresh方法</p><p>5）、webioc容器会创建嵌入式的Servlet容器；<strong>createEmbeddedServletContainer</strong>();</p><p><strong>6）、获取嵌入式的Servlet容器工厂：</strong></p><ul><li><p>EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory();</p><p>  从ioc容器中获取EmbeddedServletContainerFactory 组件；<strong>TomcatEmbeddedServletContainerFactory</strong>创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置；</p></li></ul><p>7）、<strong>使用容器工厂获取嵌入式的Servlet容器</strong>：this.embeddedServletContainer = containerFactory      .getEmbeddedServletContainer(getSelfInitializer());</p><p>8）、嵌入式的Servlet容器创建对象并启动Servlet容器；</p><ul><li><p><strong>先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来；</strong></p></li><li><p><strong>IOC容器启动创建嵌入式的Servlet容器</strong></p></li></ul><h3 id="七、使用外置的Servlet容器"><a href="#七、使用外置的Servlet容器" class="headerlink" title="七、使用外置的Servlet容器"></a>七、使用外置的Servlet容器</h3><ul><li>嵌入式Servlet容器：应用打成可执行的jar</li></ul><pre><code>    优点：简单、便携；    缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）；</code></pre><ul><li>外置的Servlet容器：外面安装Tomcat—-应用war包的方式打包；</li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>1）、必须创建一个war项目；（利用idea创建好目录结构）</p><p>2）、将嵌入式的Tomcat指定为provided；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3）、必须编写一个<strong>SpringBootServletInitializer</strong>的子类，并调用configure方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletInitializer</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder application)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//传入SpringBoot应用的主程序</span></span><br><span class="line">      <span class="keyword">return</span> application.sources(SpringBoot04WebJspApplication.class);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）、启动服务器就可以使用；</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器；</p><p>war包：启动服务器，<strong>服务器启动SpringBoot应用</strong>【SpringBootServletInitializer】，启动ioc容器；</p><p>servlet3.0（Spring注解版）：</p><p>8.2.4 Shared libraries / runtimes pluggability：</p><p>规则：</p><pre><code>1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例：2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类；</code></pre><p>流程：</p><p>1）、启动Tomcat</p><p>2）、org\springframework\spring-web\4.3.14.RELEASE\spring-web-4.3.14.RELEASE.jar!\META-INF\services\javax.servlet.ServletContainerInitializer：</p><ul><li>Spring的web模块里面有这个文件：<strong>org.springframework.web.SpringServletContainerInitializer</strong></li></ul><p>3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set<class<?>&gt;；为这些WebApplicationInitializer类型的类创建实例；</class<?></p><p>4）、每一个WebApplicationInitializer都调用自己的onStartup；</p><p>5）、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法</p><p>6）、SpringBootServletInitializer实例执行onStartup的时候会createRootApplicationContext；创建容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createRootApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、创建SpringApplicationBuilder</span></span><br><span class="line">   SpringApplicationBuilder builder = createSpringApplicationBuilder();</span><br><span class="line">   StandardServletEnvironment environment = <span class="keyword">new</span> StandardServletEnvironment();</span><br><span class="line">   environment.initPropertySources(servletContext, <span class="keyword">null</span>);</span><br><span class="line">   builder.environment(environment);</span><br><span class="line">   builder.main(getClass());</span><br><span class="line">   ApplicationContext parent = getExistingRootWebApplicationContext(servletContext);</span><br><span class="line">   <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.logger.info(<span class="string">"Root context already created (using as parent)."</span>);</span><br><span class="line">      servletContext.setAttribute(</span><br><span class="line">            WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">null</span>);</span><br><span class="line">      builder.initializers(<span class="keyword">new</span> ParentContextApplicationContextInitializer(parent));</span><br><span class="line">   &#125;</span><br><span class="line">   builder.initializers(</span><br><span class="line">         <span class="keyword">new</span> ServletContextApplicationContextInitializer(servletContext));</span><br><span class="line">   builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来</span></span><br><span class="line">   builder = configure(builder);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用builder创建一个Spring应用</span></span><br><span class="line">   SpringApplication application = builder.build();</span><br><span class="line">   <span class="keyword">if</span> (application.getSources().isEmpty() &amp;&amp; AnnotationUtils</span><br><span class="line">         .findAnnotation(getClass(), Configuration.class) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      application.getSources().add(getClass());</span><br><span class="line">   &#125;</span><br><span class="line">   Assert.state(!application.getSources().isEmpty(),</span><br><span class="line">         <span class="string">"No SpringApplication sources have been defined. Either override the "</span></span><br><span class="line">               + <span class="string">"configure method or add an @Configuration annotation"</span>);</span><br><span class="line">   <span class="comment">// Ensure error pages are registered</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.registerErrorPageFilter) &#123;</span><br><span class="line">      application.getSources().add(ErrorPageFilterConfiguration.class);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//启动Spring应用</span></span><br><span class="line">   <span class="keyword">return</span> run(application);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7）、Spring的应用就启动并且创建IOC容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">   StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">   stopWatch.start();</span><br><span class="line">   ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">   FailureAnalyzers analyzers = <span class="keyword">null</span>;</span><br><span class="line">   configureHeadlessProperty();</span><br><span class="line">   SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">   listeners.starting();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">            args);</span><br><span class="line">      ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">            applicationArguments);</span><br><span class="line">      Banner printedBanner = printBanner(environment);</span><br><span class="line">      context = createApplicationContext();</span><br><span class="line">      analyzers = <span class="keyword">new</span> FailureAnalyzers(context);</span><br><span class="line">      prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">            printedBanner);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//刷新IOC容器</span></span><br><span class="line">      refreshContext(context);</span><br><span class="line">      afterRefresh(context, applicationArguments);</span><br><span class="line">      listeners.finished(context, <span class="keyword">null</span>);</span><br><span class="line">      stopWatch.stop();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">         <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">               .logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> context;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      handleRunFailure(context, listeners, analyzers, ex);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>启动Servlet容器，再启动SpringBoot应用</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> java web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC自动配置（六）</title>
      <link href="/2019/11/23/SpringMVC%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%EF%BC%88%E5%85%AD%EF%BC%89/"/>
      <url>/2019/11/23/SpringMVC%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%EF%BC%88%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC自动配置"><a href="#SpringMVC自动配置" class="headerlink" title="SpringMVC自动配置"></a>SpringMVC自动配置</h1><p><a href="https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications</a></p><h3 id="1-Spring-MVC-auto-configuration"><a href="#1-Spring-MVC-auto-configuration" class="headerlink" title="1. Spring MVC auto-configuration"></a>1. Spring MVC auto-configuration</h3><p>Spring Boot 自动配置好了SpringMVC</p><p>以下是SpringBoot对SpringMVC的默认配置:<strong>（WebMvcAutoConfiguration）</strong></p><ul><li><p>Inclusion of <code>ContentNegotiatingViewResolver</code> and <code>BeanNameViewResolver</code> beans.</p><ul><li>自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？））</li><li>ContentNegotiatingViewResolver：组合所有的视图解析器的；</li><li>如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；</li></ul></li><li><p>Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars</p></li><li><p>Static <code>index.html</code> support. 静态首页访问</p></li><li><p>Custom <code>Favicon</code> support (see below).  favicon.ico</p></li></ul><ul><li><p>自动注册了 of <code>Converter</code>, <code>GenericConverter</code>, <code>Formatter</code> beans.</p><ul><li>Converter：转换器；  public String hello(User user)：类型转换使用Converter</li><li><code>Formatter</code>  格式化器；  2017.12.17===Date；</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.mvc"</span>, name = <span class="string">"date-format"</span>)<span class="comment">//在文件中配置日期格式化的规则</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Formatter&lt;Date&gt; <span class="title">dateFormatter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DateFormatter(<span class="keyword">this</span>.mvcProperties.getDateFormat());<span class="comment">//日期格式化组件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>自己添加的格式化器转换器，我们只需要放在容器中即可</p></li><li><p>Support for <code>HttpMessageConverters</code> (see below).</p><ul><li><p>HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—-Json；</p></li><li><p><code>HttpMessageConverters</code> 是从容器中确定；获取所有的HttpMessageConverter；</p></li><li><p>自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）</p></li></ul></li></ul><a id="more"></a><ul><li><p>Automatic registration of <code>MessageCodesResolver</code> (see below).定义错误代码生成规则</p></li><li><p>Automatic use of a <code>ConfigurableWebBindingInitializer</code> bean (see below).</p><p>我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">初始化WebDataBinder；</span><br><span class="line">请求数据=====JavaBean；</span><br></pre></td></tr></table></figure></li></ul><p><strong>org.springframework.boot.autoconfigure.web：web的所有自动场景；</strong></p><p>If you want to keep Spring Boot MVC features, and you just want to add additional <a href="https://docs.spring.io/spring/docs/4.3.14.RELEASE/spring-framework-reference/htmlsingle#mvc" target="_blank" rel="noopener">MVC configuration</a> (interceptors, formatters, view controllers etc.) you can add your own <code>@Configuration</code> class of type <code>WebMvcConfigurerAdapter</code>, but <strong>without</strong> <code>@EnableWebMvc</code>. If you wish to provide custom instances of <code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code> or <code>ExceptionHandlerExceptionResolver</code> you can declare a <code>WebMvcRegistrationsAdapter</code> instance providing such components.</p><p>If you want to take complete control of Spring MVC, you can add your own <code>@Configuration</code> annotated with <code>@EnableWebMvc</code>.</p><h3 id="2、扩展SpringMVC"><a href="#2、扩展SpringMVC" class="headerlink" title="2、扩展SpringMVC"></a>2、扩展SpringMVC</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">"/hello"</span> <span class="attr">view-name</span>=<span class="string">"success"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/hello"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc</strong>;</li></ul><p>既保留了所有的自动配置，也能用我们扩展的配置；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMvcConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// super.addViewControllers(registry);</span></span><br><span class="line">        <span class="comment">//浏览器发送 /atguigu 请求来到 success</span></span><br><span class="line">        registry.addViewController(<span class="string">"/atguigu"</span>).setViewName(<span class="string">"success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理：</p><p>1）、WebMvcAutoConfiguration是SpringMVC的自动配置类</p><p>2）、在做其他自动配置时会导入；@Import(<strong>EnableWebMvcConfiguration</strong>.class)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EnableWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">DelegatingWebMvcConfiguration</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> WebMvcConfigurerComposite configurers = <span class="keyword">new</span> WebMvcConfigurerComposite();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//从容器中获取所有的WebMvcConfigurer</span></span><br><span class="line">     <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigurers</span><span class="params">(List&lt;WebMvcConfigurer&gt; configurers)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (!CollectionUtils.isEmpty(configurers)) &#123;</span><br><span class="line">             <span class="keyword">this</span>.configurers.addWebMvcConfigurers(configurers);</span><br><span class="line">           <span class="comment">//一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用；  </span></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">// public void addViewControllers(ViewControllerRegistry registry) &#123;</span></span><br><span class="line">             <span class="comment">//    for (WebMvcConfigurer delegate : this.delegates) &#123;</span></span><br><span class="line">              <span class="comment">//       delegate.addViewControllers(registry);</span></span><br><span class="line">              <span class="comment">//   &#125;</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）、容器中所有的WebMvcConfigurer都会一起起作用；</p><p>4）、我们的配置类也会被调用；</p><p>效果：SpringMVC的自动配置和我们的扩展配置都会起作用；</p><h3 id="3、全面接管SpringMVC；"><a href="#3、全面接管SpringMVC；" class="headerlink" title="3、全面接管SpringMVC；"></a>3、全面接管SpringMVC；</h3><p>SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了</p><p><strong>我们需要在配置类中添加@EnableWebMvc即可；</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMvcConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// super.addViewControllers(registry);</span></span><br><span class="line">        <span class="comment">//浏览器发送 /atguigu 请求来到 success</span></span><br><span class="line">        registry.addViewController(<span class="string">"/atguigu"</span>).setViewName(<span class="string">"success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理：</p><p>为什么@EnableWebMvc自动配置就失效了；</p><p>1）@EnableWebMvc的核心</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(DelegatingWebMvcConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableWebMvc &#123;</span><br></pre></td></tr></table></figure><p>2）、</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>3）、</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; Servlet.class, DispatcherServlet.class,</span><br><span class="line">WebMvcConfigurerAdapter.class &#125;)</span><br><span class="line"><span class="comment">//容器中没有这个组件的时候，这个自动配置类才生效</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(WebMvcConfigurationSupport.class)</span><br><span class="line"><span class="meta">@AutoConfigureOrder</span>(Ordered.HIGHEST_PRECEDENCE + <span class="number">10</span>)</span><br><span class="line"><span class="meta">@AutoConfigureAfter</span>(&#123; DispatcherServletAutoConfiguration.class,</span><br><span class="line">ValidationAutoConfiguration.class &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcAutoConfiguration</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来；</p><p>5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能；</p><h3 id="4、如何修改SpringBoot的默认配置"><a href="#4、如何修改SpringBoot的默认配置" class="headerlink" title="4、如何修改SpringBoot的默认配置"></a>4、如何修改SpringBoot的默认配置</h3><p>模式：</p><pre><code>1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来；2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> java web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thymeleaf使用(五)</title>
      <link href="/2019/11/21/Thymeleaf%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/11/21/Thymeleaf%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Thymeleaf使用"><a href="#Thymeleaf使用" class="headerlink" title="Thymeleaf使用"></a>Thymeleaf使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.thymeleaf"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThymeleafProperties</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_ENCODING = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf(<span class="string">"text/html"</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PREFIX = <span class="string">"classpath:/templates/"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SUFFIX = <span class="string">".html"</span>;</span><br></pre></td></tr></table></figure><ul><li><p>只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染；</p></li><li><p>使用：</p></li></ul><h3 id="1、导入thymeleaf的名称空间"><a href="#1、导入thymeleaf的名称空间" class="headerlink" title="1、导入thymeleaf的名称空间"></a>1、导入thymeleaf的名称空间</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、使用thymeleaf语法；"><a href="#2、使用thymeleaf语法；" class="headerlink" title="2、使用thymeleaf语法；"></a>2、使用thymeleaf语法；</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>成功！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--th:text 将div里面的文本内容设置为 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:text</span>=<span class="string">"$&#123;hello&#125;"</span>&gt;</span>这是显示欢迎信息<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="3、语法规则"><a href="#3、语法规则" class="headerlink" title="3、语法规则"></a>3、语法规则</h3><h4 id="1）、th-text；改变当前元素里面的文本内容；"><a href="#1）、th-text；改变当前元素里面的文本内容；" class="headerlink" title="1）、th:text；改变当前元素里面的文本内容；"></a>1）、th:text；改变当前元素里面的文本内容；</h4><ul><li>th：任意html属性；来替换原生属性的值</li></ul><h4 id="2）、表达式"><a href="#2）、表达式" class="headerlink" title="2）、表达式"></a>2）、表达式</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Simple</span> <span class="string">expressions:（表达式语法）</span></span><br><span class="line">    <span class="attr">Variable</span> <span class="string">Expressions: $&#123;...&#125;：获取变量值；OGNL；</span></span><br><span class="line">    <span class="attr">1）、获取对象的属性、调用方法</span></span><br><span class="line">    <span class="attr">2）、使用内置的基本对象：</span></span><br><span class="line"><span class="comment">    #ctx : the context object.</span></span><br><span class="line"><span class="comment">    #vars: the context variables.</span></span><br><span class="line"><span class="comment">                #locale : the context locale.</span></span><br><span class="line"><span class="comment">                #request : (only in Web Contexts) the HttpServletRequest object.</span></span><br><span class="line"><span class="comment">                #response : (only in Web Contexts) the HttpServletResponse object.</span></span><br><span class="line"><span class="comment">                #session : (only in Web Contexts) the HttpSession object.</span></span><br><span class="line"><span class="comment">                #servletContext : (only in Web Contexts) the ServletContext object.</span></span><br><span class="line">                <span class="attr">$&#123;session.foo&#125;</span></span><br><span class="line">                <span class="attr">3）、内置的一些工具对象：</span></span><br><span class="line"><span class="comment">                #execInfo : information about the template being processed.</span></span><br><span class="line"><span class="comment">                #messages : methods for obtaining externalized messages inside variables</span></span><br><span class="line"><span class="comment">                #expressions, in the same way as they would be obtained using #&#123;…&#125; syntax.</span></span><br><span class="line"><span class="comment">                #uris : methods for escaping parts of URLs/URIs</span></span><br><span class="line"><span class="comment">                #conversions : methods for executing the configured conversion service (if any).</span></span><br><span class="line"><span class="comment">                #dates : methods for java.util.Date objects: formatting, component extraction, etc.</span></span><br><span class="line"><span class="comment">                #calendars : analogous to #dates , but for java.util.Calendar objects.</span></span><br><span class="line"><span class="comment">                #numbers : methods for formatting numeric objects.</span></span><br><span class="line"><span class="comment">                #strings : methods for String objects: contains, startsWith, prepending/appending, etc.</span></span><br><span class="line"><span class="comment">                #objects : methods for objects in general.</span></span><br><span class="line"><span class="comment">                #bools : methods for boolean evaluation.</span></span><br><span class="line"><span class="comment">                #arrays : methods for arrays.</span></span><br><span class="line"><span class="comment">                #lists : methods for lists.</span></span><br><span class="line"><span class="comment">                #sets : methods for sets.</span></span><br><span class="line"><span class="comment">                #maps : methods for maps.</span></span><br><span class="line"><span class="comment">                #aggregates : methods for creating aggregates on arrays or collections.</span></span><br><span class="line"><span class="comment">                #ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration).</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">Selection</span> <span class="string">Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样；</span></span><br><span class="line">    <span class="meta">补充：配合</span> <span class="string">th:object="$&#123;session.user&#125;：</span></span><br><span class="line">        <span class="meta">&lt;div</span> <span class="string">th:object="$&#123;session.user&#125;"&gt;</span></span><br><span class="line">        <span class="meta">&lt;p&gt;Name</span>: <span class="string">&lt;span th:text="*&#123;firstName&#125;"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;</span></span><br><span class="line">        <span class="meta">&lt;p&gt;Surname</span>: <span class="string">&lt;span th:text="*&#123;lastName&#125;"&gt;Pepper&lt;/span&gt;.&lt;/p&gt;</span></span><br><span class="line">        <span class="meta">&lt;p&gt;Nationality</span>: <span class="string">&lt;span th:text="*&#123;nationality&#125;"&gt;Saturn&lt;/span&gt;.&lt;/p&gt;</span></span><br><span class="line">        <span class="attr">&lt;/div&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="attr">Message</span> <span class="string">Expressions: #&#123;...&#125;：获取国际化内容</span></span><br><span class="line">        <span class="attr">Link</span> <span class="string">URL Expressions: @&#123;...&#125;：定义URL；</span></span><br><span class="line">    <span class="meta">@&#123;/order/process(execId</span>=<span class="string">$&#123;execId&#125;,execType='FAST')&#125;</span></span><br><span class="line">        <span class="attr">Fragment</span> <span class="string">Expressions: ~&#123;...&#125;：片段引用表达式</span></span><br><span class="line">        <span class="meta">&lt;div</span> <span class="string">th:insert="~&#123;commons :: main&#125;"&gt;...&lt;/div&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="attr">Literals（字面量）</span></span><br><span class="line">        <span class="attr">Text</span> <span class="string">literals: 'one text' , 'Another one!' ,…</span></span><br><span class="line">        <span class="attr">Number</span> <span class="string">literals: 0 , 34 , 3.0 , 12.3 ,…</span></span><br><span class="line">        <span class="attr">Boolean</span> <span class="string">literals: true , false</span></span><br><span class="line">        <span class="attr">Null</span> <span class="string">literal: null</span></span><br><span class="line">        <span class="attr">Literal</span> <span class="string">tokens: one , sometext , main ,…</span></span><br><span class="line">        <span class="attr">Text</span> <span class="string">operations:（文本操作）</span></span><br><span class="line">        <span class="attr">String</span> <span class="string">concatenation: +</span></span><br><span class="line">        <span class="attr">Literal</span> <span class="string">substitutions: |The name is $&#123;name&#125;|</span></span><br><span class="line">        <span class="attr">Arithmetic</span> <span class="string">operations:（数学运算）</span></span><br><span class="line">        <span class="attr">Binary</span> <span class="string">operators: + , - , * , / , %</span></span><br><span class="line">        <span class="attr">Minus</span> <span class="string">sign (unary operator): -</span></span><br><span class="line">        <span class="attr">Boolean</span> <span class="string">operations:（布尔运算）</span></span><br><span class="line">        <span class="attr">Binary</span> <span class="string">operators: and , or</span></span><br><span class="line">        <span class="attr">Boolean</span> <span class="string">negation (unary operator): ! , not</span></span><br><span class="line">        <span class="attr">Comparisons</span> <span class="string">and equality:（比较运算）</span></span><br><span class="line">        <span class="attr">Comparators</span>: <span class="string">&gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )</span></span><br><span class="line">        <span class="attr">Equality</span> <span class="string">operators: == , != ( eq , ne )</span></span><br><span class="line">        <span class="attr">Conditional</span> <span class="string">operators:条件运算（三元运算符）</span></span><br><span class="line">        <span class="meta">If-then</span>: <span class="string">(if) ? (then)</span></span><br><span class="line">        <span class="meta">If-then-else</span>: <span class="string">(if) ? (then) : (else)</span></span><br><span class="line">        <span class="attr">Default</span>: <span class="string">(value) ?: (defaultvalue)</span></span><br><span class="line">        <span class="attr">Special</span> <span class="string">tokens:</span></span><br><span class="line">        <span class="meta">No-Operation</span>: <span class="string">_</span></span><br></pre></td></tr></table></figure><p><strong>开发期间模板引擎页面修改以后，要实时生效</strong></p><h4 id="3）、禁用模板引擎的缓存"><a href="#3）、禁用模板引擎的缓存" class="headerlink" title="3）、禁用模板引擎的缓存"></a>3）、禁用模板引擎的缓存</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 禁用缓存</span><br><span class="line">spring.thymeleaf.cache=false</span><br></pre></td></tr></table></figure><h4 id="4）、页面修改完成以后ctrl-f9：重新编译；"><a href="#4）、页面修改完成以后ctrl-f9：重新编译；" class="headerlink" title="4）、页面修改完成以后ctrl+f9：重新编译；"></a>4）、页面修改完成以后ctrl+f9：重新编译；</h4>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot Web开发（四）</title>
      <link href="/2019/11/21/Spring-Boot-Web%E5%BC%80%E5%8F%91/"/>
      <url>/2019/11/21/Spring-Boot-Web%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="Web开发"><a href="#Web开发" class="headerlink" title="Web开发"></a>Web开发</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><h4 id="使用SpringBoot；"><a href="#使用SpringBoot；" class="headerlink" title="使用SpringBoot；"></a>使用SpringBoot；</h4><h4 id="1）、创建SpringBoot应用，选中我们需要的模块；"><a href="#1）、创建SpringBoot应用，选中我们需要的模块；" class="headerlink" title="1）、创建SpringBoot应用，选中我们需要的模块；"></a><strong>1）、创建SpringBoot应用，选中我们需要的模块；</strong></h4><h4 id="2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来"><a href="#2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来" class="headerlink" title="2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来"></a><strong>2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来</strong></h4><h4 id="3）、自己编写业务代码；"><a href="#3）、自己编写业务代码；" class="headerlink" title="3）、自己编写业务代码；"></a><strong>3）、自己编写业务代码；</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xxxxAutoConfiguration：帮我们给容器中自动配置组件；</span><br><span class="line">xxxxProperties:配置类来封装配置文件的内容；</span><br></pre></td></tr></table></figure><h2 id="2、SpringBoot对静态资源的映射规则；"><a href="#2、SpringBoot对静态资源的映射规则；" class="headerlink" title="2、SpringBoot对静态资源的映射规则；"></a>2、SpringBoot对静态资源的映射规则；</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.resources"</span>, ignoreUnknownFields = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceProperties</span> <span class="keyword">implements</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line">  <span class="comment">//可以设置和静态资源有关的参数，缓存时间等</span></span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">WebMvcAuotConfiguration：</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Default resource handling disabled"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Integer cachePeriod = <span class="keyword">this</span>.resourceProperties.getCachePeriod();</span><br><span class="line"><span class="keyword">if</span> (!registry.hasMappingForPattern(<span class="string">"/webjars/**"</span>)) &#123;</span><br><span class="line">customizeResourceHandlerRegistration(</span><br><span class="line">registry.addResourceHandler(<span class="string">"/webjars/**"</span>)</span><br><span class="line">.addResourceLocations(</span><br><span class="line"><span class="string">"classpath:/META-INF/resources/webjars/"</span>)</span><br><span class="line">.setCachePeriod(cachePeriod));</span><br><span class="line">&#125;</span><br><span class="line">String staticPathPattern = <span class="keyword">this</span>.mvcProperties.getStaticPathPattern();</span><br><span class="line">         <span class="comment">//静态资源文件夹映射</span></span><br><span class="line"><span class="keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">customizeResourceHandlerRegistration(</span><br><span class="line">registry.addResourceHandler(staticPathPattern)</span><br><span class="line">.addResourceLocations(</span><br><span class="line"><span class="keyword">this</span>.resourceProperties.getStaticLocations())</span><br><span class="line">.setCachePeriod(cachePeriod));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//配置欢迎页映射</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WelcomePageHandlerMapping <span class="title">welcomePageHandlerMapping</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ResourceProperties resourceProperties)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> WelcomePageHandlerMapping(resourceProperties.getWelcomePage(),</span><br><span class="line"><span class="keyword">this</span>.mvcProperties.getStaticPathPattern());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//配置喜欢的图标</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"spring.mvc.favicon.enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FaviconConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ResourceProperties resourceProperties;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FaviconConfiguration</span><span class="params">(ResourceProperties resourceProperties)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.resourceProperties = resourceProperties;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleUrlHandlerMapping <span class="title">faviconHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SimpleUrlHandlerMapping mapping = <span class="keyword">new</span> SimpleUrlHandlerMapping();</span><br><span class="line">mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + <span class="number">1</span>);</span><br><span class="line">             <span class="comment">//所有  **/favicon.ico </span></span><br><span class="line">mapping.setUrlMap(Collections.singletonMap(<span class="string">"**/favicon.ico"</span>,</span><br><span class="line">faviconRequestHandler()));</span><br><span class="line"><span class="keyword">return</span> mapping;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResourceHttpRequestHandler <span class="title">faviconRequestHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ResourceHttpRequestHandler requestHandler = <span class="keyword">new</span> ResourceHttpRequestHandler();</span><br><span class="line">requestHandler</span><br><span class="line">.setLocations(<span class="keyword">this</span>.resourceProperties.getFaviconLocations());</span><br><span class="line"><span class="keyword">return</span> requestHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>1）、所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；</p><ul><li>webjars：以jar包的方式引入静态资源；</li><li><a href="http://www.webjars.org/" target="_blank" rel="noopener">http://www.webjars.org/</a></li><li>localhost:8080/webjars/jquery/3.3.1/jquery.js</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入jquery-webjar--&gt;</span>在访问的时候只需要写webjars下面资源的名称即可</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jquery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>2）、”/**” 访问当前项目的任何资源，都去（静态资源的文件夹）找映射</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;classpath:/META-INF/resources/&quot;, </span><br><span class="line">&quot;classpath:/resources/&quot;,</span><br><span class="line">&quot;classpath:/static/&quot;, </span><br><span class="line">&quot;classpath:/public/&quot; </span><br><span class="line">&quot;/&quot;：当前项目的根路径</span><br></pre></td></tr></table></figure><ul><li><p>localhost:8080/abc ===  去静态资源文件夹里面找abc</p></li><li><p>3）、欢迎页； 静态资源文件夹下的所有index.html页面；被”/**”映射；</p><ul><li>localhost:8080/   找index页面</li></ul></li><li><p>4）、所有的 **/favicon.ico  都是在静态资源文件下找；</p></li></ul><h2 id="3、模板引擎"><a href="#3、模板引擎" class="headerlink" title="3、模板引擎"></a>3、模板引擎</h2><ul><li><p>JSP、Velocity、Freemarker、Thymeleaf</p></li><li><p>SpringBoot推荐的Thymeleaf；</p></li><li><p>语法更简单，功能更强大；</p></li></ul><h3 id="1、引入thymeleaf；"><a href="#1、引入thymeleaf；" class="headerlink" title="1、引入thymeleaf；"></a>1、引入thymeleaf；</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          2.1.6</span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--切换thymeleaf版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">thymeleaf.version</span>&gt;</span>3.0.9.RELEASE<span class="tag">&lt;/<span class="name">thymeleaf.version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 布局功能的支持程序  thymeleaf3主程序  layout2以上版本 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- thymeleaf2   layout1--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">thymeleaf-layout-dialect.version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">thymeleaf-layout-dialect.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot配置(三)</title>
      <link href="/2019/11/21/Spring-Boot%E9%85%8D%E7%BD%AE-%E4%B8%89/"/>
      <url>/2019/11/21/Spring-Boot%E9%85%8D%E7%BD%AE-%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、配置文件"><a href="#一、配置文件" class="headerlink" title="一、配置文件"></a>一、配置文件</h2><ul><li><p>Spring Boot使用一个全局得配置文件。作用：修改SpringBoot得Zion给配置默认值</p><ul><li>application.properties</li><li>application.yml </li></ul></li><li><p>配置文件放在src/main/resources目录或者类路径/config下</p><ul><li>springboot启动会扫描一下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件<br>-file:/config/<br>-file:/<br>-classpath:/config/<br>-classpath:/</li><li>优先级由高到低，高优先级的配置会覆盖低优先级的配置；</li><li>Springboot会从这四个位置全部加载主配置文件；<strong>互补配置</strong></li><li>还可以通过spring.config.location 来改变默认的配置文件位置</li></ul></li><li><p>.yml是YAML(YAML Ain’t Markup Language)语言得文件，以<strong>数据</strong>为中心，比json、xml等更适合做配置文件</p><ul><li><a href="http://www.yaml.org/" target="_blank" rel="noopener">http://www.yaml.org/</a> 参考语法规范</li><li>YAML 配置例子</li></ul></li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span><span class="number">8080</span></span><br></pre></td></tr></table></figure><ul><li>全局配置文件得可以对一些默认配置值进行修改</li></ul><a id="more"></a><h2 id="二、YAML-语法："><a href="#二、YAML-语法：" class="headerlink" title="二、YAML 语法："></a>二、YAML 语法：</h2><h3 id="1、基本语法"><a href="#1、基本语法" class="headerlink" title="1、基本语法"></a>1、基本语法</h3><ul><li>k:(空格)v:表示一堆键值对(空格必须有)：</li><li>以空格得缩进来控制层级关系；只要是左对齐得一列数据，都是同一个层级的</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">    port:</span><span class="number">8081</span></span><br><span class="line"><span class="attr">    path:</span><span class="string">/hello</span></span><br></pre></td></tr></table></figure><ul><li>属性和值也是大小写敏感</li></ul><h3 id="2、值得写法"><a href="#2、值得写法" class="headerlink" title="2、值得写法"></a>2、值得写法</h3><h4 id="字面量：普通得值（数字，字符串，布尔）"><a href="#字面量：普通得值（数字，字符串，布尔）" class="headerlink" title="字面量：普通得值（数字，字符串，布尔）"></a>字面量：普通得值（数字，字符串，布尔）</h4><ul><li><strong>k:  v:</strong>字面直接来写;<ul><li>字符串默认不用加上单引号或者双引号;</li><li>“”:双引号;不会转义字符串里面得特殊字符;特殊字符会作为本身想表示得意思<ul><li>name:”zhangsan \n lisi”:输出;zhangsan 换行 lisi</li></ul></li><li>‘ ‘:单引号;会转义特殊字符，特殊字符最终只会是一个普通得字符串数据<ul><li>name:”zhangsan \n lisi”:输出;zhangsan \n lisi </li></ul></li></ul></li></ul><h4 id="对象、Map-属性和值-（键值对）："><a href="#对象、Map-属性和值-（键值对）：" class="headerlink" title="对象、Map(属性和值)（键值对）："></a>对象、Map(属性和值)（键值对）：</h4><ul><li><strong>k:  v:</strong>在下一行来写对象的值和属性的关系;注意缩进<ul><li>对象还是k:v的方式</li><li>v:(一定要加空格)</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">friends:</span></span><br><span class="line"><span class="attr">    lastName:</span> <span class="string">zhangsan</span> </span><br><span class="line"><span class="attr">    age:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>行内写法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">friends:</span><span class="string">(lastName:zhangsan,age:18)</span></span><br></pre></td></tr></table></figure><h4 id="数组-List、Set"><a href="#数组-List、Set" class="headerlink" title="数组(List、Set):"></a>数组(List、Set):</h4><p>用 - 值表示数组中的一个元素</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pets:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">cat</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">dog</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">pig</span></span><br></pre></td></tr></table></figure><p>行内写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pets:[cat,dog,pig]</span><br></pre></td></tr></table></figure><ul><li>如果使用配置文件赋值需要@ConfigurationProperties(prefix=”对象”)</li><li>同时pom中导入配置文件处理器</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>占位符${引用其他}</li></ul><h4 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h4><h5 id="1、多Profile文件"><a href="#1、多Profile文件" class="headerlink" title="1、多Profile文件"></a>1、多Profile文件</h5><ul><li>我们在主配置文件编写的时候，文件名可以是application-{profile}.properties.yml<ul><li>默认使用application.properties.yml</li></ul></li></ul><h5 id="2、yml支持多文档块方式"><a href="#2、yml支持多文档块方式" class="headerlink" title="2、yml支持多文档块方式"></a>2、yml支持多文档块方式</h5><ul><li>利用 —-分割块</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">    port:</span><span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">    profiles:</span></span><br><span class="line"><span class="attr">        active:</span><span class="string">prod</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">    port:</span><span class="number">8082</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">    profiles:</span><span class="string">dev</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">    port:</span><span class="number">8084</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">    profiles:</span><span class="string">prod</span></span><br></pre></td></tr></table></figure><ul><li>结果：激活8084</li></ul><h5 id="3、激活指定profile"><a href="#3、激活指定profile" class="headerlink" title="3、激活指定profile"></a>3、激活指定profile</h5><ul><li>在配置（application.properties.yml）文件中指定 Spring.profiles.active=XXX</li><li>命令行：<ul><li>运行加参数—spring.profiles.active=XXX</li></ul></li><li>虚拟机参数；<ul><li>-Dspring.profiles.active=dev</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> java web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Holle World探究（二）</title>
      <link href="/2019/11/17/Holle-World%E6%8E%A2%E7%A9%B6%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2019/11/17/Holle-World%E6%8E%A2%E7%A9%B6%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="1、POM文件"><a href="#1、POM文件" class="headerlink" title="1、POM文件"></a>1、POM文件</h2><h3 id="1、父项目"><a href="#1、父项目" class="headerlink" title="1、父项目"></a>1、父项目</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">他的父项目</span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../../spring-boot-dependencies<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">他来真正管理Spring Boot 应用里面的所有依赖版本</span><br></pre></td></tr></table></figure><p>Spring Boot的版本仲裁中心：<br>以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要生面版本号）</p><h3 id="2、导入的依赖"><a href="#2、导入的依赖" class="headerlink" title="2、导入的依赖"></a>2、导入的依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>spring-boot-starter-web:<br>spring-boot-starter:spring-boot场景启动器;帮我们导入了web模块正常运行所依赖的组件;</li></ul><p>Spring Boot将所有功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器。</p><h2 id="2、主程序类，主入口类"><a href="#2、主程序类，主入口类" class="headerlink" title="2、主程序类，主入口类"></a>2、主程序类，主入口类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@<strong>SpringBootApplication:</strong> Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123; </span><br><span class="line">    <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">    <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br></pre></td></tr></table></figure><p>@<strong>SpringBootConfiguration:</strong> SpringBoot的配置类；<br>        标注在某个类上，表示这是一个Spring Boot的配置类；<br>        <strong>@Configuration:</strong>配置类上来标注这个注解；<br>         配置类——配置文件;配置类也是容器中的一个组件;@Component</p><p>@<strong>EnableAutoConfiguration</strong>：开启自动配置功能；<br>        以前我们需要配置的东西，Spring Boot帮我们自动配置;@<strong>EnableAutoConfiguration</strong>告诉SpringBoot开启自动配置功能;这样自动配置才能生效;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br></pre></td></tr></table></figure></p><p>@<strong>AutoConfigurationPackage</strong> :自动配置包<br>       @Import(AutoConfigurationImportSelector.class):<br>       Spring的底层注解@import,给容器中导入一个组件;导入的组件由(AutoConfigurationImportSelector.class)<br>       将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器中;</p><p>​       @Import(EnableAutoConfigurationImportSelector.class);给容器中导入组件;<br>​       EnableAutoConfigurationImportSelector:导入哪些组件的选择器<br>​       将所有需要导入的组件以全类名的方式返回;这些组件就会被添加到容器中<br>​       会给容器中导入非常多的自动配置类（xxxAutoConfiguration）;就是给容器中导入这个场景需要的所有组件，并配置好这些组件;<br>​       有了自动配置类，免去了我们手动编写配置主入功能组件等的工作;<br>​           </p>]]></content>
      
      
      
        <tags>
            
            <tag> java web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot入门（一）</title>
      <link href="/2019/10/06/%E5%88%9D%E5%AD%A6springboot/"/>
      <url>/2019/10/06/%E5%88%9D%E5%AD%A6springboot/</url>
      
        <content type="html"><![CDATA[<h2 id="1、Spring-Boot-简介"><a href="#1、Spring-Boot-简介" class="headerlink" title="1、Spring Boot 简介"></a>1、Spring Boot 简介</h2><ul><li>简化spring应用开发得一个框架；</li><li>整个Spring技术栈得一个大整合；</li><li>J2EE开发的一站式解决方案；</li></ul><h2 id="2、微服务"><a href="#2、微服务" class="headerlink" title="2、微服务"></a>2、微服务</h2><p>2014、Martin fowler<br>微服务：构架风格<br>一个应用应该是一组小型服务；可以通过HTTP的方式进行互通；</p><p>单体应用：ALL IN ONE；</p><ul><li>Simple to：develop,test,deploy,scale<br>每一个功能元素最终都是一个可独立替换和独立升级的软件单元<br>环境约束：</li><li>jdk1.8 :Spring Boot 1.7以上；</li><li>maven3.x :maven3.3以上；</li><li>intellIjIDEA2017 ：STS</li><li>Spring Boot RELEASE:</li></ul><h2 id="3、统一环境："><a href="#3、统一环境：" class="headerlink" title="3、统一环境："></a>3、统一环境：</h2><h3 id="1-maven设置"><a href="#1-maven设置" class="headerlink" title="1.maven设置"></a>1.maven设置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\ideaall\libmaven<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span>//大概50行</span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span>//大概150行</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.comilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.comilerVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profile</span>&gt;</span>//大概200行</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-IDEA设置"><a href="#2-IDEA设置" class="headerlink" title="2.IDEA设置"></a>2.IDEA设置</h3><ul><li>setting中maven设置setting.xml和仓库位置</li></ul><h2 id="4-Spring-Boot-Hello-World"><a href="#4-Spring-Boot-Hello-World" class="headerlink" title="4.Spring Boot Hello World"></a>4.Spring Boot Hello World</h2><h3 id="1-（首选）创建一个maven工程（jar）（md-IDEA的Spring-Initializr要搞我，以后再也不用了）-开启auto-import-maven"><a href="#1-（首选）创建一个maven工程（jar）（md-IDEA的Spring-Initializr要搞我，以后再也不用了）-开启auto-import-maven" class="headerlink" title="1.（首选）创建一个maven工程（jar）（md IDEA的Spring Initializr要搞我，以后再也不用了）(开启auto import maven)"></a>1.（首选）创建一个maven工程（jar）（<del>md IDEA的Spring Initializr要搞我，以后再也不用了</del>）(开启auto import maven)</h3><h3 id="2-导入依赖spring-boot相关的依赖"><a href="#2-导入依赖spring-boot相关的依赖" class="headerlink" title="2.导入依赖spring boot相关的依赖"></a>2.导入依赖spring boot相关的依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gs-rest-service<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.jayway.jsonpath<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>json-path<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-编写一个主程序-在【cn-XXX-XXX】包下新建一个【HelloWorldApplication】"><a href="#3-编写一个主程序-在【cn-XXX-XXX】包下新建一个【HelloWorldApplication】" class="headerlink" title="3.编写一个主程序,在【cn.XXX.XXX】包下新建一个【HelloWorldApplication】"></a>3.编写一个主程序,在【cn.XXX.XXX】包下新建一个【HelloWorldApplication】</h3><p>项目结构：</p><ul><li>HelloWorldApplication： 一个带有 main() 方法的类，用于启动应用程序</li><li>HelloWorldApplicationTests：一个空的 Junit 测试了，它加载了一个使用 Spring Boot 字典配置功能的 Spring 应用程序上下文</li><li>application.properties：一个空的 properties 文件，可以根据需要添加配置属性</li><li>pom.xml： Maven 构建说明文件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.XXX.XXX;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">*<span class="doctag">@SpringBootApplication</span> 来标注一个主程序类，说明这是一个SpringBoot应用</span></span><br><span class="line"><span class="comment">***/</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldApplication</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Spring应用启动起来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HelloWorldApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-在【cn-XXX-XXX】包下新建一个【HelloController】-编写相关Controller，Service"><a href="#4-在【cn-XXX-XXX】包下新建一个【HelloController】-编写相关Controller，Service" class="headerlink" title="4.在【cn.XXX.XXX】包下新建一个【HelloController】(编写相关Controller，Service)"></a>4.在【cn.XXX.XXX】包下新建一个【HelloController】(编写相关Controller，Service)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.XXX.XXX;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello Spring Boot!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@RestController 注解： 该注解是 @Controller 和 @ResponseBody 注解的合体版</li></ul><h3 id="4-利用-IDEA-启动-Spring-Boot"><a href="#4-利用-IDEA-启动-Spring-Boot" class="headerlink" title="4.利用 IDEA 启动 Spring Boot"></a>4.利用 IDEA 启动 Spring Boot</h3><p>我们回到 SpringbootApplication 这个类中，然后右键点击运行<br>可以看到我们的 Tomcat 运行在 8080 端口，我们来访问 “<code>127.0.0.1:8080/hello</code>” 地址试一下</p><h3 id="5-简化部署"><a href="#5-简化部署" class="headerlink" title="5.简化部署"></a>5.简化部署</h3><p>pom.xml增加插件<br>右侧maven的package可以打成jar包（targe目录下）直接运行（Java -jar）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java web </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
