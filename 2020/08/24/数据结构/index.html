<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">






  
  
  <link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3">




<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="tool,">










<meta name="description" content="数据结构复习算法复杂度">
<meta name="keywords" content="tool">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构">
<meta property="og:url" content="https://banniford.github.io/2020/08/24/数据结构/index.html">
<meta property="og:site_name" content="潘的日记本">
<meta property="og:description" content="数据结构复习算法复杂度">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://banniford.github.io/2020/08/24/数据结构/1.jpg">
<meta property="og:image" content="https://banniford.github.io/2020/08/24/数据结构/2.jpg">
<meta property="og:image" content="https://banniford.github.io/2020/08/24/数据结构/3.jpg">
<meta property="og:image" content="https://banniford.github.io/2020/08/24/数据结构/4.jpg">
<meta property="og:image" content="https://banniford.github.io/2020/08/24/数据结构/5.jpg">
<meta property="og:image" content="https://banniford.github.io/2020/08/24/数据结构/6.jpg">
<meta property="og:image" content="https://banniford.github.io/2020/08/24/数据结构/7.jpg">
<meta property="og:image" content="https://banniford.github.io/2020/08/24/数据结构/8.jpg">
<meta property="og:image" content="https://banniford.github.io/2020/08/24/数据结构/9.jpg">
<meta property="og:image" content="https://banniford.github.io/2020/08/24/数据结构/12.jpg">
<meta property="og:image" content="https://banniford.github.io/2020/08/24/数据结构/13.jpg">
<meta property="og:image" content="https://banniford.github.io/2020/08/24/数据结构/14.jpg">
<meta property="og:image" content="https://banniford.github.io/2020/08/24/数据结构/32.jpg">
<meta property="og:image" content="https://banniford.github.io/2020/08/24/数据结构/15.jpg">
<meta property="og:image" content="https://banniford.github.io/2020/08/24/数据结构/16.jpg">
<meta property="og:image" content="https://banniford.github.io/2020/08/24/数据结构/17.jpg">
<meta property="og:image" content="https://banniford.github.io/2020/08/24/数据结构/18.jpg">
<meta property="og:image" content="https://banniford.github.io/2020/08/24/数据结构/19.jpg">
<meta property="og:image" content="https://banniford.github.io/2020/08/24/数据结构/20.jpg">
<meta property="og:image" content="https://banniford.github.io/2020/08/24/数据结构/21.jpg">
<meta property="og:image" content="https://banniford.github.io/2020/08/24/数据结构/22.jpg">
<meta property="og:image" content="https://banniford.github.io/2020/08/24/数据结构/23.jpg">
<meta property="og:image" content="https://banniford.github.io/2020/08/24/数据结构/24.jpg">
<meta property="og:image" content="https://banniford.github.io/2020/08/24/数据结构/25.jpg">
<meta property="og:image" content="https://banniford.github.io/2020/08/24/数据结构/26.jpg">
<meta property="og:image" content="https://banniford.github.io/2020/08/24/数据结构/27.jpg">
<meta property="og:image" content="https://banniford.github.io/2020/08/24/数据结构/28.jpg">
<meta property="og:image" content="https://banniford.github.io/2020/08/24/数据结构/29.jpg">
<meta property="og:image" content="https://banniford.github.io/2020/08/24/数据结构/31.jpg">
<meta property="og:image" content="https://banniford.github.io/2020/08/24/数据结构/30.jpg">
<meta property="og:updated_time" content="2020-12-05T08:10:56.597Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据结构">
<meta name="twitter:description" content="数据结构复习算法复杂度">
<meta name="twitter:image" content="https://banniford.github.io/2020/08/24/数据结构/1.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://banniford.github.io/2020/08/24/数据结构/">





  <title>数据结构 | 潘的日记本</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">潘的日记本</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://banniford.github.io/2020/08/24/数据结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="paniford">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潘的日记本">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">数据结构</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-24T10:33:21+08:00">
                2020-08-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        <h1 id="数据结构复习"><a href="#数据结构复习" class="headerlink" title="数据结构复习"></a>数据结构复习</h1><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><p><img src="/2020/08/24/数据结构/1.jpg" alt></p>
<p><img src="/2020/08/24/数据结构/2.jpg" alt></p>
<a id="more"></a>
<ul>
<li>若两端算法分别由复杂度$T_1(n)=O(f_1(n))$和$T_2(n)=O(f_2(n))$则<ul>
<li>$T_1(n)+T_2(n)=max(O(f_1(n)),O(f_2(n))$</li>
<li>$T_1(n)<em>T_2(n)=O(f_1(n)</em>f_2(n))$</li>
</ul>
</li>
<li>若$T(n)$是关于 n 的 k 阶多项式，那么$T(n)=O(n^k)$</li>
<li>一个<strong>for</strong>循环的时间复杂度等于循环次数乘以循环体代码的复杂度</li>
</ul>
<p>例题1 给定N个整数序列{A1，A2，……，An}；求函数$f(i,j)=max(\sum_{i=0}^jA_k)$的最大值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1 时间复杂度O(n^2)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSubseqSum1</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ThisSum,MaxSum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;N;k++)&#123;</span><br><span class="line">            ThisSum+=A[j];</span><br><span class="line">            <span class="keyword">if</span>(ThisSum&gt;MaxSum)</span><br><span class="line">                MaxSum=ThisSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MaxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法2 分而治之(递归) 时间复杂度O(nlogn) 见归并排序</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法3 在线处理（动态规划） 时间复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSubseqSum1</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ThisSum=<span class="number">0</span>,MaxSum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        ThisSum+=A[i];<span class="comment">//向右累加</span></span><br><span class="line">        <span class="keyword">if</span>(ThisSum&gt;MaxSum)</span><br><span class="line">            MaxSum=ThisSum;<span class="comment">//发现更大和则更新当前结果</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ThisSum&lt;<span class="number">0</span>)<span class="comment">//如果发现当前子列和为负数</span></span><br><span class="line">            ThisSum=<span class="number">0</span>;<span class="comment">//则不可能使后面的部分和增大，抛弃之</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MaxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="考-线性表（查找，增加，删除）"><a href="#考-线性表（查找，增加，删除）" class="headerlink" title="(考)线性表（查找，增加，删除）"></a>(考)线性表（查找，增加，删除）</h3><p>定义：（对象集）一个线性表是<code>n</code>个数据元素的有限序列。由同类型元素构成有序序列的线性结构。</p>
<ul>
<li>线性表<strong>顺序存储,</strong>抽象表示（考）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElementType Data[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> Last;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> <span class="title">L</span>;</span></span><br><span class="line">List Ptrl;</span><br><span class="line"><span class="comment">//访问下标i的元素：L.Data[i]或Ptrl-&gt;Data[i]</span></span><br><span class="line"><span class="comment">//线性表的长度：L.Last+1或Ptrl-&gt;last+1</span></span><br><span class="line"><span class="comment">//初始化（建立空表）</span></span><br><span class="line"><span class="function">List <span class="title">MakeEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List PtrL;</span><br><span class="line">    ptrL=(List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">    PtrL-&gt;Last=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> PtrL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(ElementType X,List Ptrl)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=PtrL-&gt;Last &amp;&amp; PtrL-&gt;Data[i]!=X) i++;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;PtrL-&gt;Last)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> i;</span><br><span class="line">&#125;<span class="comment">//时间复杂度 O(n)</span></span><br><span class="line"><span class="comment">//插入从后往前先挪数，再插入到i-1下标，第i个元素下标0开始</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(ElementType X,<span class="keyword">int</span> i,List PtrL)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">if</span>(Ptrl-&gt;Last==MAXSIZE<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"表满了，插不进去"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;PtrL-&gt;Last+<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"位置不合法"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j=PtrL-&gt;Last;j&gt;=i<span class="number">-1</span>;j--)</span><br><span class="line">        Ptrl-&gt;Data[j+<span class="number">1</span>]=PtrL-&gt;Data[j];</span><br><span class="line">    PtrL-&gt;Data[i<span class="number">-1</span>]=X;</span><br><span class="line">    PtrL-&gt;Last++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="comment">//O(n)</span></span><br><span class="line"><span class="comment">//删除,从i开始向前挪，覆盖前一个</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> i,List PtrL)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">   <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;PtrL-&gt;Last+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"位置不合法"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j=i;j&lt;=PtrL-&gt;Last;j++)</span><br><span class="line">         Ptrl-&gt;Data[j<span class="number">-1</span>]=PtrL-&gt;Data[j];</span><br><span class="line">    PtrL-&gt;Last--;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="comment">//O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//手写代码</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> ElementType int</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> LIST_INIT_SIZE 10 <span class="comment">//初始分配长度</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> LISTINCREMENT  5  <span class="comment">//存储空间的分配增量 </span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//动态分配 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElementType *data;</span><br><span class="line">	<span class="keyword">int</span> length;<span class="comment">//当前长度 </span></span><br><span class="line">	<span class="keyword">int</span> listsize;<span class="comment">//当前分配的储存容量(以sizeof(ELementType)为单位) </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造一个空的顺序表，返回指针 </span></span><br><span class="line"><span class="function">struct LNode* <span class="title">InitList_Sq</span><span class="params">()</span></span>&#123;<span class="comment">//初始化一个顺序表 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">q</span>;</span></span><br><span class="line">	q=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">	q-&gt;data=(ElementType*)<span class="built_in">malloc</span>(LIST_INIT_SIZE*<span class="keyword">sizeof</span>(ElementType));</span><br><span class="line">	<span class="keyword">if</span>(!q-&gt;data)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"内存空间不足\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	q-&gt;length=<span class="number">0</span>;</span><br><span class="line">	q-&gt;listsize=LIST_INIT_SIZE;</span><br><span class="line">	<span class="keyword">return</span> q;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//按值查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(ElementType X,struct LNode *p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;p-&gt;length &amp;&amp; p-&gt;data[i]!=X) &#123;i++;&#125;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=p-&gt;length)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> i+<span class="number">1</span>;<span class="comment">//返回下标要+1才是位置 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除 按位置删除 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> i,struct LNode *p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;p-&gt;length)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"位置不合法\n"</span>);</span><br><span class="line">		<span class="comment">//return ; </span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(j=i;j&lt;=p-&gt;length;j++)<span class="comment">//=将a[10]不存在转换到a[9] </span></span><br><span class="line">	p-&gt;data[j<span class="number">-1</span>]=p-&gt;data[j];</span><br><span class="line">	p-&gt;	length--;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入 从后往前先挪数，再插入到i-1下标，第i个元素下标0开始 </span></span><br><span class="line"><span class="function">struct LNode* <span class="title">Insert</span><span class="params">(ElementType X,<span class="keyword">int</span> i,struct LNode *p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;length==p-&gt;listsize)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"表满了，插不进去\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//跳出函数 </span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;=p-&gt;length+<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"位置不合法\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j=p-&gt;length;j&gt;=i<span class="number">-1</span>;j--)</span><br><span class="line">        p-&gt;data[j+<span class="number">1</span>]=p-&gt;data[j];</span><br><span class="line">    p-&gt;data[i<span class="number">-1</span>]=X;</span><br><span class="line">    p-&gt;length++;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">struct LNode* <span class="title">InitList_Sq</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(ElementType X,struct LNode *p)</span></span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">q</span>;</span></span><br><span class="line">	q=InitList_Sq();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">		q-&gt;data[i]=i;</span><br><span class="line">		q-&gt;length+=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查找 </span></span><br><span class="line">	<span class="keyword">int</span> g=Find(<span class="number">13</span>,q);</span><br><span class="line">	<span class="keyword">if</span>(g==<span class="number">-1</span>)<span class="built_in">printf</span>(<span class="string">"不在\n"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"在%d个位置\n"</span>,g);  </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;q-&gt;length;j++)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,q-&gt;data[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n%d\n"</span>,q-&gt;length);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//删除 </span></span><br><span class="line">	Delete(<span class="number">6</span>,q);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;q-&gt;length;j++)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,q-&gt;data[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n%d\n"</span>,q-&gt;length);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//插入 </span></span><br><span class="line">	q=Insert(<span class="number">10</span>,<span class="number">11</span>,q);</span><br><span class="line">	<span class="keyword">if</span>(q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;q-&gt;length;j++)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,q-&gt;data[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n%d\n"</span>,q-&gt;length);&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>链式存储，抽象表示</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    List Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> <span class="title">L</span>;</span></span><br><span class="line">List PtrL;</span><br><span class="line"><span class="comment">//求表长</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(List PtrL)</span></span>&#123;</span><br><span class="line">    List p=PtrL;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        p=p-&gt;Next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;<span class="comment">//O(n)</span></span><br><span class="line"><span class="comment">//按序号查找</span></span><br><span class="line"><span class="function">List <span class="title">FindKth</span><span class="params">(<span class="keyword">int</span> K,List PtrL)</span></span>&#123;</span><br><span class="line">    List p=PtrL;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;i&lt;K)&#123;</span><br><span class="line">        p=p-&gt;Next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i==K)<span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;<span class="comment">//O(n)</span></span><br><span class="line"><span class="comment">//按值查找</span></span><br><span class="line"><span class="function">List <span class="title">Find</span><span class="params">(ElementType X,List Ptrl)</span></span>&#123;</span><br><span class="line">    List p=Ptrl;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;Data!=X)</span><br><span class="line">        p=p-&gt;Next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;<span class="comment">//O(n)</span></span><br><span class="line"><span class="comment">//插入结点，找i-1</span></span><br><span class="line"><span class="function">List <span class="title">Insert</span><span class="params">(ElementType X,<span class="keyword">int</span> i,List PtrL)</span></span>&#123;</span><br><span class="line">    List p,s;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;<span class="comment">//新节点插入表头，将头指针改变，替换原来的头指针</span></span><br><span class="line">        s=(List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">        s-&gt;Data=X;</span><br><span class="line">        s-&gt;Next=PtrL;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    p = FindKth(i<span class="number">-1</span>,PtrL);</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"参数错误"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        s=(List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">        s-&gt;Data=X;</span><br><span class="line">        s-&gt;Next=p-&gt;Next;</span><br><span class="line">        p-&gt;Next=s;</span><br><span class="line">        <span class="keyword">return</span> PtrL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//O(n)</span></span><br><span class="line"><span class="comment">//删除结点，找i-1</span></span><br><span class="line"><span class="function">List <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> i,List Ptrl)</span></span>&#123;</span><br><span class="line">    List p,s;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">        s=PtrL;</span><br><span class="line">        <span class="keyword">if</span>(PtrL!=<span class="literal">NULL</span>)PtrL=PtrL-&gt;Next;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(s);</span><br><span class="line">        <span class="keyword">return</span> PtrL;</span><br><span class="line">    &#125;</span><br><span class="line">    p=FindKth(i<span class="number">-1</span>,PtrL);</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"结点不存在"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;Next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"结点不存在"</span>);<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        s=p-&gt;Next;</span><br><span class="line">        p-&gt;Next=s-&gt;Next;</span><br><span class="line">        <span class="built_in">free</span>(s);</span><br><span class="line">        <span class="keyword">return</span> PtrL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//O(n)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链表实现</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Data;</span><br><span class="line">    List Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">List <span class="title">FindKth</span><span class="params">(<span class="keyword">int</span> K,List PtrL)</span></span>&#123;</span><br><span class="line">    List p=PtrL;</span><br><span class="line">    	<span class="keyword">int</span> i=<span class="number">1</span>;<span class="comment">//插入到第二个结点 </span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; i&lt;K)&#123;</span><br><span class="line">        p=p-&gt;Next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    printf("第一%d\n 第二%d",i,K); </span></span><br><span class="line">    <span class="keyword">if</span>(i==K)<span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;<span class="comment">//O(n)</span></span><br><span class="line"><span class="function">List <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> X,<span class="keyword">int</span> i,List PtrL)</span></span>&#123;</span><br><span class="line">    List p,s;<span class="comment">//本身List就是指针类型，属于加*</span></span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;<span class="comment">//新节点插入表头，将头指针改变，替换原来的头指针</span></span><br><span class="line">        s=(List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">        s-&gt;Data=X;</span><br><span class="line">        s-&gt;Next=PtrL;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    p = FindKth(i<span class="number">-1</span>,PtrL);</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"参数错误"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        s=(List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">        s-&gt;Data=X;</span><br><span class="line">        s-&gt;Next=p-&gt;Next;</span><br><span class="line">        p-&gt;Next=s;</span><br><span class="line">        <span class="keyword">return</span> PtrL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">List <span class="title">FindKth</span><span class="params">(<span class="keyword">int</span> K,List PtrL)</span></span>;</span><br><span class="line"><span class="function">List <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> X,<span class="keyword">int</span> i,List PtrL)</span></span>;</span><br><span class="line">LNode *head,*p,*q,*w;</span><br><span class="line">w=(List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">w-&gt;Data=<span class="number">3</span>;</span><br><span class="line">w-&gt;Next=<span class="literal">NULL</span>;</span><br><span class="line">q=(List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">q-&gt;Data=<span class="number">2</span>;</span><br><span class="line">q-&gt;Next=w;</span><br><span class="line">p=(List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">p-&gt;Data=<span class="number">1</span>;</span><br><span class="line">p-&gt;Next=q;</span><br><span class="line"></span><br><span class="line">head=p;</span><br><span class="line"></span><br><span class="line">p=Insert(<span class="number">4</span>,<span class="number">3</span>,p); </span><br><span class="line"></span><br><span class="line">p=Insert(<span class="number">5</span>,<span class="number">3</span>,p);</span><br><span class="line">p=Insert(<span class="number">6</span>,<span class="number">3</span>,p);</span><br><span class="line">p=Insert(<span class="number">7</span>,<span class="number">3</span>,p);</span><br><span class="line">p=Insert(<span class="number">8</span>,<span class="number">3</span>,p);</span><br><span class="line"><span class="keyword">while</span>(head-&gt;Data!=<span class="literal">NULL</span>)&#123;<span class="comment">//不要漏掉结点</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,head-&gt;Data);</span><br><span class="line">	head=head-&gt;Next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="考-堆栈"><a href="#考-堆栈" class="headerlink" title="(考)堆栈"></a>(考)堆栈</h3><ul>
<li>插入数据：入栈(Push)</li>
<li>删除数据：出栈(Pop)</li>
<li>后入先出：Last In First Out(LIFO)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//！！！顺序存储实现，抽象</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MaxSize<span class="meta-string">&lt;个数&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span>&#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> Top;<span class="comment">//栈顶数组下标</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(Stack PtrS,ElementType item)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(PtrS-&gt;Top==MaxSize<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"堆栈满"</span>);<span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        PtrS-&gt;Data[++(P-&gt;Top)]=item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">(Stack PtrS)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(PtrS-&gt;Top==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"堆栈空"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>(PtrS-&gt;Data[(PrtS-&gt;Top)--]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElementType int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxsize 10</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span>&#123;</span></span><br><span class="line">	<span class="comment">//ElementType *data;//如果使用动态分配需要指针 </span></span><br><span class="line">	ElementType data[Maxsize];</span><br><span class="line">	<span class="keyword">int</span> top;<span class="comment">//数组栈顶下标 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct SNode* <span class="title">Init_Stack</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">p</span>=(<span class="title">SNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">SNode</span>));</span></span><br><span class="line">	<span class="comment">//p-&gt;data =(ElementType*)malloc(Maxsize*sizeof(ElementType));</span></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"内存不足"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	p-&gt;top=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进栈 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(ElementType k,struct SNode *p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;top==Maxsize<span class="number">-1</span>)&#123;<span class="comment">//如果使用动态分配，Maxsize要传入</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"栈满"</span>); 	</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	p-&gt;data[++(p-&gt;top)]=k;<span class="comment">//先自增在进栈	</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈 </span></span><br><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">(struct SNode *p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;top==<span class="number">-1</span>)&#123;<span class="comment">//0可能有数 </span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"堆栈空"</span>); </span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">//抛出异常 退出 </span></span><br><span class="line">	&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> p-&gt;data[(p-&gt;top)--];<span class="comment">//先弹出在自减 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">p</span>;</span></span><br><span class="line">	p=Init_Stack();</span><br><span class="line">	Push(<span class="number">1</span>,p);</span><br><span class="line">	Push(<span class="number">2</span>,p);</span><br><span class="line">	<span class="keyword">int</span> i=Pop(p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">	Push(<span class="number">3</span>,p); </span><br><span class="line">	Push(<span class="number">4</span>,p); </span><br><span class="line">	Push(<span class="number">5</span>,p); </span><br><span class="line">	i=Pop(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=p-&gt;top;i++)<span class="built_in">printf</span>(<span class="string">"栈内有：%d\n"</span>,p-&gt;data[i]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,p-&gt;top);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用一个数组实现两个堆栈，要求最大地利用数组空间，使数组只要有空间入栈操作就可以成功。(使这两个栈分别从数组的两头开始向中间生长，当两个栈的栈顶指针相遇时，表示两个栈都满了)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MaxSize<span class="meta-string">&lt;个数&gt;</span></span></span><br><span class="line"><span class="comment">//typedef struct Dstack *S;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DStack</span>&#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> Top1;<span class="comment">//栈顶数组下标</span></span><br><span class="line">    <span class="keyword">int</span> Top2;</span><br><span class="line">&#125;S;</span><br><span class="line">S.Top1=<span class="number">-1</span>;<span class="comment">//数组两边下标，越界所以需要先自增或先自减</span></span><br><span class="line">S.Top2=MaxSize;</span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(Stack Dstack *PtrS,ElementType item,<span class="keyword">int</span> Tag)</span></span>&#123;<span class="comment">//当Tag=1为第一个堆栈，2为第二个堆栈</span></span><br><span class="line">    <span class="keyword">if</span>(PtrS-&gt;Top2-PtrS-&gt;Top1==<span class="number">1</span>)&#123;<span class="comment">//相邻右边减左边</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"堆栈满"</span>);<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Tag==<span class="number">1</span>)</span><br><span class="line">        PtrS-&gt;Data[++(P-&gt;Top1)]=item;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        PtrS-&gt;Data[--(P-&gt;Top2)]=item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">(Stack Dstack *PtrS,<span class="keyword">int</span> Tag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Tag==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(PtrS-&gt;Top1==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"堆栈1空"</span>); <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> PtrS-&gt;Data[(PrtS-&gt;Top1)--];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(PtrS-&gt;Top2==MaxSize)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"堆栈2空"</span>);<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> PtrS-&gt;Data[(PrtS-&gt;Top2)++];       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>表达式求值(中缀转后缀)<ul>
<li>运算数：直接输出；</li>
<li>左括号：压入堆栈；</li>
<li>右括号：将栈顶的运算符弹出并输出，直到遇到左括号(出栈，不输出)；</li>
<li>运算符：<ul>
<li>若优先级<strong>大于</strong>栈顶运算符时，把它进行压栈；</li>
<li>若优先级<strong>小于等于</strong>栈顶运算符时，将栈顶运算符弹出并输出；再比较新的栈顶运算符，直到该运算符大于栈顶运算符优先级为止，然后将该运算符压栈；</li>
</ul>
</li>
<li>若各对象处理完毕，则把堆栈中留存的运算符<strong>一并输出</strong>。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul>
<li>插入数据：入队列(AddQ)</li>
<li>删除数据：出队列(DeleteQ)</li>
<li>先来先服务</li>
<li>先进先出：FIFO</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize<span class="meta-string">&lt;个数&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> rear;<span class="comment">//队头，插入</span></span><br><span class="line">    <span class="keyword">int</span> front;<span class="comment">//队尾，删除</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">Queue</span>;</span></span><br><span class="line"><span class="comment">//循环队列 数组内只放放n-1个元素防止误判 满/空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddQ</span><span class="params">(Queue PtrQ,ElementType item)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((PtrQ-&gt;rear+<span class="number">1</span>)%MaxSize==PtrQ-&gt;front)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列满"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PtrQ-&gt;rear=(PtrQ-&gt;rear+<span class="number">1</span>)%MaxSize;<span class="comment">//最后一位会变零</span></span><br><span class="line">    ptrQ-&gt;Data[PtrQ-&gt;rear]=item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出队列</span></span><br><span class="line"><span class="function">ElementType <span class="title">DeleteQ</span><span class="params">(Queue PtrQ)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(PtrQ-&gt;front==PtrQ-&gt;rear)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列空"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        PtrQ-&gt;front=(PtrQ-&gt;front+<span class="number">1</span>)%MaxSize;</span><br><span class="line">        <span class="keyword">return</span>  ptrQ-&gt;Data[PtrQ-&gt;front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElementType int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR -99</span></span><br><span class="line"><span class="comment">//构建结点信息 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">Next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span><span class="comment">//链队列结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">rear</span>;</span><span class="comment">//指向队尾</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">front</span>;</span><span class="comment">//指向队头</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ElementType <span class="title">DeleteQ</span><span class="params">(struct QNode *PtrQ)</span></span>&#123;</span><br><span class="line"><span class="comment">//    pNode FrontCell;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">FrontCell</span>;</span></span><br><span class="line">    ElementType FrontElem;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(PtrQ-&gt;front==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列空"</span>);<span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    FrontCell=PtrQ-&gt;front;</span><br><span class="line">    <span class="keyword">if</span>(PtrQ-&gt;front==PtrQ-&gt;rear)<span class="comment">//若队列只有一个元素</span></span><br><span class="line">        PtrQ-&gt;front=PtrQ-&gt;rear=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        PtrQ-&gt;front=PtrQ-&gt;front-&gt;Next;</span><br><span class="line">    FrontElem=FrontCell-&gt;Data;<span class="comment">//将删除的元素返回</span></span><br><span class="line">    <span class="built_in">free</span>(FrontCell);</span><br><span class="line">    <span class="keyword">return</span> FrontElem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddQ</span><span class="params">(struct QNode *q,ElementType i)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">qNode</span>;</span></span><br><span class="line">    qNode=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!qNode)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"内存空间不足\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    qNode-&gt;Data=i;</span><br><span class="line">    qNode-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;front==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        q-&gt;front = qNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;rear == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        q-&gt;rear = qNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//头尾不为null，则执行下列操作</span></span><br><span class="line">        q-&gt;rear-&gt;Next=qNode;<span class="comment">//连上上一个指针  </span></span><br><span class="line">        q-&gt;rear=qNode;<span class="comment">//队尾指针从新被定义</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmptyQ</span><span class="params">(struct QNode *q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (q-&gt;front == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrientQueue</span><span class="params">(struct QNode *q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsEmptyQ(q))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"空队列\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"打印队列所有元素：\n"</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">qnode</span> = <span class="title">q</span>-&gt;<span class="title">front</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(qnode != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,qnode-&gt;Data);</span><br><span class="line">        qnode= qnode-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">ElementType <span class="title">DeleteQ</span><span class="params">(struct QNode *PtrQ)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">AddQ</span><span class="params">(struct QNode *q,ElementType i)</span></span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">int</span> w;</span><br><span class="line">	p=(QNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct QNode));</span><br><span class="line">	p-&gt;front=p-&gt;rear=<span class="literal">NULL</span>;</span><br><span class="line">	AddQ(p,<span class="number">1</span>);</span><br><span class="line">	AddQ(p,<span class="number">2</span>);</span><br><span class="line">	AddQ(p,<span class="number">3</span>);</span><br><span class="line">	AddQ(p,<span class="number">4</span>);</span><br><span class="line">	AddQ(p,<span class="number">5</span>);</span><br><span class="line">	PrientQueue(p);</span><br><span class="line">	DeleteQ(p);</span><br><span class="line">	DeleteQ(p);</span><br><span class="line"></span><br><span class="line">	PrientQueue(p);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h3><p>顺序查找</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElementType Element[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> Length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SequentialSearch</span> <span class="params">(struct LNode *Tb1,ElementType K)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    Tb1-&gt;Element[<span class="number">0</span>]=K;</span><br><span class="line">    <span class="keyword">for</span>(i =Tb1-&gt;Length; Tb1-&gt;Element[i]!=K;i--);<span class="comment">//建立哨兵，返回数组下标没有返回0，哨兵坐标。</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;<span class="comment">//O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SequentialSearch</span><span class="params">(ElementType A[],ElementType K,<span class="keyword">int</span> N)</span></span>&#123;<span class="comment">//顺序查找 </span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(A[i]==K)<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a><strong>二分查找</strong></h4><ul>
<li>假设<code>n</code>个数据元素的关键字满足<strong>有序</strong>(比如：小到大)(k1&lt;k2&lt;····&lt;kn)并且是连续存放<strong>（数组）</strong>，那么可以进行二分查找。</li>
<li>二叉排序树-&gt;动态查找问题</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElementType Element[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> Length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(struct LNode *Tb1,ElementType K)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left,right,mid,NoFound=<span class="number">-1</span>;</span><br><span class="line">    left=<span class="number">1</span>;<span class="comment">//左边界</span></span><br><span class="line">    right=Tb1-&gt;Length;<span class="comment">//右边界</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        mid=(left+right)/<span class="number">2</span>;<span class="comment">//计算中间元素</span></span><br><span class="line">        <span class="keyword">if</span>(K&lt;Tb1-&gt;Element[mid]) right=mid<span class="number">-1</span>;<span class="comment">//调整右边界</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(K&gt;Tb1-&gt;Element[mid]) left=mid+<span class="number">1</span>;<span class="comment">//调整左边界</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid;<span class="comment">//查找成功，返回元素下标。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NotFound;<span class="comment">//查找失败，返回-1  </span></span><br><span class="line">&#125;<span class="comment">//O(logN)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(ElementType A[],ElementType K,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left,right,mid,Nofound=<span class="number">-1</span>;</span><br><span class="line">	left=<span class="number">0</span>;</span><br><span class="line">	right=N<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">		mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(K&lt;A[mid])right=mid<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (K&gt;A[mid])left=mid+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Nofound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/08/24/数据结构/3.jpg" alt></p>
<hr>
<h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>定义：n(n&gt;=0)个结点的有限集合，n=0时，称为空树，这是一种情况。在任意一科<strong>非空树</strong>中应满足：</p>
<ul>
<li>有且仅有一个特定的称为<strong>根</strong>的结点。</li>
<li>其余结点可分为m(m&gt;0)个<strong>互不相交</strong>的有限集{T1,T2,….,Tm},其中每个集合本身又是一棵树，称为原来树的“子树”。</li>
</ul>
<p>树与非树？</p>
<ul>
<li>子树是不相交的；</li>
<li>出了根结点外，每个结点有且仅有一个父结点；</li>
<li>一棵N个结点的树有<strong>N-1</strong>条边。</li>
</ul>
<p>一些基本定义：</p>
<ul>
<li><strong>结点的度：</strong>结点的<strong>子树个数</strong>；</li>
<li><strong>树的度：</strong>树的所有结点中<strong>最大</strong>的<strong>度数</strong>；</li>
<li><strong>叶结点：</strong> <strong>度为0</strong>的结点；</li>
<li><strong>父结点：</strong>有子树的结点是其子树的根结点的父结点；</li>
<li><strong>子结点：</strong>子结点也称孩子结点；</li>
<li><strong>兄弟结点：</strong>具有同一父结点的各结点彼此是兄弟结点。</li>
<li><strong>路径和路径长度：</strong>从n1-&gt;nk的路径为一个<strong>结点序列</strong>，路径所包含<strong>边的个数</strong>为路径长度。</li>
<li><strong>祖先结点：</strong>沿<strong>树根到某一结点路径上所有结点</strong>都是这个结点的祖先结点。</li>
<li><strong>子孙结点：</strong>某结点的<strong>子树中所有结点</strong>都是这个结点的子孙结点。</li>
<li><strong>结点的层次：</strong>根节点为1层，<strong>向下累加</strong>。</li>
<li><strong>数的深度：</strong>树中所有结点<strong>最大层次</strong>是这棵树的深度。</li>
</ul>
<p>基本性质：</p>
<ul>
<li>树中的结点数等于所有结点的度+1；</li>
<li>度为<strong>m</strong>的树中第<strong>i</strong>层上至多有$m^{i-1}$个结点(i&gt;=1);</li>
<li>高度为h的m叉树至多有($m^h$-1)/(m-1)个结点。</li>
<li>具有n个结点的m叉树的最小高度为┌$log_m(n(m-1)+1)$┐</li>
</ul>
<hr>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//儿子兄弟表示法</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    ElementType Element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">firstChild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">NextSibling</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>二叉树有左右之分，5中形态(空，根，根左，根左右，根右)，其中特殊的二叉树有，<strong>满二叉树，完全二叉树(不满但是结点序号和顺序必须一致)，二叉排序树(左小右大，二分查找)，平衡二叉树(任一结点左子树和右子树深度之差不超过1)。</strong></p>
<p>操作集：</p>
</li>
<li><p>Boolean IsEmpty(struct tree *BT):判别BT是否为空；</p>
</li>
<li>Void Traversal(struct tree *BT):遍历，按某个顺序访问每个结点；<ul>
<li>void PreOrderTraversal(struct tree *BT):先序遍历—- 根，左，右；</li>
<li>void InOrderTraversal(struct tree *BT):中序遍历—-左，根，右；</li>
<li>void PostOrderTraversal(struct tree *BT):后序遍历—-左，右，根；</li>
<li>void LevelOrderTraversal(struct tree *BT):层次遍历，从上到下，从左到右</li>
</ul>
</li>
<li>struct tree CreatBinTree():创建一个二叉树。</li>
</ul>
<p><img src="/2020/08/24/数据结构/4.jpg" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表存储</span></span><br><span class="line"><span class="comment">//儿子兄弟表示法</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">    ElementType Element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">Left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">Right</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="考-二叉树遍历"><a href="#考-二叉树遍历" class="headerlink" title="(考)二叉树遍历"></a>(考)二叉树遍历</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">(struct tree *BT)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BT)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,BT-&gt;Data);</span><br><span class="line">        PreOrderTraversal(BT-&gt;Left);</span><br><span class="line">        PreOrderTraversal(BT-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">(struct tree *BT)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(BT)&#123; </span><br><span class="line">        InOrderTraversal(BT-&gt;Left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,BT-&gt;Data);</span><br><span class="line">        InOrderTraversal(BT-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后续遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraversal</span><span class="params">(struct tree *BT)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BT)&#123; </span><br><span class="line">        PostOrderTraversal(BT-&gt;Left);</span><br><span class="line">        PostOrderTraversal(BT-&gt;Right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,BT-&gt;Data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历非递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal1</span><span class="params">(struct tree *BT,<span class="keyword">int</span> Maxsize)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">T</span>=<span class="title">BT</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> *<span class="title">S</span>=<span class="title">CreatStack</span>(<span class="title">Maxsize</span>);</span><span class="comment">//创建并初始化堆栈S</span></span><br><span class="line">	<span class="keyword">while</span>(T || !IsEmpty(S))&#123;</span><br><span class="line">		<span class="keyword">while</span>(T)&#123;<span class="comment">//一直向左并将沿途压入堆栈</span></span><br><span class="line">			Push(S,T);</span><br><span class="line">			T=T-&gt;Left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!IsEmpty(S))&#123;</span><br><span class="line">			T=Pop(S);<span class="comment">//结点弹出堆栈</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d"</span>,T-&gt;Data);<span class="comment">//访问打印结点</span></span><br><span class="line">			T=T-&gt;Right; <span class="comment">//转向右子树</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历非递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal1</span><span class="params">(struct tree *BT,<span class="keyword">int</span> Maxsize)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">T</span>=<span class="title">BT</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> *<span class="title">S</span>=<span class="title">CreatStack</span>(<span class="title">Maxsize</span>);</span><span class="comment">//创建并初始化堆栈S</span></span><br><span class="line">	<span class="keyword">while</span>(T || !IsEmpty(S))&#123;</span><br><span class="line">		<span class="keyword">while</span>(T)&#123;<span class="comment">//一直向左并将沿途压入堆栈</span></span><br><span class="line">			Push(S,T);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d"</span>,T-&gt;Data);<span class="comment">//访问打印结点</span></span><br><span class="line">			T=T-&gt;Left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!IsEmpty(S))&#123;</span><br><span class="line">			T=Pop(S);<span class="comment">//结点弹出堆栈	</span></span><br><span class="line">			T=T-&gt;Right; <span class="comment">//转向右子树</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层序遍历队列实现，每次出队时入队左右儿子结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrderTraversal</span><span class="params">(struct tree *BT)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">T</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">Q</span>;</span><span class="comment">//数组</span></span><br><span class="line">    <span class="keyword">if</span>(!BT) <span class="keyword">return</span>;</span><br><span class="line">    Q = CreatQueue(MaxSize);</span><br><span class="line">    AddQ(Q,BT);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmptyQ(Q))&#123;</span><br><span class="line">        T=DeleteQ(Q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,T-&gt;Data);</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;Left) AddQ(Q,T-&gt;Left);</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;Right) AddQ(Q,T-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码测试</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElementType int</span></span><br><span class="line"><span class="comment">//儿子兄弟表示法</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line"> 	ElementType Data;</span><br><span class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">Left</span>;</span></span><br><span class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">Right</span>;</span></span><br><span class="line"> &#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">data</span>;</span></span><br><span class="line">	<span class="keyword">int</span> top;</span><br><span class="line">	<span class="keyword">int</span> Maxsize;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct Stack* <span class="title">CreatStack</span><span class="params">(<span class="keyword">int</span> Maxsize)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> *<span class="title">p</span>=(<span class="title">Stack</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Stack</span>));</span></span><br><span class="line">	p-&gt;data=(tree*)<span class="built_in">malloc</span>(Maxsize*<span class="keyword">sizeof</span>(struct tree));</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span> || p-&gt;data==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"内存不足"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		<span class="comment">//exit(0); </span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		p-&gt;top=<span class="number">-1</span>;</span><br><span class="line">		p-&gt;Maxsize=Maxsize;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(struct Stack *s,struct tree *p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s-&gt;top==s-&gt;Maxsize<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"堆栈满"</span>); 		</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		s-&gt;data[++(s-&gt;top)]=*p; <span class="comment">//※※※※※※※重点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct tree* <span class="title">Pop</span><span class="params">(struct Stack *s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s-&gt;top==<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"堆栈空"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;(s-&gt;data[(s-&gt;top)--]);<span class="comment">//※※※※※※重点</span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(struct Stack *p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;top==<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">struct tree *<span class="title">add</span><span class="params">(struct tree *q,ElementType k,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n==<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">p</span>=(<span class="title">tree</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">tree</span>));</span></span><br><span class="line">		p-&gt;Data=k;</span><br><span class="line">		p-&gt;Left=<span class="literal">NULL</span>;</span><br><span class="line">		p-&gt;Right=<span class="literal">NULL</span>;</span><br><span class="line">		q-&gt;Left=p;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		struct tree *p=(tree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct tree));</span><br><span class="line">		p-&gt;Data=k;</span><br><span class="line">		p-&gt;Left=<span class="literal">NULL</span>;</span><br><span class="line">		p-&gt;Right=<span class="literal">NULL</span>;</span><br><span class="line">		q-&gt;Right=p;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct tree *<span class="title">creat</span><span class="params">(ElementType k)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">q</span>=(<span class="title">tree</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">tree</span>));</span></span><br><span class="line">	q-&gt;Data=k;</span><br><span class="line">	q-&gt;Left=<span class="literal">NULL</span>;</span><br><span class="line">	q-&gt;Right=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">struct Stack* <span class="title">CreatStack</span><span class="params">(<span class="keyword">int</span> Maxsize)</span></span>;	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">(struct tree *BT)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">(struct tree *BT)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraversal</span><span class="params">(struct tree *BT)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal1</span><span class="params">(struct tree *BT,<span class="keyword">int</span> Maxsize)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal1</span><span class="params">(struct tree *BT,<span class="keyword">int</span> Maxsize)</span></span>;</span><br><span class="line">	<span class="function">struct tree *<span class="title">add</span><span class="params">(struct tree *q,ElementType k,<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">	<span class="function">struct tree *<span class="title">creat</span><span class="params">(ElementType k)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">q</span>,*<span class="title">w</span>,*<span class="title">root</span>;</span>	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="comment">//p=CreatStack(10);</span></span><br><span class="line">	q=creat(<span class="number">1</span>);</span><br><span class="line">	q=add(q,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">	q=add(q,<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">	root=w=q;</span><br><span class="line">	w=w-&gt;Right;</span><br><span class="line">	q=q-&gt;Left; </span><br><span class="line">	w=add(w,<span class="number">6</span>,<span class="number">1</span>);</span><br><span class="line">	w=add(w,<span class="number">7</span>,<span class="number">2</span>);</span><br><span class="line">	q=add(q,<span class="number">4</span>,<span class="number">1</span>);</span><br><span class="line">	q=add(q,<span class="number">5</span>,<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"先序遍历\n"</span>); </span><br><span class="line">	PreOrderTraversal(root);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n中序遍历\n"</span>);</span><br><span class="line">	InOrderTraversal(root);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n后序遍历\n"</span>);</span><br><span class="line">	PostOrderTraversal(root);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n中序遍历非递归算法\n"</span>);</span><br><span class="line">	InOrderTraversal1(root,<span class="number">7</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n先序遍历非递归算法\n"</span>);</span><br><span class="line">	PreOrderTraversal1(root,<span class="number">7</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二叉树遍历应用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出二叉树中叶子结点，先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">(struct tree *BT)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BT)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!BT-&gt;Left &amp;&amp; !BT-&gt;Right)<span class="comment">//没有二子结点</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,BT-&gt;Data);</span><br><span class="line">        PreOrderTraversal(BT-&gt;Left);</span><br><span class="line">        PreOrderTraversal(BT-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求树高度，左右子树最高高度+1</span></span><br><span class="line"><span class="comment">//使用后序遍历改</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PostOrderGetHeight</span><span class="params">(struct tree *BT)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> HL,HR,MaxH;</span><br><span class="line">    <span class="keyword">if</span>(BT)&#123; </span><br><span class="line">        HL=PreOrderGetHeight(BT-&gt;Left);<span class="comment">//左子树深度</span></span><br><span class="line">        HR=PreOrderGetHeight(BT-&gt;Right);<span class="comment">//右子树深度</span></span><br><span class="line">        MaxH=(HL&gt;HR)?HL:HR;<span class="comment">//取左右最大值</span></span><br><span class="line">        <span class="keyword">return</span> (MaxH+<span class="number">1</span>);<span class="comment">//返回树深度</span></span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>二元运算表达式树及其遍历</strong></p>
<p><img src="/2020/08/24/数据结构/5.jpg" alt></p>
<p><strong>通过两种序列(必须有中序遍历)就可以确定一个唯一的二叉树</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树静态链表</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MaxTree 10</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> ElementType char</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> Tree int</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> Null -1 <span class="comment">//编译器定义Null（0）</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    ElementType Element;</span><br><span class="line">    Tree Left;</span><br><span class="line">    Tree Right;</span><br><span class="line">&#125;T1[MaxTree],T2[MaxTree];<span class="comment">//数组中没有出现的下标就是根</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/08/24/数据结构/6.jpg" alt></p>
<p><img src="/2020/08/24/数据结构/7.jpg" alt></p>
<p><img src="/2020/08/24/数据结构/8.jpg" alt><img src="/2020/08/24/数据结构/9.jpg" alt></p>
<hr>
<h5 id="考-二叉搜索树-查找树-排序树"><a href="#考-二叉搜索树-查找树-排序树" class="headerlink" title="(考)二叉搜索树/查找树/排序树"></a>(考)二叉搜索树/查找树/排序树</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(ElementType X,struct tree *BST)</span></span>;<span class="comment">//从二叉排序树BST中查找元素X，返回其所在结点的地址；</span></span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">(struct tree *BST)</span></span>;<span class="comment">//找出最小元素所在结点地址</span></span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">(struct tree *BST)</span></span>;</span><br><span class="line"><span class="function">struct tree <span class="title">Insert</span><span class="params">(ElementType X,struct tree *BST)</span></span>;</span><br><span class="line"><span class="function">struct tree <span class="title">Delete</span><span class="params">(ElementType X,struct tree *BST)</span></span>;</span><br></pre></td></tr></table></figure>
<p>插入操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct tree* <span class="title">Insert</span><span class="params">(ElementType k,struct tree *BST)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!BST)&#123;</span><br><span class="line">		<span class="comment">//若原树为空，则生成一个结点得二叉排序树 </span></span><br><span class="line">		BST=(tree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct tree));<span class="comment">////!!!!!!!!!!!!!!!!!!!!!!!!!不用结构体声明，直接申请，指针已经传进来了 </span></span><br><span class="line">		BST-&gt;data=k;</span><br><span class="line">		BST-&gt;Left=BST-&gt;Right=<span class="literal">NULL</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;<span class="comment">//找插入元素得位置 </span></span><br><span class="line">		<span class="keyword">if</span>(k&lt;BST-&gt;data)&#123;</span><br><span class="line">			BST-&gt;Left=Insert(k,BST-&gt;Left);<span class="comment">//递归插入左子树 </span></span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(k&gt;BST-&gt;data)&#123;</span><br><span class="line">			BST-&gt;Right=Insert(k,BST-&gt;Right);<span class="comment">//递归插入右子树 </span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//else k已经存在，什么都不做 </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> BST; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>删除操作</strong></p>
<ul>
<li>当为叶子结点直接删除</li>
<li>当删除结点只有一个儿子，用儿子代替</li>
<li>当左右都有儿子结点都有二子结点时<ul>
<li>右子树最小元素代替</li>
<li>左子树的最大元素</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若为叶子结点直接删除</span></span><br><span class="line"><span class="comment">//若只有一个孩子结点则用孩子结点代替自己</span></span><br><span class="line"><span class="comment">//若 左右都有儿子结点且都有孙子结点</span></span><br><span class="line"><span class="comment">//用右子树最小元素 或左子树最大元素代替 </span></span><br><span class="line"><span class="function">struct tree* <span class="title">Delete</span><span class="params">(ElementType k,struct tree *BST)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> 	<span class="title">tree</span> *<span class="title">Tmp</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(!BST)<span class="built_in">printf</span>(<span class="string">"要删除的结点不存在"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(k&lt;BST-&gt;data)</span><br><span class="line">		BST-&gt;Left=Delete(k,BST-&gt;Left);<span class="comment">//左子树递归查找要删除的结点 </span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(k&gt;BST-&gt;data)</span><br><span class="line">		BST-&gt;Right=Delete(k,BST-&gt;Right);<span class="comment">//右子树递归查找要删除的结点 </span></span><br><span class="line">	<span class="keyword">else</span> <span class="comment">//找到要删除的结点 </span></span><br><span class="line">		<span class="keyword">if</span>(BST-&gt;Left &amp;&amp; BST-&gt;Right)&#123;</span><br><span class="line">			Tmp=FindMin(BST-&gt;Right);<span class="comment">//右子树最小结点 </span></span><br><span class="line">			<span class="comment">//Tmp=FindMax(BST-&gt;Left);//左子树最大结点 </span></span><br><span class="line">			</span><br><span class="line">			BST-&gt;data=Tmp-&gt;data;</span><br><span class="line">			BST-&gt;Right=Delete(BST-&gt;data,BST-&gt;Right);<span class="comment">//删除右子树中最小元素 </span></span><br><span class="line">			<span class="comment">//BST-&gt;Left=Delete(BST-&gt;data,BST-&gt;Left);</span></span><br><span class="line">			</span><br><span class="line">		&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">			Tmp=BST;</span><br><span class="line">			<span class="keyword">if</span>(!BST-&gt;Left)<span class="comment">//没有左节点，将右节点当自己 </span></span><br><span class="line">				BST=BST-&gt;Right;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(!BST-&gt;Right)<span class="comment">//没有右节点，将左结点当自己 </span></span><br><span class="line">				BST=BST-&gt;Left;</span><br><span class="line">			<span class="comment">//两个都没有直接释放自己 此时BST=NULL; </span></span><br><span class="line">			<span class="built_in">free</span>(Tmp);<span class="comment">//释放这个结点 释放的是结构体的空间，并不是指针变量，指针变量是临时的，用完就没了 </span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> BST;<span class="comment">//返回的是当前结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElementType int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//左小右大树 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">	ElementType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">Left</span>;</span></span><br><span class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">Right</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct tree* <span class="title">FindMin</span><span class="params">(struct tree *BST)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(BST-&gt;Left)&#123;</span><br><span class="line">		FindMin(BST-&gt;Left);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> BST;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">struct tree* <span class="title">FindMax</span><span class="params">(struct tree *BST)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(BST-&gt;Right)&#123;</span><br><span class="line">		FindMax(BST-&gt;Right);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> BST;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">(struct tree *BT)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(BT)&#123; </span><br><span class="line">        InOrderTraversal(BT-&gt;Left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,BT-&gt;data);</span><br><span class="line">        InOrderTraversal(BT-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">(struct tree *BT)</span></span>;</span><br><span class="line">	<span class="function">struct tree* <span class="title">FindMin</span><span class="params">(struct tree *BST)</span></span>;</span><br><span class="line">	<span class="function">struct tree* <span class="title">FindMax</span><span class="params">(struct tree *BST)</span></span>;</span><br><span class="line">	<span class="function">struct tree* <span class="title">Insert</span><span class="params">(ElementType k,struct tree *BST)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">p</span>=<span class="title">NULL</span>,*<span class="title">w</span>,*<span class="title">q</span>;</span></span><br><span class="line">	p=Insert(<span class="number">6</span>,p);</span><br><span class="line">	p=Insert(<span class="number">2</span>,p);</span><br><span class="line">	p=Insert(<span class="number">1</span>,p);</span><br><span class="line">	p=Insert(<span class="number">3</span>,p);</span><br><span class="line">	p=Insert(<span class="number">7</span>,p);</span><br><span class="line">	p=Insert(<span class="number">9</span>,p);</span><br><span class="line">	w=FindMin(p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"最小值%d\n"</span>,w-&gt;data);</span><br><span class="line">	q=FindMax(p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"最大值%d\n"</span>,q-&gt;data);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"中序遍历\n"</span>);</span><br><span class="line">	InOrderTraversal(p);</span><br><span class="line">	p=Delete(<span class="number">2</span>,p); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	InOrderTraversal(p);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h5><ul>
<li>任一结点左子树和右子树深度之差不超过1</li>
<li>搜索树结点不同插入次序，将导致不同的<strong>深度</strong>和平均查找长度<strong>ASL</strong></li>
<li>斐波那契数列(1,1,2,3,5,….)，nh=n(h-1)+n(h-2)+1 =》给定结点数为n的平衡二叉树（AVL）最大高度为<strong>h=O(log2n)</strong>.</li>
</ul>
<p>调整：</p>
<ul>
<li>RR旋转</li>
</ul>
<p><img src="/2020/08/24/数据结构/12.jpg" alt></p>
<ul>
<li>LL旋转</li>
</ul>
<p><img src="/2020/08/24/数据结构/13.jpg" alt></p>
<ul>
<li>LR旋转</li>
</ul>
<p><img src="/2020/08/24/数据结构/14.jpg" alt></p>
<hr>
<h5 id="考-线索二叉树"><a href="#考-线索二叉树" class="headerlink" title="(考)线索二叉树"></a>(考)线索二叉树</h5><p>线索化</p>
<ul>
<li>若无左子树，则将左指针指向其前驱结点；</li>
<li>若无右子树，则将右指针指向其后继结点。</li>
</ul>
<p>前驱结点</p>
<ul>
<li>若左指针为线索，则其指向结点为前驱结点；</li>
<li>若左指针为左孩子，则其左子树的最右侧结点为前驱结点。</li>
</ul>
<p>后继结点</p>
<ul>
<li>若右指针为线索，则其指向结点为后继结点；</li>
<li>若右指针为右孩子，则其右子树的最左侧结点为后继结点。</li>
</ul>
<p><img src="/2020/08/24/数据结构/32.jpg" alt></p>
<p>中序线索二叉树，将<strong>中序序列</strong>中对应的结点结构中空指针设置<strong>前驱</strong>和<strong>后继</strong>，并设置头节点，指向<strong>根</strong>和<strong>尾结点</strong>，而<strong>左子树最后一个元素的前驱</strong>和<strong>右子树的尾结点元素的后继</strong>指向头节点。称为线索链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElementType int</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">	ElementType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">Left</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">Right</span>;</span></span><br><span class="line">	<span class="keyword">int</span> Ltag;<span class="comment">//0代表左孩子,1代表前驱 </span></span><br><span class="line">	<span class="keyword">int</span> Rtag; <span class="comment">//0代表右孩子,1代表后继 </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//中序线索二叉树线索化 </span></span><br><span class="line"><span class="comment">//&amp;引用结构体得到的只是一个对象，不能当指针用，需要加*标记为指针才可以使用 ！！！！！！！！！！ </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThread</span><span class="params">(struct ThreadNode *&amp;p,struct ThreadNode *&amp;pre)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		InThread(p-&gt;Left,pre);<span class="comment">//递归左孩子</span></span><br><span class="line">		</span><br><span class="line">		 <span class="comment">//对叶子节点的左孩子制作线索，线索为前驱结点 </span></span><br><span class="line">		<span class="keyword">if</span>(p-&gt;Left==<span class="literal">NULL</span>)&#123;</span><br><span class="line">			p-&gt;Left=pre;</span><br><span class="line">			p-&gt;Ltag=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//从第二个结点开始前驱结点的右孩子如果空则将其线索指向当前结点 </span></span><br><span class="line">		<span class="keyword">if</span>(pre!=<span class="literal">NULL</span> &amp;&amp; pre-&gt;Right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">			pre-&gt;Right=p;</span><br><span class="line">			pre-&gt;Rtag=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		pre=p;<span class="comment">//将前驱结点置为当前结点 </span></span><br><span class="line">		</span><br><span class="line">		InThread(p-&gt;Right,pre);<span class="comment">//递归右孩子 </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化和收尾工作，传入第一个NULL为前驱，</span></span><br><span class="line"><span class="comment">将最后一个结点右孩子后继设置为NULL，也可以设置一个头节点，</span></span><br><span class="line"><span class="comment">将第一个结点的左孩子和最后一个结点的右孩子指向头节点，</span></span><br><span class="line"><span class="comment">头节点中左孩子和右孩子指向根节点和最后一个结点*/</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createThread</span><span class="params">(struct ThreadNode *p)</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">pre</span>=<span class="title">NULL</span>;</span></span><br><span class="line"><span class="keyword">if</span> (p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">	InThread(p,pre);</span><br><span class="line">	pre-&gt;Right=<span class="literal">NULL</span>;</span><br><span class="line">	pre-&gt;Rtag=<span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//线索二叉树的遍历</span></span><br><span class="line"> <span class="function">struct ThreadNode *<span class="title">Firstnode</span><span class="params">(struct ThreadNode *p)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">while</span>(p-&gt;Ltag==<span class="number">0</span>)</span><br><span class="line"> 		p=p-&gt;Left;		</span><br><span class="line"> 	<span class="keyword">return</span> p;</span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="function">struct ThreadNode *<span class="title">Nextnode</span><span class="params">(struct ThreadNode *p)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">if</span>(p-&gt;Rtag==<span class="number">0</span>)</span><br><span class="line"> 		<span class="keyword">return</span> Firstnode(p-&gt;Right);</span><br><span class="line"> 	<span class="keyword">else</span> </span><br><span class="line"> 		<span class="keyword">return</span> p-&gt;Right;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//遍历主函数</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">(struct ThreadNode *T)</span></span>&#123;</span><br><span class="line"> 	<span class="keyword">for</span>(struct ThreadNode *p=Firstnode(T);p!=<span class="literal">NULL</span>;p=Nextnode(p))</span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"%d"</span>,p-&gt;data);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">struct ThreadNode* <span class="title">Insert</span><span class="params">(ElementType k,struct ThreadNode *BST)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!BST)&#123;</span><br><span class="line">		<span class="comment">//若原树为空，则生成一个结点得二叉排序树 </span></span><br><span class="line">		BST=(ThreadNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ThreadNode));<span class="comment">////!!!!!!!!!!!!!!!!!!!!!!!!!不用结构体声明，直接申请，指针已经传进来了 </span></span><br><span class="line">		BST-&gt;data=k;</span><br><span class="line">		BST-&gt;Ltag=BST-&gt;Rtag=<span class="number">0</span>;</span><br><span class="line">		BST-&gt;Left=BST-&gt;Right=<span class="literal">NULL</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;<span class="comment">//找插入元素得位置 </span></span><br><span class="line">		<span class="keyword">if</span>(k&lt;BST-&gt;data)&#123;</span><br><span class="line">			BST-&gt;Left=Insert(k,BST-&gt;Left);<span class="comment">//递归插入左子树 </span></span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(k&gt;BST-&gt;data)&#123;</span><br><span class="line">			BST-&gt;Right=Insert(k,BST-&gt;Right);<span class="comment">//递归插入右子树 </span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//else k已经存在，什么都不做 </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> BST; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序线索二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">struct ThreadNode* <span class="title">Insert</span><span class="params">(ElementType k,struct ThreadNode *BST)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">createThread</span><span class="params">(struct ThreadNode *p)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">(struct ThreadNode *T)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">(struct ThreadNode *BT)</span></span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">p</span>=<span class="title">NULL</span>;</span>	</span><br><span class="line">	p=Insert(<span class="number">6</span>,p);</span><br><span class="line">	p=Insert(<span class="number">2</span>,p);</span><br><span class="line">	p=Insert(<span class="number">1</span>,p);</span><br><span class="line">	p=Insert(<span class="number">3</span>,p);</span><br><span class="line">	p=Insert(<span class="number">7</span>,p);</span><br><span class="line">	p=Insert(<span class="number">9</span>,p);</span><br><span class="line">	createThread(p);</span><br><span class="line">	Inorder(p);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="完全二叉搜索树"><a href="#完全二叉搜索树" class="headerlink" title="完全二叉搜索树"></a>完全二叉搜索树</h5><p>完全二叉搜索树=二叉搜索树+完全二叉树</p>
<p>特点：不浪费空间，使用数组更加方便，使用层序遍历==直接输出</p>
<p>算法思想:首先从小到大排序，找根节点，分为左右子树，再递归将左右子树分别填入</p>
<hr>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p><strong>优先队列：</strong>特殊的“<strong>队列</strong>”，取出元素的顺序是依照元素的<strong>优先权（关键字）</strong>大小，而不是元素进入队列的先后顺序。</p>
<p><img src="/2020/08/24/数据结构/15.jpg" alt></p>
<p>基本结构体及构建</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span>&#123;</span></span><br><span class="line">	ElementType *data;<span class="comment">//储存堆元素的数组</span></span><br><span class="line">	<span class="keyword">int</span> Size;<span class="comment">//堆当前元素的个数 </span></span><br><span class="line">	<span class="keyword">int</span> Capacity; <span class="comment">//堆的最大容量 </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="function">struct HeapStruct* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> Maxsize)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span> *<span class="title">p</span>=(<span class="title">HeapStruct</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">HeapStruct</span>));</span></span><br><span class="line">	p-&gt;data=(ElementType*)<span class="built_in">malloc</span>((Maxsize+<span class="number">1</span>) * <span class="keyword">sizeof</span>(ElementType));<span class="comment">//从1开始存 </span></span><br><span class="line">	p-&gt;Size=<span class="number">0</span>;</span><br><span class="line">	p-&gt;Capacity=Maxsize;</span><br><span class="line">	p-&gt;data[<span class="number">0</span>]=Maxdata;</span><br><span class="line">	<span class="comment">//定义哨兵，大于堆中所有可能元素的值，便于以后更快操作；</span></span><br><span class="line">	<span class="keyword">return</span> p; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>堆的插入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*保证插入后仍然是完全二叉树，且每个结点都是其子树所有结点的最大值 </span></span><br><span class="line"><span class="comment">1.按顺序插入到最后一个位置</span></span><br><span class="line"><span class="comment">2.调整整个树使其称为最大堆 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(struct HeapStruct *p,ElementType k)</span></span>&#123;</span><br><span class="line">	<span class="comment">//将元素k插入最大堆p，其中p-&gt;data[0]已经定义为哨兵 </span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">if</span>(IsFull(p))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"最大堆已满"</span>);</span><br><span class="line">		<span class="keyword">return</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	i=++p-&gt;Size;<span class="comment">//i指向插入堆中的最后一个元素的位置 </span></span><br><span class="line">	<span class="keyword">for</span>(;p-&gt;data[i/<span class="number">2</span>]&lt;k;i/=<span class="number">2</span>)<span class="comment">//如果不加哨兵，需要增加 &amp;&amp; i&gt;1  </span></span><br><span class="line">		p-&gt;data[i]=p-&gt;data[i/<span class="number">2</span>];<span class="comment">//向下过滤结点i/2是父节点位置 </span></span><br><span class="line">	p-&gt;data[i]=k; <span class="comment">//将k插入 	</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>堆的删除</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*删除最大元素或某个元素用最后一个元素代替当前位置，</span></span><br><span class="line"><span class="comment">并调整堆为最大堆，向下比较，并交换位置 */</span></span><br><span class="line"><span class="function">ElementType <span class="title">DeleteMax</span><span class="params">(struct HeapStruct *p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> parent,Child;</span><br><span class="line">	ElementType Max,temp;</span><br><span class="line">	<span class="keyword">if</span>(IsEmpty(p))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"最大堆已空"</span>);</span><br><span class="line">		<span class="keyword">return</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	Max=p-&gt;data[<span class="number">1</span>];<span class="comment">//取出树根结点最大值；</span></span><br><span class="line">	<span class="comment">/*用最大堆中最后一个元素从根节点开始向上过滤下层结点*/</span></span><br><span class="line">	temp=p-&gt;data[p-&gt;Size--];<span class="comment">//取出最后一个元素并且将整体Size减一 </span></span><br><span class="line">	<span class="keyword">for</span>(Parent=<span class="number">1</span>;Parent*<span class="number">2</span>&lt;=p-&gt;Size;Parent=Child);&#123;<span class="comment">//第三个函数在每一轮结束后执行 </span></span><br><span class="line">		Child=Parent*<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>((Child!=p-&gt;Size) &amp;&amp; (p-&gt;data[Child]&lt;p-&gt;data[Child+<span class="number">1</span>]))</span><br><span class="line">			Child++;<span class="comment">//Child 指向左右子结点较大者</span></span><br><span class="line">		<span class="keyword">if</span>(temp&gt;=p-&gt;data[Child])<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span> p-&gt;data[Parent]=p-&gt;data[Child]; </span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;data[Parent]=temp;</span><br><span class="line">	<span class="keyword">return</span> Max;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最小堆</span></span><br><span class="line"><span class="function">ElementType <span class="title">DeleteMin</span><span class="params">(struct HeapStruct *p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> Parent,Child;</span><br><span class="line">	ElementType Min,temp;</span><br><span class="line">	<span class="keyword">if</span>(IsEmpty(p))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"最小堆已空"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	Min=p-&gt;data[<span class="number">1</span>];<span class="comment">//取出树根结点最小值；</span></span><br><span class="line">	<span class="comment">/*用最小堆中最后一个元素从根节点开始向上过滤下层结点*/</span></span><br><span class="line">	temp=p-&gt;data[p-&gt;Size--];<span class="comment">//取出最后一个元素并且将整体Size减一 </span></span><br><span class="line">	<span class="keyword">for</span>(Parent=<span class="number">1</span>;Parent*<span class="number">2</span>&lt;=p-&gt;Size;Parent=Child)&#123;<span class="comment">//第三个函数在每一轮结束后执行 </span></span><br><span class="line">		Child=Parent*<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>((Child!=p-&gt;Size) &amp;&amp; (p-&gt;data[Child]&gt;p-&gt;data[Child+<span class="number">1</span>]))</span><br><span class="line">			Child++;<span class="comment">//Child 指向左右子结点较小者</span></span><br><span class="line">		<span class="keyword">if</span>(temp&lt;=p-&gt;data[Child])<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span> p-&gt;data[Parent]=p-&gt;data[Child]; </span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;data[Parent]=temp;</span><br><span class="line">	<span class="keyword">return</span> Min;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如何建立一个堆？<ul>
<li>一个一个的插入(效率低)</li>
<li>在<strong>线性时间复杂度</strong>下建立最大堆。<ul>
<li>将N个元素按输入顺序存入，先满足<strong>完全二叉树的结构性</strong>；</li>
<li>调整各结点位置，以满足最大堆的<strong>有序特性。</strong></li>
</ul>
</li>
</ul>
</li>
<li>思路：从倒数第一个有儿子的父结点(size/2)开始一个一个调整(删除结点的思路)为堆</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调整为最大堆</span></span><br><span class="line"><span class="function">struct HeapStruct* <span class="title">CreatMaxHeap</span><span class="params">(struct HeapStruct *p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> Parent,Child,Parent1,Child1;</span><br><span class="line">	ElementType temp;</span><br><span class="line">	<span class="keyword">if</span>(IsEmpty(p))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"最大堆已空"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">/*用最后一个元素从倒数第一个父结点开始自下向上过滤结点*/</span></span><br><span class="line">	<span class="keyword">for</span>(Parent=p-&gt;Size/<span class="number">2</span>;Parent&gt;=<span class="number">1</span>;Parent--)&#123;<span class="comment">//从倒数第一个父结点开始依次递减 ， </span></span><br><span class="line">	Child=Parent*<span class="number">2</span>;</span><br><span class="line">	Parent1=Parent;</span><br><span class="line">	Child1=Child;</span><br><span class="line">		<span class="keyword">for</span>(;Parent1*<span class="number">2</span>&lt;=p-&gt;Size;Parent1=Child1)&#123;</span><br><span class="line">			Child1=Parent1*<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>((Parent1*<span class="number">2</span>!=p-&gt;Size)&amp;&amp;(p-&gt;data[Child1]&lt;p-&gt;data[Child1+<span class="number">1</span>]))</span><br><span class="line">				Child1++;</span><br><span class="line">			<span class="keyword">if</span>(p-&gt;data[Child1]&gt;p-&gt;data[Parent1])&#123;</span><br><span class="line">				temp=p-&gt;data[Parent1];</span><br><span class="line">				p-&gt;data[Parent1]=p-&gt;data[Child1];</span><br><span class="line">				p-&gt;data[Child1]=temp; </span><br><span class="line">		    &#125;		</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//调整为最小堆</span></span><br><span class="line"><span class="function">struct HeapStruct* <span class="title">CreatMinHeap</span><span class="params">(struct HeapStruct *p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> Parent,Child,Parent1,Child1;</span><br><span class="line">	ElementType temp;</span><br><span class="line">	<span class="keyword">if</span>(IsEmpty(p))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"最小堆已空"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">/*用最后一个元素从倒数第一个父结点开始自下向上过滤结点*/</span></span><br><span class="line">	<span class="keyword">for</span>(Parent=p-&gt;Size/<span class="number">2</span>;Parent&gt;=<span class="number">1</span>;Parent--)&#123;<span class="comment">//从倒数第一个父结点开始依次递减 ， </span></span><br><span class="line">	Child=Parent*<span class="number">2</span>;</span><br><span class="line">	Parent1=Parent;</span><br><span class="line">	Child1=Child;</span><br><span class="line">		<span class="keyword">for</span>(;Parent1*<span class="number">2</span>&lt;=p-&gt;Size;Parent1=Child1)&#123;</span><br><span class="line">			Child1=Parent1*<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>((Parent1*<span class="number">2</span>!=p-&gt;Size)&amp;&amp;(p-&gt;data[Child1]&gt;p-&gt;data[Child1+<span class="number">1</span>]))</span><br><span class="line">				Child1++;</span><br><span class="line">			<span class="keyword">if</span>(p-&gt;data[Child1]&lt;p-&gt;data[Parent1])&#123;</span><br><span class="line">				temp=p-&gt;data[Parent1];</span><br><span class="line">				p-&gt;data[Parent1]=p-&gt;data[Child1];</span><br><span class="line">				p-&gt;data[Child1]=temp; </span><br><span class="line">		    &#125;		</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsFull</span><span class="params">(struct HeapStruct *p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;Capacity==p-&gt;Size)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(struct HeapStruct *p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;Size==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">struct HeapStruct* <span class="title">CreatHeap</span><span class="params">(struct HeapStruct *p)</span></span>;</span><br><span class="line">	<span class="function">ElementType <span class="title">DeleteMax</span><span class="params">(struct HeapStruct *p)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(struct HeapStruct *p,ElementType k)</span></span>;</span><br><span class="line">	<span class="function">struct HeapStruct* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> Maxsize)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span> *<span class="title">p</span>=<span class="title">Create</span>(12);</span></span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line"><span class="comment">//	Insert1(p,83);</span></span><br><span class="line"><span class="comment">//	Insert1(p,87);</span></span><br><span class="line"><span class="comment">//	Insert1(p,43);</span></span><br><span class="line"><span class="comment">//	Insert1(p,72);</span></span><br><span class="line"><span class="comment">//	Insert1(p,91);</span></span><br><span class="line"><span class="comment">//	for(int i=1;i&lt;6;i++)printf("%d",p-&gt;data[i]);</span></span><br><span class="line"><span class="comment">//	int a=DeleteMax(p);</span></span><br><span class="line"><span class="comment">//	int b=DeleteMin(p);</span></span><br><span class="line"><span class="comment">//	printf("\n");</span></span><br><span class="line"><span class="comment">//	for(int i=1;i&lt;5;i++)printf("%d",p-&gt;data[i]);</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">13</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">		p-&gt;data[i]=a;</span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;Size=<span class="number">12</span>;</span><br><span class="line">	p=CreatMinHeap(p); </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">13</span>;j++)<span class="built_in">printf</span>(<span class="string">"%d "</span>,p-&gt;data[j]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	a=DeleteMin(p);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">12</span>;j++)<span class="built_in">printf</span>(<span class="string">"%d "</span>,p-&gt;data[j]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="哈夫曼树和编码"><a href="#哈夫曼树和编码" class="headerlink" title="哈夫曼树和编码"></a>哈夫曼树和编码</h4><h5 id="考-哈夫曼树"><a href="#考-哈夫曼树" class="headerlink" title="(考)哈夫曼树"></a>(考)哈夫曼树</h5><p>定义：<strong>带权路径长度(WPL)：</strong>设二叉树有<strong>n个叶子结点</strong>，每个叶子结点带有权值$W<em>k$,从根结点到每个叶子结点的长度为$L_k$,则每个叶子结点的带权路径长度之和就是：$WPL=\sum</em>{k=1}^nW_kL_k$</p>
<p><strong>最优二叉树</strong>或<strong>哈夫曼树</strong>：<strong>WPL</strong>最小的二叉树。</p>
<p>哈夫曼树构造：</p>
<ul>
<li>由一段<strong>有序序列</strong>（可以用<strong>堆</strong>实现，效率更高<strong>O(NlogN</strong>)）中挑选<strong>最小的两个合并为一棵树</strong>后将权值重新加入排序，重复上述过程直到创建树成功.</li>
</ul>
<p>哈夫曼树特点：</p>
<ul>
<li>没有度为<strong>1</strong>的结点</li>
<li><strong>n</strong>个叶子结点的哈夫曼树共有<strong>2n-1</strong>个结点；</li>
<li>哈夫曼树的任意非叶子结点的<strong>左右子树交换后</strong>仍是哈夫曼树；</li>
<li>对同一组权值<strong>{$w_1,w_2,…,w_n$},</strong>存在<strong>不同构</strong>的哈夫曼树，但<strong>WPL</strong>值相同。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElementType int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mindata 0; </span></span><br><span class="line"><span class="comment">//数据结构部分</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span>&#123;</span></span><br><span class="line">	ElementType data;<span class="comment">//数据 </span></span><br><span class="line">	<span class="keyword">int</span> Weight;<span class="comment">//权重 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">Left</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">Right</span>;</span> </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">data</span>;</span><span class="comment">//储存堆元素的数组</span></span><br><span class="line">	<span class="keyword">int</span> Size;<span class="comment">//堆当前元素的个数 </span></span><br><span class="line">	<span class="keyword">int</span> Capacity; <span class="comment">//堆的最大容量 </span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsFull</span><span class="params">(struct HeapStruct *p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;Capacity==p-&gt;Size)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(struct HeapStruct *p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;Size==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个堆</span></span><br><span class="line"><span class="function">struct HeapStruct* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> Maxsize)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span> *<span class="title">p</span>=(<span class="title">HeapStruct</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">HeapStruct</span>));</span></span><br><span class="line">	p-&gt;data=(tree*)<span class="built_in">malloc</span>((Maxsize+<span class="number">1</span>)*<span class="keyword">sizeof</span>(struct tree));<span class="comment">//从1开始存 </span></span><br><span class="line">	p-&gt;Size=<span class="number">0</span>;</span><br><span class="line">	p-&gt;Capacity=Maxsize;</span><br><span class="line">	p-&gt;data[<span class="number">0</span>].data= Mindata;<span class="comment">//结构体中嵌套结构体是对象，并不是指针</span></span><br><span class="line">	p-&gt;data[<span class="number">0</span>].Weight=Mindata;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Maxsize;i++)&#123;</span><br><span class="line">		p-&gt;data[i].Left=<span class="literal">NULL</span>;<span class="comment">//树的左右指针要置空，否则最后遍历无法运行</span></span><br><span class="line">		p-&gt;data[i].Right=<span class="literal">NULL</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//定义哨兵，大于堆中所有可能元素的值，便于以后更快操作；</span></span><br><span class="line">	<span class="keyword">return</span> p; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//将一个结构体插入最小堆</span></span><br><span class="line"><span class="comment">//将结构体插入最小堆 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertMin</span><span class="params">(struct HeapStruct *p,struct tree q)</span></span>&#123;</span><br><span class="line">	<span class="comment">//将元素k插入最小堆p，其中p-&gt;data[0]已经定义为哨兵 </span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">if</span>(IsFull(p))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"最小堆已满"</span>);</span><br><span class="line">		<span class="keyword">return</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	i=++p-&gt;Size;<span class="comment">//i指向插入堆中的最后一个元素的位置 </span></span><br><span class="line">	<span class="keyword">for</span>(;p-&gt;data[i/<span class="number">2</span>].Weight&gt;q.Weight;i/=<span class="number">2</span>)<span class="comment">//如果不加哨兵，需要增加 &amp;&amp; i&gt;1  </span></span><br><span class="line">		p-&gt;data[i]=p-&gt;data[i/<span class="number">2</span>];<span class="comment">//向下过滤结点i/2是父节点位置 </span></span><br><span class="line">	p-&gt;data[i]=q; <span class="comment">//将q插入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除最小元素</span></span><br><span class="line"><span class="function">struct tree <span class="title">DeleteMin</span><span class="params">(struct HeapStruct *p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> Parent,Child;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tree</span> <span class="title">Min</span>,<span class="title">temp</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(IsEmpty(p))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"最小堆已空"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">	</span><br><span class="line">	Min=p-&gt;data[<span class="number">1</span>];<span class="comment">//取出树根结点最小值；</span></span><br><span class="line">	<span class="comment">/*用最大堆中最后一个元素从根节点开始向上过滤下层结点*/</span></span><br><span class="line">	temp=p-&gt;data[p-&gt;Size--];<span class="comment">//取出最后一个元素并且将整体Size减一 </span></span><br><span class="line">	<span class="keyword">for</span>(Parent=<span class="number">1</span>;Parent*<span class="number">2</span>&lt;=p-&gt;Size;Parent=Child)&#123;<span class="comment">//第三个函数在每一轮结束后执行 </span></span><br><span class="line">		Child=Parent*<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>((Child!=p-&gt;Size) &amp;&amp; (p-&gt;data[Child].Weight&gt;p-&gt;data[Child+<span class="number">1</span>].Weight))</span><br><span class="line">			Child++;<span class="comment">//Child 指向左右子结点较大者</span></span><br><span class="line">		<span class="keyword">if</span>(temp.Weight&lt;=p-&gt;data[Child].Weight)<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span> p-&gt;data[Parent]=p-&gt;data[Child]; </span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;data[Parent]=temp;</span><br><span class="line">	<span class="keyword">return</span> Min;<span class="comment">//返回的是一个结构体变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调整一个堆为最小堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatMinHeap</span><span class="params">(struct HeapStruct *&amp;p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> Parent,Child,Parent1,Child1;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tree</span> <span class="title">temp</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(IsEmpty(p))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"最小堆已空"</span>);</span><br><span class="line">		<span class="keyword">return</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">/*用最后一个元素从倒数第一个父结点开始自下向上过滤结点*/</span></span><br><span class="line">	<span class="keyword">for</span>(Parent=p-&gt;Size/<span class="number">2</span>;Parent&gt;=<span class="number">1</span>;Parent--)&#123;<span class="comment">//从倒数第一个父结点开始依次递减 ， </span></span><br><span class="line">	Child=Parent*<span class="number">2</span>;</span><br><span class="line">	Parent1=Parent;</span><br><span class="line">	Child1=Child;</span><br><span class="line">		<span class="keyword">for</span>(;Parent1*<span class="number">2</span>&lt;=p-&gt;Size;Parent1=Child1)&#123;</span><br><span class="line">			Child1=Parent1*<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>((Parent1*<span class="number">2</span>!=p-&gt;Size)&amp;&amp;(p-&gt;data[Child1].Weight&gt;p-&gt;data[Child1+<span class="number">1</span>].Weight))</span><br><span class="line">				Child1++;</span><br><span class="line">			<span class="keyword">if</span>(p-&gt;data[Child1].Weight&lt;p-&gt;data[Parent1].Weight)&#123;</span><br><span class="line">				temp=p-&gt;data[Parent1];</span><br><span class="line">				p-&gt;data[Parent1]=p-&gt;data[Child1];</span><br><span class="line">				p-&gt;data[Child1]=temp; </span><br><span class="line">		    &#125;		</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//哈夫曼树  </span></span><br><span class="line"><span class="function">struct tree* <span class="title">Huffmantree</span><span class="params">(struct HeapStruct *&amp;p)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tree</span> *<span class="title">T</span>;</span></span><br><span class="line">	CreatMinHeap(p);<span class="comment">//调整堆</span></span><br><span class="line">	<span class="keyword">while</span>(p-&gt;Size&gt;<span class="number">1</span>)&#123;<span class="comment">//做p-&gt;size -1 次合并</span></span><br><span class="line">		T=(tree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct tree));<span class="comment">//建立新的结点</span></span><br><span class="line">		T-&gt;Left=(tree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct tree));<span class="comment">//没有申请空间不能使用 </span></span><br><span class="line">		T-&gt;Right=(tree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct tree));</span><br><span class="line">		*T-&gt;Left=DeleteMin(p);<span class="comment">//将从堆中删除的结构体置入新T的左子结点</span></span><br><span class="line">		*T-&gt;Right=DeleteMin(p);<span class="comment">//将从堆中删除的结构体置入新T的右子结点</span></span><br><span class="line">		</span><br><span class="line">		T-&gt;Weight=T-&gt;Left-&gt;Weight+T-&gt;Right-&gt;Weight;<span class="comment">//合并左右子结点权重</span></span><br><span class="line">		InsertMin(p,*T);<span class="comment">//将T插入到堆中重新排序</span></span><br><span class="line">	&#125;</span><br><span class="line">	*T=DeleteMin(p);<span class="comment">//最后一个结点就是根节点，直接弹出</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> T; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//一定要和函数对应上TAT 特别是改了以后</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">(struct tree *BT)</span></span>; </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">(struct tree *BT)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">CreatMinHeap</span><span class="params">(struct HeapStruct *&amp;p)</span></span>;</span><br><span class="line">	<span class="function">struct tree* <span class="title">Huffmantree</span><span class="params">(struct HeapStruct *&amp;p)</span></span>;</span><br><span class="line">	<span class="function">struct tree <span class="title">DeleteMin</span><span class="params">(struct HeapStruct *p)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">InsertMin</span><span class="params">(struct HeapStruct *p,struct tree q)</span></span>;</span><br><span class="line">	<span class="function">struct HeapStruct* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> Maxsize)</span></span>;</span><br><span class="line">	</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span> *<span class="title">pp</span>;</span></span><br><span class="line">    pp=Create(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;pp-&gt;data[i].Weight);	</span><br><span class="line">	&#125;</span><br><span class="line">    pp-&gt;Size=<span class="number">6</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d "</span>,pp-&gt;data[i].Weight);	</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    w=Huffmantree(pp);</span><br><span class="line">    PreOrderTraversal(w);<span class="comment">//先序遍历</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	InOrderTraversal(w);<span class="comment">//中序遍历</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h5><p>Q:给定一段字符串，如何对字符进行编码，可以使该字符串的编码存储空间最少？</p>
<ul>
<li>按照<strong>频率</strong>给定<strong>权值</strong></li>
</ul>
<p>Q:如何避免二义性？</p>
<ul>
<li><strong>前缀码：任何字符的编码都不是另一字符编码的前缀</strong></li>
</ul>
<p>用二叉树进行编码：</p>
<ul>
<li><strong>左右分支：0、1</strong></li>
<li>字符只在<strong>叶结点</strong>上</li>
</ul>
<p><img src="/2020/08/24/数据结构/16.jpg" alt></p>
<hr>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><ul>
<li>表示<strong>多对多</strong>的关系</li>
<li>包含<ul>
<li>一组顶点：通常用 <strong>V(Vertex)</strong> 表示顶点集合</li>
<li>一组边：通常用 <strong>E(Edge)</strong> 表示边的集合<ul>
<li>边是顶点对：<strong>(v,w) ∈ E</strong>，其中 <strong>v,w ∈ V</strong></li>
<li>有向边 <strong><v,w></v,w></strong> 表示从 <strong>v</strong> 指向 <strong>w</strong> 的边(单行线)</li>
<li>不考虑重边和自回路</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="图的表示法"><a href="#图的表示法" class="headerlink" title="图的表示法"></a>图的表示法</h4><h5 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h5><p><img src="/2020/08/24/数据结构/17.jpg" alt></p>
<p>Q:对于无向图的存储，怎样可以省一半的空间？</p>
<ul>
<li>用一个长度为N/(N+1)/2 的1 维数组 A 存储{$G<em>{00},G</em>{10},G<em>{11},G</em>{20},G<em>{21},…,G</em>{n-1, 0}，…，G<em>{n-1,n-1}$},则$G</em>{i,j}$在A中对应的下标为：$(i*(i+1)/2+j)$</li>
<li>对于网络，只要把$G[i][j]$的值定义为边&lt;$v_i,v_j$&gt;的权重即可。</li>
</ul>
<p><img src="/2020/08/24/数据结构/18.jpg" alt></p>
<p>对于稀疏图浪费空间(稠密图还是很合算)，也浪费时间。</p>
<h5 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h5><p><img src="/2020/08/24/数据结构/19.jpg" alt></p>
<ul>
<li>方便找任一顶点的所有“邻接点”</li>
<li>节约稀疏图的空间<ul>
<li>需要N个头指针 + 2E 个结点（每个结点至少2个域）</li>
</ul>
</li>
<li>只方便计算无向图的度，不太适合有向图</li>
</ul>
<h4 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h4><h5 id="考-DFS-深度优先搜索"><a href="#考-DFS-深度优先搜索" class="headerlink" title="(考)DFS 深度优先搜索"></a>(考)DFS 深度优先搜索</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归访问,抽象表示，类似于树的先序遍历，栈也可</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Vertex V)</span></span>&#123;<span class="comment">//传入一个起始点</span></span><br><span class="line">    visited[V]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> ( V的每个邻接点 W )</span><br><span class="line">        <span class="keyword">if</span>(!visited [W])</span><br><span class="line">            DFS(w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先搜索 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(struct GNode *Graph,<span class="keyword">int</span> n,<span class="keyword">int</span> visited[])</span></span>&#123;<span class="comment">//G为已知图，n为起始点 </span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,Graph-&gt;Data[n]);<span class="comment">//先输出起始顶点，再输出访问的其他顶点</span></span><br><span class="line">	visited[n]=<span class="number">1</span>;<span class="comment">//事先将起始顶点标记为true</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Graph-&gt;Nv;i++)&#123;</span><br><span class="line">		 <span class="keyword">if</span>(Graph-&gt;G[n][i]!=<span class="number">0</span> &amp;&amp; visited[i]==<span class="number">0</span>)<span class="comment">///若第i个顶点与G-&gt;Data[n]有关，并且未被访问</span></span><br><span class="line">        &#123;</span><br><span class="line">            DFS(Graph,i,visited);<span class="comment">///用递归的方式继续搜寻</span></span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Graph-&gt;Nv;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[i]==<span class="number">0</span>)<span class="comment">///此循环用于判断顶点是否访问完成</span></span><br><span class="line">        &#123;</span><br><span class="line">             DFS(Graph,i,visited);<span class="comment">///用递归的方式继续搜寻，直至所有顶点访问完毕</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>采用队列实现</li>
</ul>
<p>若有N个顶点、E条边，时间复杂度是</p>
<ul>
<li>用邻接表存储图，有O(N+E)</li>
<li>用临界矩阵存储图，有O(N^2)</li>
</ul>
<h5 id="考-BFS-广度优先搜索"><a href="#考-BFS-广度优先搜索" class="headerlink" title="(考)BFS 广度优先搜索"></a>(考)BFS 广度优先搜索</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类似层序遍历队列实现，每次出队时入队相邻未访问元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Vertex V)</span></span>&#123;</span><br><span class="line">    visited[V]= <span class="literal">true</span>;</span><br><span class="line">    Enqueue(V,Q);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">        V = Dequeue(Q);</span><br><span class="line">        <span class="keyword">for</span>(V 的每个邻接点 W)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[W])&#123;</span><br><span class="line">                visited[W] = <span class="literal">true</span>;</span><br><span class="line">                Enqueue(W,Q);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElementType int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WeightType int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DataType int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxsize 5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	ElementType Data[Maxsize];</span><br><span class="line">	<span class="keyword">int</span> front;</span><br><span class="line">	<span class="keyword">int</span> rear;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function">struct Node* <span class="title">initNode</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">p</span>;</span></span><br><span class="line">	p=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">	p-&gt;front=<span class="number">0</span>;</span><br><span class="line">	p-&gt;rear=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环队列 数组内只放放n-1个元素防止误判 满/空 尾(rear)进头(front)出 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(struct Node *p,ElementType k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>((p-&gt;rear+<span class="number">1</span>)%Maxsize==p-&gt;front)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"队列满"</span>); </span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		p-&gt;rear=(p-&gt;rear+<span class="number">1</span>)%Maxsize;<span class="comment">//最后一位会变零</span></span><br><span class="line">		p-&gt;Data[p-&gt;rear]=k;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队列</span></span><br><span class="line"><span class="function">ElementType <span class="title">Delete</span><span class="params">(struct Node *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;front==p-&gt;rear)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列空"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        p-&gt;front=(p-&gt;front+<span class="number">1</span>)%Maxsize;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;Data[p-&gt;front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(struct GNode *Graph,<span class="keyword">int</span> visited[],struct Node *p)</span></span>&#123;<span class="comment">//图、起始点、顶点数量、辅助数组、辅助队列 </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Graph-&gt;Nv;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!visited[i])&#123;<span class="comment">//从未访问过该顶点 </span></span><br><span class="line">			visited[i]=<span class="number">1</span>; </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Graph-&gt;Data[i]);</span><br><span class="line">			Add(p,i);</span><br><span class="line">			<span class="keyword">while</span>(p-&gt;front!=p-&gt;rear)&#123;</span><br><span class="line">				i=Delete(p);<span class="comment">//出队需要访问的顶点下标 </span></span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Graph-&gt;Nv;j++)&#123;</span><br><span class="line">					<span class="keyword">if</span>(Graph-&gt;G[i][j]==<span class="number">1</span> &amp;&amp; !visited[j])&#123;<span class="comment">//其他顶点与改顶点有联系 且未访问 </span></span><br><span class="line">						visited[j]=<span class="number">1</span>;</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Graph-&gt;Data[j]);<span class="comment">//访问已出队的顶点 </span></span><br><span class="line">						Add(p,j);<span class="comment">//入队未访问的顶点下标 </span></span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">				&#125;				</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若有N个顶点、E条边，时间复杂度是</p>
<ul>
<li>用邻接表存储图，有O(N+E)</li>
<li>用临界矩阵存储图，有O(N^2)</li>
</ul>
<p>每调用一次<strong>BFS/BFS</strong> 就是把 <strong>V</strong> 所在的连通分量遍历了一遍。</p>
<h4 id="如何建立一个图"><a href="#如何建立一个图" class="headerlink" title="如何建立一个图"></a>如何建立一个图</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span> *<span class="title">PtrToGNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Nv;<span class="comment">//顶点数</span></span><br><span class="line">    <span class="keyword">int</span> Ne;<span class="comment">//边数</span></span><br><span class="line">    WeightType G[MaxVertexNum][MaxVertexNum];</span><br><span class="line">    DataType Data[MaxVertexNum];<span class="comment">//存放顶点的数据，顶点表vertex</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToGNode MGraph;<span class="comment">//指针别名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤1：初始化一个有VertexNum 个顶点但 没有边 的图</span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">int</span> Vertex;<span class="comment">//用顶点下标表示顶点，为整型</span></span><br><span class="line"><span class="function">MGraph <span class="title">CreateGraph</span><span class="params">(<span class="keyword">int</span> VertexNum)</span></span>&#123;</span><br><span class="line">    Vertex V,W;<span class="comment">//区分出入的顶点个数VertexNum</span></span><br><span class="line">    MGraph Graph;</span><br><span class="line">    </span><br><span class="line">    Graph = (MGraph)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct GNode));</span><br><span class="line">    Graph-&gt;Nv = VertexNum;</span><br><span class="line">    Graph-&gt;Ne = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意这里默认顶点编号从0开始，到(Graph-&gt;Nv-1)</span></span><br><span class="line">    <span class="keyword">for</span>(V=<span class="number">0</span>;V&lt;Graph-&gt;Nv;V++)</span><br><span class="line">        <span class="keyword">for</span> (W=<span class="number">0</span>;W&lt;Graph-&gt;Nv;W++)</span><br><span class="line">            Graph-&gt;G[V][W]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//步骤2：向图中插入边</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ENode</span> *<span class="title">PtrToENode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ENode</span>&#123;</span></span><br><span class="line">  Vertex V1,V2;<span class="comment">//有向边&lt;V1,V2&gt;,两个顶点</span></span><br><span class="line">  WeightType Weight;<span class="comment">//权重</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToENode Edge;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertEdge</span><span class="params">(MGraph Graph,Edge E)</span></span>&#123;</span><br><span class="line">    <span class="comment">//插入边，有向图只用插一边&lt;V1,V2&gt;，无向图要两边</span></span><br><span class="line">    Graph-&gt;G[E-&gt;V1][E-&gt;V2]=E-&gt;Weight;</span><br><span class="line">    <span class="comment">//无向图 插入&lt;V2,V1&gt;</span></span><br><span class="line">    Graph-&gt;G[E-&gt;V2][E-&gt;V1]=E-&gt;Weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//完整的建立一个图</span></span><br><span class="line"><span class="function">MGraph <span class="title">BuildGraph</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MGraph Graph;</span><br><span class="line">    Edge E;</span><br><span class="line">    Vertex V;</span><br><span class="line">    <span class="keyword">int</span> Nv,i;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Nv);</span><br><span class="line">    Graph = CreateGraph(Nv);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;(Graph-&gt;Ne));<span class="comment">//直接读入 赋值边 输入函数不能加花里胡哨的东西</span></span><br><span class="line">    <span class="keyword">if</span> (Graph-&gt;Ne!=<span class="number">0</span>)&#123;</span><br><span class="line">        E = (Edge)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ENode));<span class="comment">//临时</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Graph-&gt;Ne;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;E-&gt;V1,&amp;E-&gt;V2,&amp;E-&gt;Weight);</span><br><span class="line">            InsertEdge(Graph,E);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果顶点有数据的话，读入数据</span></span><br><span class="line">    <span class="keyword">for</span>(V=<span class="number">0</span>; V&lt;Graph-&gt;Nv;V++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">" %c"</span>,&amp;(Graph-&gt;Data[V]));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//考试应急</span></span><br><span class="line"><span class="keyword">int</span> G[MAXN][MAXN],Nv,Ne;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildGraph</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,v1,v2,w;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Nv);</span><br><span class="line">    <span class="comment">//创建图</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Nv;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;Nv;j++)&#123;</span><br><span class="line">            G[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Ne);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Ne;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;v1,&amp;v2,&amp;w);</span><br><span class="line">        <span class="comment">//插入</span></span><br><span class="line">        G[v1][v2]=w;</span><br><span class="line">        G[v2][v1]=w;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="单元最短路径"><a href="#单元最短路径" class="headerlink" title="单元最短路径"></a>单元最短路径</h4><h5 id="考-Dijkstra"><a href="#考-Dijkstra" class="headerlink" title="(考)Dijkstra"></a>(考)Dijkstra</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Dijkstra</span>(<span class="title">int</span> <span class="title">n</span>,<span class="title">int</span> <span class="title">v</span>,<span class="title">Type</span> <span class="title">dist</span>[],<span class="title">int</span> <span class="title">prev</span>[],<span class="title">Type</span> **<span class="title">c</span>)&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> s[maxint];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dist[i]=c[v][i];</span><br><span class="line">        s[i]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(dist[i]==maxint)</span><br><span class="line">            prev[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            prev[i]=v;<span class="comment">//当前i顶点对应的前一个顶点下标</span></span><br><span class="line">    &#125;</span><br><span class="line">    dist[v]=<span class="number">0</span>;s[v]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=maxint;</span><br><span class="line">        <span class="keyword">int</span> u=v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((!s[j])&amp;&amp;(dist[j]&lt;temp))&#123;</span><br><span class="line">                u=j;</span><br><span class="line">                temp = dist[j];</span><br><span class="line">            &#125;</span><br><span class="line">            s[u]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((!s[j])&amp;&amp;(c[u][j]&lt;maxint))&#123;</span><br><span class="line">                    Type newdist =dist[u]+c[u][j];</span><br><span class="line">                    <span class="keyword">if</span>(newdist&lt;dist[j])&#123;</span><br><span class="line">                        dist[j]=newdist;</span><br><span class="line">                        prev[j] = u;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><p>定义：</p>
<ul>
<li>是一棵树<ul>
<li>无回路</li>
<li><code>V</code>个顶点一定有<code>V-1</code>条边</li>
</ul>
</li>
<li>是生成树<ul>
<li>包含全部顶点</li>
<li><code>V-1</code>条边都在图里</li>
</ul>
</li>
<li>边的权重和最小</li>
</ul>
<p><strong>等价于图连通</strong></p>
<p>贪心算法：</p>
<ul>
<li>贪：每一步要求最<strong>好</strong></li>
<li>好：权重最小的边</li>
<li><strong>需要约束：</strong><ul>
<li>只能用途中有的边</li>
<li>只能正好用掉<code>V-1</code>条边</li>
<li>不能有回路</li>
</ul>
</li>
</ul>
<hr>
<h5 id="考-Prim算法"><a href="#考-Prim算法" class="headerlink" title="(考)Prim算法"></a>(考)Prim算法</h5><p>算法思想：</p>
<p>从连通网 N={V,E}中的某一顶点U0出发，选择与它关联的具有最小权值的边(U0,v)，将其顶点加入到生成树的顶点集合U中。以后每一步从集合U中的所有顶点边中选择一条最小权值边(u,v)同时此边(u,v)所连接的顶点不包含在集合U中的任何顶点，则把它的顶点加入到集合U中。如此继续下去，直到网中的所有顶点都加入到生成树顶点集合U中为止。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(|V|2)适合稠密图</span></span><br><span class="line"><span class="comment">//Prim</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Void</span> <span class="title">Prim</span>(<span class="title">int</span> <span class="title">n</span>,<span class="title">Type</span> **<span class="title">c</span>)&#123;</span></span><br><span class="line">    Type lowcost[maxint];</span><br><span class="line">    <span class="keyword">int</span> closest[maxint];</span><br><span class="line">    <span class="keyword">bool</span> s[maxint];</span><br><span class="line">    s[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        lowcost[i]=c[<span class="number">1</span>][i];</span><br><span class="line">        closest[i]=<span class="number">1</span>;</span><br><span class="line">        s[i]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        Type min=inf;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//找中使用权值最小的顶点j</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>;k&lt;=n;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((lowcost[k]&lt;min)&amp;&amp; (!s[k]))&#123;</span><br><span class="line">                min=lowcost[k];</span><br><span class="line">                j=k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到符合贪心选择方式的边，将顶点j加入到集合S</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;j&lt;&lt;<span class="string">' '</span>&lt;&lt;closest[j]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        s[j]=<span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//找到一条边后，更新数组closest和lowcost</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        	<span class="keyword">if</span>((c[j][k]&lt;lowcost[k]) &amp;&amp; (!s[k]))&#123;</span><br><span class="line">            	lowcost[k]=c[j][k];</span><br><span class="line">                closest[k]=j;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h5><p>算法思想：</p>
<p>把森林合并成树</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度（使用最小堆放权重集合 并查集检查回路）O(|E|log|E|) 适合稀疏图</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="考-查找和内部排序"><a href="#考-查找和内部排序" class="headerlink" title="(考)查找和内部排序"></a>(考)查找和内部排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElementType int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(ElementType *x,ElementType *y)</span></span>&#123;</span><br><span class="line">    ElementType temp;</span><br><span class="line">    temp = *x;</span><br><span class="line">    *x=*y;</span><br><span class="line">    *y=temp;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap1</span><span class="params">(ElementType &amp;x,ElementType &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    temp = x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=temp;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Bubble_Sort</span><span class="params">(ElementType A[],<span class="keyword">int</span> N)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> x[]=&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>&#125;; </span><br><span class="line">	Bubble_Sort(x,<span class="number">6</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>,x[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="简单排序"><a href="#简单排序" class="headerlink" title="简单排序"></a>简单排序</h4><h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><p>算法思想：比较相邻两个元素大小，若从小到大排则将大元素始终置后，<strong>每一趟</strong>完成会将<strong>最大的元素</strong>放到确定的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble_Sort</span><span class="params">(ElementType A[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> p=N<span class="number">-1</span>;p&gt;=<span class="number">0</span>;p--)&#123;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;<span class="comment">//判断是否在一趟排序过程中有序，没有触发Swap</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;p;i++)&#123;<span class="comment">//一趟</span></span><br><span class="line">    <span class="keyword">if</span>(A[i]&gt;A[i+<span class="number">1</span>])&#123;</span><br><span class="line">    	<span class="comment">//a=&amp;A[i];</span></span><br><span class="line">    	<span class="comment">//b=&amp;A[i+1];</span></span><br><span class="line">        <span class="comment">//Swap(a,b);</span></span><br><span class="line">        Swap1(A[i],A[i+<span class="number">1</span>]);</span><br><span class="line">        flag=<span class="number">1</span>;<span class="comment">//发生了交换</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//适合单向链表，同一顺序，稳定 最好O(N)最坏O(N^2) 平均O(N^2)</span></span><br></pre></td></tr></table></figure>
<h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><p>算法思想：从前往后取数，并从取数位置从后向前比较，将每一个数向后移，插入到合适得位置，从<strong>第一个数开始</strong>，<strong>第零个不动</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insertion_Sort</span><span class="params">(ElementType A[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">    ElementType tmp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> P=<span class="number">1</span>;P&lt;N;P++)&#123;</span><br><span class="line">		tmp=A[P];<span class="comment">//摸下一张，从前往后 </span></span><br><span class="line">		<span class="keyword">for</span>( i=P;i&gt;<span class="number">0</span> &amp;&amp; A[i<span class="number">-1</span>]&gt;tmp;i--)&#123;</span><br><span class="line">			A[i]=A[i<span class="number">-1</span>];<span class="comment">//移出空位 </span></span><br><span class="line">		&#125;</span><br><span class="line">	    A[i]=tmp;<span class="comment">//新牌落位 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="comment">//稳定，最好O(N)最坏O(N^2) 平均O(N^2)</span></span><br></pre></td></tr></table></figure>
<h5 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h5><p>算法思想：通过设定增量序列，实现插入排序</p>
<p><img src="/2020/08/24/数据结构/20.jpg" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shell_sort</span><span class="params">(ElementType A[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">    ElementType tmp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> D=N/<span class="number">2</span>;D&gt;<span class="number">0</span>;D/=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> P=D;P&lt;N;P++)&#123;</span><br><span class="line">		tmp=A[P];<span class="comment">//摸下一张，从前往后 </span></span><br><span class="line">		<span class="keyword">for</span>( i=P;i&gt;=D &amp;&amp; A[i-D]&gt;tmp;i-=D)&#123;</span><br><span class="line">			A[i]=A[i-D];<span class="comment">//移出空位 </span></span><br><span class="line">		&#125;</span><br><span class="line">	    A[i]=tmp;<span class="comment">//新牌落位 </span></span><br><span class="line">	&#125;		</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;<span class="comment">//最坏O(N^2) Hibbard 增量 Dk=2^k-1-相邻元素互质，不互质小增量排序没效果，最坏(O^3/2)</span></span><br></pre></td></tr></table></figure>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Selection_Sort</span><span class="params">(ElementType A[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        MinPosition = ScanForMin(A,i,N<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//从A[i]到A[i-1]中找到最小元，并将其位置赋值给MinPosition</span></span><br><span class="line">        Swap1(A[i],A[MinPosition]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1 时间O(NlogN) 并且需要额外O(N)空间，并且复制元素需要时间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap_Sort</span><span class="params">(ElementType A[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    BuildHeap(A);<span class="comment">// O(n)小顶堆/最小堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        TmpA[i]=DeleteMin(A);<span class="comment">//O(logN)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)<span class="comment">//O(N)</span></span><br><span class="line">        A[i]=TmpA[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//算法2 时间2NlogN-O(NloglogN) </span></span><br><span class="line"><span class="comment">//通过调整最大堆，完成后将根结点最大元素与最小元素交换位置，并剔除最大元素，将剩余元素继续执行上述过程 由小到大排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap_Sort</span><span class="params">(ElementType A[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=N/<span class="number">2</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)<span class="comment">//BuildHeap</span></span><br><span class="line">        PercDown(A , i ,N);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=N<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        swap(A[<span class="number">0</span>],A[i]);<span class="comment">//deleteMax</span></span><br><span class="line">        PercDown(A,<span class="number">0</span>,i);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PercDown</span><span class="params">(ElementType A[],<span class="keyword">int</span> i,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> parent,child;</span><br><span class="line">    ElementType temp;</span><br><span class="line">	<span class="keyword">for</span>(parent=i;parent*<span class="number">2</span>+<span class="number">1</span>&lt;N;parent=child)&#123;<span class="comment">//A[0]不是哨兵了</span></span><br><span class="line">	        child=parent*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">	        <span class="keyword">if</span>(child!=N<span class="number">-1</span> &amp;&amp; A[child]&lt;A[child+<span class="number">1</span>])</span><br><span class="line">	            child++;</span><br><span class="line">	        <span class="keyword">if</span>(A[parent]&lt;A[child])&#123;</span><br><span class="line">				temp=A[parent];</span><br><span class="line">	            A[parent]=A[child];</span><br><span class="line">	            A[child]=temp;</span><br><span class="line">	        &#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>核心：<strong>两个有序子列得归并</strong></p>
<p>思想：比较两个序列中元素得大小，挑出小元素放到第三个序列中,适合<strong>外部排序</strong></p>
<p><img src="/2020/08/24/数据结构/21.jpg" alt></p>
<h5 id="递归方式"><a href="#递归方式" class="headerlink" title="递归方式"></a>递归方式</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间 O(N) 两个子列一共有N个元素</span></span><br><span class="line"><span class="comment">//L=左边起始位置(Aptr) R=右边起始位置(Bptr) RightEnd=右边终点位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(ElementType A[],ElementType TmpA[],<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> RightEnd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leftEnd=R<span class="number">-1</span>;<span class="comment">//左边终点位置，假设左右两列挨着 在一个数组里面</span></span><br><span class="line">    <span class="keyword">int</span> Tmp=L;<span class="comment">//存放结果得数组得初始位置，从第二个数组得哪个地方开始</span></span><br><span class="line">    <span class="keyword">int</span> NumElements = RightEnd - L + <span class="number">1</span>;<span class="comment">//归并结束后总元素数</span></span><br><span class="line">    <span class="keyword">while</span>(L&lt;=leftEnd &amp;&amp; R&lt;=RightEnd)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[L]&lt;=A[R])TmpA[Tmp++]=A[L++];</span><br><span class="line">        <span class="keyword">else</span> TmpA[Tmp++]=A[R++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(L&lt;=leftEnd)</span><br><span class="line">        TmpA[Tmp++]=A[L++];<span class="comment">//直接复制左边剩下的</span></span><br><span class="line">    <span class="keyword">while</span>(R&lt;=RightEnd)</span><br><span class="line">        TmpA[Tmp++]=A[R++];<span class="comment">//直接复制右边剩下得</span></span><br><span class="line">    <span class="comment">//两个只会执行一个</span></span><br><span class="line">    <span class="comment">//最后将TmpA数组倒回A数组，RightEnd 始终没变(传进来后，传进来前始终在变)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;NumElements;i++,RightEnd--)</span><br><span class="line">        A[RightEnd]=TmpA[RightEnd];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分而治之 时间复杂度T(N)=T(N/2)+T(N/2)+O(N)=&gt;T(N)=O(NlogN) 稳定</span></span><br><span class="line"><span class="comment">//RightEnd 始终在变 递归调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MSort</span><span class="params">(ElementType A[],ElementType TmpA[],<span class="keyword">int</span> L,<span class="keyword">int</span> RightEnd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Center;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;RightEnd)&#123;</span><br><span class="line">        Center = (L+RightEnd)/<span class="number">2</span>;</span><br><span class="line">        MSort(A,TmpA,L,Center);</span><br><span class="line">        MSort(A,TmpA,Center+<span class="number">1</span>,RightEnd);</span><br><span class="line">        Merge(A,TmpA,L,Center+<span class="number">1</span>,RightEnd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统一接口 重要！！！！</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_sort</span><span class="params">(ElementType A[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    ElementType *TmpA;</span><br><span class="line">    TmpA=(ElementType*)<span class="built_in">malloc</span>(N * <span class="keyword">sizeof</span>(ElementType));</span><br><span class="line">    <span class="keyword">if</span> (TmpA!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        MSort(A,TmpA,<span class="number">0</span>,N<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">free</span>(TmpA);<span class="comment">//释放临时数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> Error(<span class="string">"内存不足"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过程图解：解决一段导回去一段</p>
<p><img src="/2020/08/24/数据结构/22.jpg" alt></p>
<p><img src="/2020/08/24/数据结构/23.jpg" alt></p>
<p><strong>不合算，重复malloc</strong></p>
<p><img src="/2020/08/24/数据结构/24.jpg" alt></p>
<h5 id="非递归方式"><a href="#非递归方式" class="headerlink" title="非递归方式"></a>非递归方式</h5><p>算法思想：利用临时数组，两边倒</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge1</span><span class="params">(ElementType A[],ElementType TmpA[],<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> RightEnd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leftEnd=R<span class="number">-1</span>;<span class="comment">//左边终点位置，假设左右两列挨着 在一个数组里面</span></span><br><span class="line">    <span class="keyword">int</span> Tmp=L;<span class="comment">//存放结果得数组得初始位置，从第二个数组得哪个地方开始</span></span><br><span class="line">    <span class="keyword">int</span> NumElements = RightEnd - L + <span class="number">1</span>;<span class="comment">//归并结束后总元素数</span></span><br><span class="line">    <span class="keyword">while</span>(L&lt;=leftEnd &amp;&amp; R&lt;=RightEnd)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[L]&lt;=A[R])TmpA[Tmp++]=A[L++];</span><br><span class="line">        <span class="keyword">else</span> TmpA[Tmp++]=A[R++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(L&lt;=leftEnd)</span><br><span class="line">        TmpA[Tmp++]=A[L++];<span class="comment">//直接复制左边剩下的</span></span><br><span class="line">    <span class="keyword">while</span>(R&lt;=RightEnd)</span><br><span class="line">        TmpA[Tmp++]=A[R++];<span class="comment">//直接复制右边剩下得</span></span><br><span class="line">    <span class="comment">//两个只会执行一个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_pass</span><span class="params">(ElementType A[],ElementType TmpA[],<span class="keyword">int</span> N,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> length)</span></span>&#123;<span class="comment">//length = 当前有序子序列长度</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=N<span class="number">-2</span>*length;i+=<span class="number">2</span>*length)</span><br><span class="line">        Merge1(A,TmpA,i,i+length,i+<span class="number">2</span>*length<span class="number">-1</span>);<span class="comment">//将A中元素归并到TmpA而不直接倒回来</span></span><br><span class="line">    <span class="comment">//处理最后两个</span></span><br><span class="line">    <span class="keyword">if</span>(i+length&lt;N)<span class="comment">//归并最后两个子列</span></span><br><span class="line">        Merge1(A,TmpA,i,i+length,N<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//最后剩一个,直接倒进去就可以了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;N;j++)TmpA[j]=A[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统一接口 重要！！！！</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_sort1</span><span class="params">(ElementType A[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    ElementType *TmpA;</span><br><span class="line">    <span class="keyword">int</span> length=<span class="number">1</span>;<span class="comment">//长度为1开始一次两个</span></span><br><span class="line">    TmpA=(ElementType*)<span class="built_in">malloc</span>(N * <span class="keyword">sizeof</span>(ElementType));</span><br><span class="line">    <span class="keyword">if</span> (TmpA!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(length&lt;N)&#123;</span><br><span class="line">            Merge_pass(A,TmpA,N,length);</span><br><span class="line">        	length *=<span class="number">2</span>;</span><br><span class="line">            Merge_pass(TmpA,A,N,length);</span><br><span class="line">            length *=<span class="number">2</span>;<span class="comment">//两边确保最后一次将TmpA中得序列倒回 A中</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="built_in">free</span>(TmpA);<span class="comment">//释放临时数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> Error(<span class="string">"内存不足"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>算法思想：<strong>分而治之(递归)</strong>，首先随机找一个数作为主元，将集合分为以主元为标识得左右两集合，通过递归将两个集合排序，最后合并三部分(左集合，主元，右集合)。</p>
<p><img src="/2020/08/24/数据结构/25.jpg" alt></p>
<p><img src="/2020/08/24/数据结构/26.jpg" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最好情况，每次主元中分两个数组O(nlogn) 最坏O(N^2)</span></span><br><span class="line"><span class="comment">//选取头 中 尾得中位数 采用交换得方式，将头 中 尾处理为小到大得序列，选中间</span></span><br><span class="line"><span class="function">ElementType <span class="title">Median3</span><span class="params">(ElementType A[],<span class="keyword">int</span> Left,<span class="keyword">int</span> Right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Center=(Left+Right)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(A[Left]&gt;A[Center])</span><br><span class="line">        Swap(A[Left],A[Center]);</span><br><span class="line">    <span class="keyword">if</span>(A[Left]&gt;A[Right])</span><br><span class="line">        Swap(A[Left],A[Right]);</span><br><span class="line">    <span class="keyword">if</span>(A[Center]&gt;A[Right])</span><br><span class="line">        Swap(A[Center],A[Right]);</span><br><span class="line">    <span class="comment">//A[Left]&lt;=A[Center]&lt;=A[Right]</span></span><br><span class="line">    Swap(A[Center],A[Right<span class="number">-1</span>]);<span class="comment">//将pivot藏到右边倒数第二个，</span></span><br><span class="line">    <span class="comment">//只需考虑A[Left+1],A[Right-2]，因为第一个和最后一个已经比它小和大</span></span><br><span class="line">    <span class="keyword">return</span> A[Right<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/08/24/数据结构/27.jpg" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quicksort</span><span class="params">(ElementType A[],<span class="keyword">int</span> Left,<span class="keyword">int</span> Right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Right<span class="number">-1</span>&gt;<span class="number">0</span> &amp;&amp; Left+<span class="number">1</span>&lt;Right)&#123;<span class="comment">//判断数组是否越界，越界直接退出</span></span><br><span class="line">	<span class="keyword">int</span> Pivot=Median3(A,Left,Right);</span><br><span class="line">    <span class="keyword">int</span> i=Left;</span><br><span class="line">    <span class="keyword">int</span> j=Right<span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>( ; ; )&#123;</span><br><span class="line">        <span class="comment">//A[Left+1],A[Right-2]</span></span><br><span class="line">        <span class="keyword">while</span>(A[++i]&lt;Pivot)&#123;&#125;</span><br><span class="line">        <span class="keyword">while</span>(A[--j]&gt;Pivot)&#123;&#125;</span><br><span class="line">        <span class="comment">//两边都出现问题</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">            <span class="comment">//说明都出现问题 可以调换</span></span><br><span class="line">            Swap(&amp;A[i],&amp;A[j]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;<span class="comment">//i&gt;j 调换</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Swap(&amp;A[i],&amp;A[Right<span class="number">-1</span>]);<span class="comment">//将Center这个数放到自己得位置上</span></span><br><span class="line">    Quicksort(A,Left,i<span class="number">-1</span>);<span class="comment">//递归将两边集合继续划分子集排序</span></span><br><span class="line">    Quicksort(A,i+<span class="number">1</span>,Right);</span><br><span class="line">	&#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quick_Sort</span><span class="params">(ElementType A[],<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    Quicksort(A,<span class="number">0</span>,N<span class="number">-1</span>);<span class="comment">//数组下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="表排序"><a href="#表排序" class="headerlink" title="表排序"></a>表排序</h4><p>算法思想：间接排序，定义一个<strong>指针数组</strong>(数组下标/指针)作为“表”(table)</p>
<p><img src="/2020/08/24/数据结构/28.jpg" alt></p>
<ul>
<li><strong>N个数字得排列一定是由若干个独立得环组成</strong><ul>
<li>每完成一个移动就重置<code>table</code>等于自己，最后一个环放置第一个拿出去的临时数</li>
</ul>
</li>
</ul>
<p><img src="/2020/08/24/数据结构/29.jpg" alt></p>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>算法思想：采用LSD”次位优先“， 首先根据<strong>个位数</strong>的数值，在走访数值时将它们分配至编号0到9的桶子中， 接下来将这些桶子中的数值重新串接起来 ， 接着再进行一次分配，这次是根据<strong>十位数</strong>来分配 ， 接下来将这些桶子中的数值重新串接起来 ， 这时候整个数列已经排序完毕；如果排序的对象有三位数以上，则持续进行以上的动作直至<strong>最高位数</strong>为止。 </p>
<p><img src="/2020/08/24/数据结构/31.jpg" alt></p>
<h4 id="排序算法比较"><a href="#排序算法比较" class="headerlink" title="排序算法比较"></a>排序算法比较</h4><p><img src="/2020/08/24/数据结构/30.jpg" alt></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/tool/" rel="tag"># tool</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/08/20/c语言复习/" rel="next" title="c语言复习">
                <i class="fa fa-chevron-left"></i> c语言复习
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/10/13/算法设计与分析/" rel="prev" title="算法设计与分析">
                算法设计与分析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.jpg" alt="paniford">
            
              <p class="site-author-name" itemprop="name">paniford</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#数据结构复习"><span class="nav-number">1.</span> <span class="nav-text">数据结构复习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#算法复杂度"><span class="nav-number">1.0.1.</span> <span class="nav-text">算法复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#考-线性表（查找，增加，删除）"><span class="nav-number">1.0.2.</span> <span class="nav-text">(考)线性表（查找，增加，删除）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#考-堆栈"><span class="nav-number">1.0.3.</span> <span class="nav-text">(考)堆栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#队列"><span class="nav-number">1.0.4.</span> <span class="nav-text">队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#树和二叉树"><span class="nav-number">1.0.5.</span> <span class="nav-text">树和二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#二分查找"><span class="nav-number">1.0.5.1.</span> <span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#树"><span class="nav-number">1.0.5.2.</span> <span class="nav-text">树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉树"><span class="nav-number">1.0.5.3.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#考-二叉树遍历"><span class="nav-number">1.0.5.3.1.</span> <span class="nav-text">(考)二叉树遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#考-二叉搜索树-查找树-排序树"><span class="nav-number">1.0.5.3.2.</span> <span class="nav-text">(考)二叉搜索树/查找树/排序树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#平衡二叉树"><span class="nav-number">1.0.5.3.3.</span> <span class="nav-text">平衡二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#考-线索二叉树"><span class="nav-number">1.0.5.3.4.</span> <span class="nav-text">(考)线索二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#完全二叉搜索树"><span class="nav-number">1.0.5.3.5.</span> <span class="nav-text">完全二叉搜索树</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆"><span class="nav-number">1.0.5.4.</span> <span class="nav-text">堆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#哈夫曼树和编码"><span class="nav-number">1.0.5.5.</span> <span class="nav-text">哈夫曼树和编码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#考-哈夫曼树"><span class="nav-number">1.0.5.5.1.</span> <span class="nav-text">(考)哈夫曼树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#哈夫曼编码"><span class="nav-number">1.0.5.5.2.</span> <span class="nav-text">哈夫曼编码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图"><span class="nav-number">1.0.6.</span> <span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#图的表示法"><span class="nav-number">1.0.6.1.</span> <span class="nav-text">图的表示法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#邻接矩阵法"><span class="nav-number">1.0.6.1.1.</span> <span class="nav-text">邻接矩阵法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#邻接表"><span class="nav-number">1.0.6.1.2.</span> <span class="nav-text">邻接表</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#图的遍历"><span class="nav-number">1.0.6.2.</span> <span class="nav-text">图的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#考-DFS-深度优先搜索"><span class="nav-number">1.0.6.2.1.</span> <span class="nav-text">(考)DFS 深度优先搜索</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#考-BFS-广度优先搜索"><span class="nav-number">1.0.6.2.2.</span> <span class="nav-text">(考)BFS 广度优先搜索</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何建立一个图"><span class="nav-number">1.0.6.3.</span> <span class="nav-text">如何建立一个图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单元最短路径"><span class="nav-number">1.0.6.4.</span> <span class="nav-text">单元最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#考-Dijkstra"><span class="nav-number">1.0.6.4.1.</span> <span class="nav-text">(考)Dijkstra</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最小生成树"><span class="nav-number">1.0.6.5.</span> <span class="nav-text">最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#考-Prim算法"><span class="nav-number">1.0.6.5.1.</span> <span class="nav-text">(考)Prim算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Kruskal算法"><span class="nav-number">1.0.6.5.2.</span> <span class="nav-text">Kruskal算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#考-查找和内部排序"><span class="nav-number">1.0.7.</span> <span class="nav-text">(考)查找和内部排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简单排序"><span class="nav-number">1.0.7.1.</span> <span class="nav-text">简单排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#冒泡排序"><span class="nav-number">1.0.7.1.1.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#插入排序"><span class="nav-number">1.0.7.1.2.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#希尔排序"><span class="nav-number">1.0.7.1.3.</span> <span class="nav-text">希尔排序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#选择排序"><span class="nav-number">1.0.7.2.</span> <span class="nav-text">选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#堆排序"><span class="nav-number">1.0.7.2.1.</span> <span class="nav-text">堆排序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#归并排序"><span class="nav-number">1.0.7.3.</span> <span class="nav-text">归并排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#递归方式"><span class="nav-number">1.0.7.3.1.</span> <span class="nav-text">递归方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#非递归方式"><span class="nav-number">1.0.7.3.2.</span> <span class="nav-text">非递归方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快速排序"><span class="nav-number">1.0.7.4.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#表排序"><span class="nav-number">1.0.7.5.</span> <span class="nav-text">表排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基数排序"><span class="nav-number">1.0.7.6.</span> <span class="nav-text">基数排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#排序算法比较"><span class="nav-number">1.0.7.7.</span> <span class="nav-text">排序算法比较</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">paniford</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "./public/search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
